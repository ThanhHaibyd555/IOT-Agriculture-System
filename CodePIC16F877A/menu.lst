CCS PCM C Compiler, Version 5.112, 5967               10-Jun-23 22:28

               Filename:   C:\Users\Hai\Desktop\LASTGOM\2Bandungdechinhsuavafixlancuoi\FixGom4cambienbancuoi_I2C\menu.lst

               ROM used:   7437 words (91%)
                           Largest free fragment is 579
               RAM used:   151 (41%) at main() level
                           280 (76%) worst case
               Stack used: 7 locations
               Stack size: 8

*
0000:  MOVLW  18
0001:  MOVWF  0A
0002:  GOTO   000
0003:  NOP
.................... 
.................... #include <main.h>
.................... #include <16F887.h>
.................... //////////// Standard Header file for the PIC16F887 device ////////////////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996, 2020 Custom Computer Services          ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... #device PIC16F887
0004:  DATA 41,2A
0005:  DATA 0D,05
0006:  DATA 00,00
0007:  DATA 41,2A
0008:  DATA 45,18
0009:  DATA 0D,05
000A:  DATA 00,01
000B:  DATA 41,2A
000C:  DATA AB,21
000D:  DATA D7,26
000E:  DATA 4F,22
000F:  DATA C5,1E
0010:  DATA B1,06
0011:  DATA 0A,00
0012:  DATA 41,2A
0013:  DATA AB,21
0014:  DATA 57,25
0015:  DATA 41,28
0016:  DATA 3D,11
0017:  DATA A5,39
0018:  DATA 22,16
0019:  DATA A2,12
001A:  DATA 73,11
001B:  DATA 0D,05
001C:  DATA 00,00
001D:  DATA 41,2A
001E:  DATA AB,21
001F:  DATA 49,28
0020:  DATA CD,2A
0021:  DATA D8,1E
0022:  DATA B0,06
0023:  DATA 0A,00
0024:  DATA C7,22
0025:  DATA 54,10
0026:  DATA 2F,33
0027:  DATA 69,3C
0028:  DATA 2F,36
0029:  DATA E1,39
002A:  DATA 74,17
002B:  DATA 70,34
002C:  DATA F0,1F
002D:  DATA 75,38
002E:  DATA E4,30
002F:  DATA F4,32
0030:  DATA 26,3B
0031:  DATA B1,1E
0032:  DATA A5,34
0033:  DATA 26,3B
0034:  DATA B2,1E
0035:  DATA A5,34
0036:  DATA 26,3B
0037:  DATA B3,1E
0038:  DATA A5,34
0039:  DATA 26,3B
003A:  DATA B4,1E
003B:  DATA 25,18
003C:  DATA 35,36
003D:  DATA 75,10
003E:  DATA 48,2A
003F:  DATA 54,28
0040:  DATA AF,18
0041:  DATA AE,18
0042:  DATA 0D,05
0043:  DATA C8,37
0044:  DATA 73,3A
0045:  DATA 3A,10
0046:  DATA B1,1C
0047:  DATA 32,17
0048:  DATA 31,1B
0049:  DATA 38,17
004A:  DATA B1,19
004B:  DATA 37,17
004C:  DATA B1,06
004D:  DATA 8A,06
004E:  DATA 0A,00
004F:  DATA 41,2A
0050:  DATA AB,21
0051:  DATA 49,28
0052:  DATA 53,2A
0053:  DATA 41,29
0054:  DATA D4,1E
0055:  DATA 22,2A
0056:  DATA 43,28
0057:  DATA 22,16
0058:  DATA A2,12
0059:  DATA 73,11
005A:  DATA 2C,1C
005B:  DATA B0,06
005C:  DATA 0A,00
005D:  DATA 41,2A
005E:  DATA AB,21
005F:  DATA 49,28
0060:  DATA D3,22
0061:  DATA 4E,22
0062:  DATA BD,12
0063:  DATA E9,06
0064:  DATA 0A,00
0065:  DATA 41,2A
0066:  DATA AB,21
0067:  DATA 49,28
0068:  DATA 43,26
0069:  DATA CF,29
006A:  DATA C5,06
006B:  DATA 0A,00
006C:  DATA C4,20
006D:  DATA D4,22
006E:  DATA BA,29
006F:  DATA 75,00
0070:  DATA C4,20
0071:  DATA D4,22
0072:  DATA BA,26
0073:  DATA 6F,00
0074:  DATA C4,20
0075:  DATA D4,22
0076:  DATA 3A,2A
0077:  DATA 75,00
0078:  DATA C4,20
0079:  DATA D4,22
007A:  DATA BA,2B
007B:  DATA 65,00
007C:  DATA C4,20
007D:  DATA D4,22
007E:  DATA 3A,2A
007F:  DATA 68,00
0080:  DATA C4,20
0081:  DATA D4,22
0082:  DATA 3A,23
0083:  DATA 72,00
0084:  DATA C4,20
0085:  DATA D4,22
0086:  DATA BA,29
0087:  DATA 61,00
0088:  DATA 20,10
0089:  DATA 00,01
008A:  DATA 20,00
008B:  DATA 20,00
008C:  DATA 20,00
008D:  DATA 20,00
008E:  DATA 20,00
008F:  DATA 20,00
0090:  DATA 20,00
0091:  DATA 20,00
0092:  DATA 20,00
0093:  DATA 20,00
0094:  DATA 20,00
0095:  DATA 20,00
0096:  DATA 3E,00
0097:  DATA 3E,00
0098:  DATA 3E,00
0099:  DATA 3E,00
009A:  DATA 3E,00
009B:  DATA 3E,00
009C:  DATA 3E,00
009D:  DATA 3E,00
009E:  DATA 3E,00
009F:  DATA 3E,00
00A0:  DATA 3E,00
00A1:  DATA 3E,00
00A2:  DATA D4,20
00A3:  DATA 59,00
00A4:  DATA C1,2A
00A5:  DATA D4,27
00A6:  DATA 00,01
00A7:  DATA 43,26
00A8:  DATA CF,21
00A9:  DATA 4B,00
00AA:  DATA D1,2A
00AB:  DATA 41,2A
00AC:  DATA 00,01
00AD:  DATA C4,22
00AE:  DATA 4E,00
00AF:  DATA C2,27
00B0:  DATA 4D,00
00B1:  DATA 50,24
00B2:  DATA 55,27
00B3:  DATA 00,01
00B4:  DATA 4F,27
00B5:  DATA 00,01
00B6:  DATA 4F,27
00B7:  DATA 00,01
00B8:  DATA 4F,27
00B9:  DATA 00,01
00BA:  DATA 4F,27
00BB:  DATA 00,01
00BC:  DATA 4F,23
00BD:  DATA 46,00
00BE:  DATA 4F,23
00BF:  DATA 46,00
00C0:  DATA 4F,23
00C1:  DATA 46,00
00C2:  DATA 4F,23
00C3:  DATA 46,00
00C4:  DATA C1,3A
00C5:  DATA F4,37
00C6:  DATA 00,01
00C7:  DATA D2,3A
00C8:  DATA 6E,37
00C9:  DATA 69,37
00CA:  DATA 67,00
00CB:  DATA CD,27
00CC:  DATA C4,22
00CD:  DATA 3A,27
00CE:  DATA 4F,27
00CF:  DATA 45,00
00D0:  DATA CD,27
00D1:  DATA C4,22
00D2:  DATA BA,26
00D3:  DATA 41,27
00D4:  DATA D5,20
00D5:  DATA 4C,00
00D6:  DATA CD,27
00D7:  DATA C4,22
00D8:  DATA BA,20
00D9:  DATA 55,2A
00DA:  DATA 4F,00
00DB:  DATA D4,32
00DC:  DATA 6D,38
00DD:  DATA A0,1E
00DE:  DATA A0,12
00DF:  DATA 75,00
00E0:  DATA C8,3A
00E1:  DATA ED,34
00E2:  DATA 64,10
00E3:  DATA 3D,10
00E4:  DATA A5,3A
00E5:  DATA 00,01
00E6:  DATA 57,10
00E7:  DATA 3D,10
00E8:  DATA A5,3A
00E9:  DATA 00,01
00EA:  DATA 4C,10
00EB:  DATA 3D,10
00EC:  DATA 25,18
00ED:  DATA 35,36
00EE:  DATA 75,00
00EF:  DATA D3,3A
00F0:  DATA 00,01
00F1:  DATA CD,37
00F2:  DATA 00,01
00F3:  DATA D4,3A
00F4:  DATA 00,01
00F5:  DATA D7,32
00F6:  DATA 00,01
00F7:  DATA 54,34
00F8:  DATA 00,01
00F9:  DATA 46,39
00FA:  DATA 00,01
00FB:  DATA D3,30
00FC:  DATA 00,01
00FD:  DATA 20,10
00FE:  DATA 20,00
00FF:  DATA D3,3A
0100:  DATA 00,01
0101:  DATA CD,37
0102:  DATA 00,01
0103:  DATA D4,3A
0104:  DATA 00,01
0105:  DATA D7,32
0106:  DATA 00,01
0107:  DATA 54,34
0108:  DATA 00,01
0109:  DATA 46,39
010A:  DATA 00,01
010B:  DATA D3,30
010C:  DATA 00,01
*
0210:  MOVF   0B,W
0211:  BSF    03.6
0212:  MOVWF  6A
0213:  BCF    03.6
0214:  BCF    0B.7
0215:  BSF    03.5
0216:  BSF    03.6
0217:  BSF    0C.7
0218:  BSF    0C.0
0219:  NOP
021A:  NOP
021B:  BCF    03.5
021C:  BTFSS  6A.7
021D:  GOTO   221
021E:  BCF    03.6
021F:  BSF    0B.7
0220:  BSF    03.6
0221:  MOVF   0C,W
0222:  ANDLW  7F
0223:  BTFSC  03.2
0224:  GOTO   260
0225:  MOVWF  6A
0226:  MOVF   0D,W
0227:  MOVWF  6B
0228:  MOVF   0F,W
0229:  MOVWF  6C
022A:  MOVF   6A,W
022B:  BCF    03.6
022C:  BTFSS  0C.4
022D:  GOTO   22C
022E:  MOVWF  19
022F:  BSF    03.6
0230:  MOVF   6B,W
0231:  MOVWF  0D
0232:  MOVF   6C,W
0233:  MOVWF  0F
0234:  BCF    03.6
0235:  MOVF   0B,W
0236:  BSF    03.6
0237:  MOVWF  6D
0238:  BCF    03.6
0239:  BCF    0B.7
023A:  BSF    03.5
023B:  BSF    03.6
023C:  BSF    0C.7
023D:  BSF    0C.0
023E:  NOP
023F:  NOP
0240:  BCF    03.5
0241:  BTFSS  6D.7
0242:  GOTO   246
0243:  BCF    03.6
0244:  BSF    0B.7
0245:  BSF    03.6
0246:  RLF    0C,W
0247:  RLF    0E,W
0248:  ANDLW  7F
0249:  BTFSC  03.2
024A:  GOTO   260
024B:  MOVWF  6A
024C:  MOVF   0D,W
024D:  MOVWF  6B
024E:  MOVF   0F,W
024F:  MOVWF  6C
0250:  MOVF   6A,W
0251:  BCF    03.6
0252:  BTFSS  0C.4
0253:  GOTO   252
0254:  MOVWF  19
0255:  BSF    03.6
0256:  MOVF   6B,W
0257:  MOVWF  0D
0258:  MOVF   6C,W
0259:  MOVWF  0F
025A:  INCF   0D,F
025B:  BTFSC  03.2
025C:  INCF   0F,F
025D:  BCF    03.6
025E:  GOTO   210
025F:  BSF    03.6
0260:  BCF    03.6
0261:  RETURN
0262:  MOVF   0B,W
0263:  BSF    03.6
0264:  MOVWF  6B
0265:  BCF    03.6
0266:  BCF    0B.7
0267:  BSF    03.5
0268:  BSF    03.6
0269:  BSF    0C.7
026A:  BSF    0C.0
026B:  NOP
026C:  NOP
026D:  BCF    03.5
026E:  BTFSS  6B.7
026F:  GOTO   273
0270:  BCF    03.6
0271:  BSF    0B.7
0272:  BSF    03.6
0273:  BTFSC  03.0
0274:  GOTO   29B
0275:  MOVF   0C,W
0276:  ANDLW  7F
0277:  MOVWF  6B
0278:  MOVF   0D,W
0279:  MOVWF  6C
027A:  MOVF   0F,W
027B:  MOVWF  6D
027C:  MOVF   6B,W
027D:  BCF    03.6
027E:  BTFSS  0C.4
027F:  GOTO   27E
0280:  MOVWF  19
0281:  BSF    03.6
0282:  MOVF   6C,W
0283:  MOVWF  0D
0284:  MOVF   6D,W
0285:  MOVWF  0F
0286:  BCF    03.6
0287:  MOVF   0B,W
0288:  BSF    03.6
0289:  MOVWF  6E
028A:  BCF    03.6
028B:  BCF    0B.7
028C:  BSF    03.5
028D:  BSF    03.6
028E:  BSF    0C.7
028F:  BSF    0C.0
0290:  NOP
0291:  NOP
0292:  BCF    03.5
0293:  BTFSS  6E.7
0294:  GOTO   298
0295:  BCF    03.6
0296:  BSF    0B.7
0297:  BSF    03.6
0298:  DECFSZ 6A,F
0299:  GOTO   29B
029A:  GOTO   2B6
029B:  RLF    0C,W
029C:  RLF    0E,W
029D:  ANDLW  7F
029E:  MOVWF  6B
029F:  MOVF   0D,W
02A0:  MOVWF  6C
02A1:  MOVF   0F,W
02A2:  MOVWF  6D
02A3:  MOVF   6B,W
02A4:  BCF    03.6
02A5:  BTFSS  0C.4
02A6:  GOTO   2A5
02A7:  MOVWF  19
02A8:  BSF    03.6
02A9:  MOVF   6C,W
02AA:  MOVWF  0D
02AB:  MOVF   6D,W
02AC:  MOVWF  0F
02AD:  INCF   0D,F
02AE:  BTFSC  03.2
02AF:  INCF   0F,F
02B0:  BCF    03.0
02B1:  DECFSZ 6A,F
02B2:  GOTO   2B4
02B3:  GOTO   2B6
02B4:  BCF    03.6
02B5:  GOTO   262
02B6:  BCF    03.6
02B7:  RETURN
02B8:  MOVF   00,F
02B9:  BTFSC  03.2
02BA:  GOTO   2D5
02BB:  BSF    03.6
02BC:  CLRF   6B
02BD:  MOVF   04,W
02BE:  MOVWF  6A
02BF:  BCF    6B.0
02C0:  BTFSC  03.7
02C1:  BSF    6B.0
02C2:  MOVF   00,W
02C3:  BCF    03.6
02C4:  BTFSS  0C.4
02C5:  GOTO   2C4
02C6:  MOVWF  19
02C7:  BSF    03.6
02C8:  MOVF   6A,W
02C9:  MOVWF  04
02CA:  BCF    03.7
02CB:  BTFSC  6B.0
02CC:  BSF    03.7
02CD:  INCF   04,F
02CE:  BTFSS  03.2
02CF:  GOTO   2D3
02D0:  BCF    03.6
02D1:  INCF   05,F
02D2:  BSF    03.6
02D3:  BCF    03.6
02D4:  GOTO   2B8
02D5:  RETURN
*
0364:  MOVF   57,W
0365:  MOVWF  04
0366:  BCF    03.7
0367:  BTFSC  58.0
0368:  BSF    03.7
0369:  BSF    03.5
036A:  BSF    03.6
036B:  MOVF   17,W
036C:  MOVWF  00
036D:  INCF   04,F
036E:  CLRF   00
036F:  BCF    03.5
0370:  BCF    03.6
0371:  INCF   57,F
0372:  BTFSC  03.2
0373:  INCF   58,F
0374:  RETURN
0375:  MOVF   0B,W
0376:  BSF    03.6
0377:  MOVWF  6B
0378:  BCF    03.6
0379:  BCF    0B.7
037A:  BSF    03.5
037B:  BSF    03.6
037C:  BSF    0C.7
037D:  BSF    0C.0
037E:  NOP
037F:  NOP
0380:  BCF    03.5
0381:  BTFSS  6B.7
0382:  GOTO   386
0383:  BCF    03.6
0384:  BSF    0B.7
0385:  BSF    03.6
0386:  BTFSC  03.0
0387:  GOTO   3AF
0388:  MOVF   0C,W
0389:  ANDLW  7F
038A:  MOVWF  6B
038B:  MOVF   0D,W
038C:  MOVWF  6C
038D:  MOVF   0F,W
038E:  MOVWF  6D
038F:  MOVF   6B,W
0390:  BSF    03.5
0391:  MOVWF  17
0392:  BCF    03.5
0393:  BCF    03.6
0394:  CALL   364
0395:  BSF    03.6
0396:  MOVF   6C,W
0397:  MOVWF  0D
0398:  MOVF   6D,W
0399:  MOVWF  0F
039A:  BCF    03.6
039B:  MOVF   0B,W
039C:  BSF    03.6
039D:  MOVWF  6E
039E:  BCF    03.6
039F:  BCF    0B.7
03A0:  BSF    03.5
03A1:  BSF    03.6
03A2:  BSF    0C.7
03A3:  BSF    0C.0
03A4:  NOP
03A5:  NOP
03A6:  BCF    03.5
03A7:  BTFSS  6E.7
03A8:  GOTO   3AC
03A9:  BCF    03.6
03AA:  BSF    0B.7
03AB:  BSF    03.6
03AC:  DECFSZ 6A,F
03AD:  GOTO   3AF
03AE:  GOTO   3CB
03AF:  RLF    0C,W
03B0:  RLF    0E,W
03B1:  ANDLW  7F
03B2:  MOVWF  6B
03B3:  MOVF   0D,W
03B4:  MOVWF  6C
03B5:  MOVF   0F,W
03B6:  MOVWF  6D
03B7:  MOVF   6B,W
03B8:  BSF    03.5
03B9:  MOVWF  17
03BA:  BCF    03.5
03BB:  BCF    03.6
03BC:  CALL   364
03BD:  BSF    03.6
03BE:  MOVF   6C,W
03BF:  MOVWF  0D
03C0:  MOVF   6D,W
03C1:  MOVWF  0F
03C2:  INCF   0D,F
03C3:  BTFSC  03.2
03C4:  INCF   0F,F
03C5:  BCF    03.0
03C6:  DECFSZ 6A,F
03C7:  GOTO   3C9
03C8:  GOTO   3CB
03C9:  BCF    03.6
03CA:  GOTO   375
03CB:  BCF    03.6
03CC:  RETURN
03CD:  BSF    03.5
03CE:  BSF    03.6
03CF:  MOVF   11,W
03D0:  CLRF   78
03D1:  SUBWF  10,W
03D2:  BTFSC  03.0
03D3:  GOTO   3D7
03D4:  MOVF   10,W
03D5:  MOVWF  77
03D6:  GOTO   3E3
03D7:  CLRF   77
03D8:  MOVLW  08
03D9:  MOVWF  12
03DA:  RLF    10,F
03DB:  RLF    77,F
03DC:  MOVF   11,W
03DD:  SUBWF  77,W
03DE:  BTFSC  03.0
03DF:  MOVWF  77
03E0:  RLF    78,F
03E1:  DECFSZ 12,F
03E2:  GOTO   3DA
03E3:  BCF    03.5
03E4:  BCF    03.6
03E5:  RETURN
03E6:  MOVLW  20
03E7:  BSF    03.6
03E8:  BTFSS  6B.4
03E9:  MOVLW  30
03EA:  MOVWF  6C
03EB:  MOVF   6A,W
03EC:  MOVWF  77
03ED:  BTFSS  6A.7
03EE:  GOTO   3F7
03EF:  COMF   77,F
03F0:  INCF   77,F
03F1:  MOVF   77,W
03F2:  MOVWF  6A
03F3:  MOVLW  2D
03F4:  MOVWF  6C
03F5:  BSF    6B.7
03F6:  BSF    6B.0
03F7:  MOVF   6A,W
03F8:  BSF    03.5
03F9:  MOVWF  10
03FA:  MOVLW  64
03FB:  MOVWF  11
03FC:  BCF    03.5
03FD:  BCF    03.6
03FE:  CALL   3CD
03FF:  MOVF   77,W
0400:  BSF    03.6
0401:  MOVWF  6A
0402:  MOVLW  30
0403:  ADDWF  78,W
0404:  MOVWF  6D
0405:  MOVF   6A,W
0406:  BSF    03.5
0407:  MOVWF  10
0408:  MOVLW  0A
0409:  MOVWF  11
040A:  BCF    03.5
040B:  BCF    03.6
040C:  CALL   3CD
040D:  MOVLW  30
040E:  ADDWF  77,W
040F:  BSF    03.6
0410:  MOVWF  6F
0411:  MOVLW  30
0412:  ADDWF  78,W
0413:  MOVWF  6E
0414:  MOVF   6C,W
0415:  MOVWF  77
0416:  MOVLW  30
0417:  SUBWF  6D,W
0418:  BTFSC  03.2
0419:  GOTO   41E
041A:  BSF    6B.1
041B:  BTFSC  6B.7
041C:  BSF    6B.2
041D:  GOTO   432
041E:  MOVF   6C,W
041F:  MOVWF  6D
0420:  MOVLW  20
0421:  MOVWF  6C
0422:  MOVLW  30
0423:  SUBWF  6E,W
0424:  BTFSC  03.2
0425:  GOTO   42A
0426:  BSF    6B.0
0427:  BTFSC  6B.7
0428:  BSF    6B.1
0429:  GOTO   432
042A:  BTFSS  03.2
042B:  BSF    6B.0
042C:  BTFSS  03.2
042D:  GOTO   432
042E:  MOVF   6D,W
042F:  MOVWF  6E
0430:  MOVLW  20
0431:  MOVWF  6D
0432:  BTFSC  6B.2
0433:  GOTO   439
0434:  BTFSC  6B.1
0435:  GOTO   440
0436:  BTFSC  6B.0
0437:  GOTO   447
0438:  GOTO   44E
0439:  MOVF   6C,W
043A:  BSF    03.5
043B:  MOVWF  17
043C:  BCF    03.5
043D:  BCF    03.6
043E:  CALL   364
043F:  BSF    03.6
0440:  MOVF   6D,W
0441:  BSF    03.5
0442:  MOVWF  17
0443:  BCF    03.5
0444:  BCF    03.6
0445:  CALL   364
0446:  BSF    03.6
0447:  MOVF   6E,W
0448:  BSF    03.5
0449:  MOVWF  17
044A:  BCF    03.5
044B:  BCF    03.6
044C:  CALL   364
044D:  BSF    03.6
044E:  MOVF   6F,W
044F:  BSF    03.5
0450:  MOVWF  17
0451:  BCF    03.5
0452:  BCF    03.6
0453:  CALL   364
0454:  RETURN
*
049F:  BSF    03.5
04A0:  CLRF   16
04A1:  MOVF   04,W
04A2:  MOVWF  15
04A3:  BCF    16.0
04A4:  BTFSC  03.7
04A5:  BSF    16.0
04A6:  BCF    03.5
04A7:  SWAPF  6B,W
04A8:  IORLW  F0
04A9:  BSF    03.5
04AA:  MOVWF  11
04AB:  ADDWF  11,F
04AC:  ADDLW  E2
04AD:  MOVWF  12
04AE:  ADDLW  32
04AF:  MOVWF  14
04B0:  BCF    03.5
04B1:  MOVF   6B,W
04B2:  ANDLW  0F
04B3:  BSF    03.5
04B4:  ADDWF  12,F
04B5:  ADDWF  12,F
04B6:  ADDWF  14,F
04B7:  ADDLW  E9
04B8:  MOVWF  13
04B9:  ADDWF  13,F
04BA:  ADDWF  13,F
04BB:  BCF    03.5
04BC:  SWAPF  6A,W
04BD:  ANDLW  0F
04BE:  BSF    03.5
04BF:  ADDWF  13,F
04C0:  ADDWF  14,F
04C1:  RLF    13,F
04C2:  RLF    14,F
04C3:  COMF   14,F
04C4:  RLF    14,F
04C5:  BCF    03.5
04C6:  MOVF   6A,W
04C7:  ANDLW  0F
04C8:  BSF    03.5
04C9:  ADDWF  14,F
04CA:  RLF    11,F
04CB:  MOVLW  07
04CC:  MOVWF  10
04CD:  MOVLW  0A
04CE:  ADDWF  14,F
04CF:  DECF   13,F
04D0:  BTFSS  03.0
04D1:  GOTO   4CE
04D2:  ADDWF  13,F
04D3:  DECF   12,F
04D4:  BTFSS  03.0
04D5:  GOTO   4D2
04D6:  ADDWF  12,F
04D7:  DECF   11,F
04D8:  BTFSS  03.0
04D9:  GOTO   4D6
04DA:  ADDWF  11,F
04DB:  DECF   10,F
04DC:  BTFSS  03.0
04DD:  GOTO   4DA
04DE:  MOVLW  90
04DF:  MOVWF  04
04E0:  BSF    03.7
04E1:  MOVLW  07
04E2:  ANDWF  15,W
04E3:  BCF    15.6
04E4:  ADDWF  04,F
04E5:  MOVLW  94
04E6:  SUBWF  04,W
04E7:  BTFSC  03.2
04E8:  BSF    15.6
04E9:  MOVF   00,W
04EA:  MOVWF  77
04EB:  BTFSS  03.2
04EC:  GOTO   4F5
04ED:  BTFSC  15.6
04EE:  GOTO   4F5
04EF:  BTFSC  15.4
04F0:  GOTO   50D
04F1:  BTFSC  15.3
04F2:  GOTO   4F5
04F3:  MOVLW  20
04F4:  GOTO   4F8
04F5:  BSF    15.3
04F6:  BCF    15.4
04F7:  MOVLW  30
04F8:  ADDWF  77,F
04F9:  BCF    03.5
04FA:  CLRF   6B
04FB:  MOVF   04,W
04FC:  MOVWF  6A
04FD:  BCF    6B.0
04FE:  BTFSC  03.7
04FF:  BSF    6B.0
0500:  MOVF   77,W
0501:  BSF    03.5
0502:  MOVWF  17
0503:  BCF    03.5
0504:  BCF    03.6
0505:  CALL   364
0506:  BSF    03.6
0507:  MOVF   6A,W
0508:  MOVWF  04
0509:  BCF    03.7
050A:  BTFSC  6B.0
050B:  BSF    03.7
050C:  BSF    03.5
050D:  INCF   04,F
050E:  BTFSS  15.6
050F:  GOTO   4E5
*
0571:  MOVLW  20
0572:  BTFSS  6B.4
0573:  MOVLW  30
0574:  MOVWF  6C
0575:  MOVF   6A,W
0576:  MOVWF  77
0577:  BTFSS  6A.7
0578:  GOTO   581
0579:  COMF   77,F
057A:  INCF   77,F
057B:  MOVF   77,W
057C:  MOVWF  6A
057D:  MOVLW  2D
057E:  MOVWF  6C
057F:  BSF    6B.7
0580:  BSF    6B.0
0581:  MOVF   6A,W
0582:  BSF    03.5
0583:  MOVWF  10
0584:  MOVLW  64
0585:  MOVWF  11
0586:  BCF    03.5
0587:  BCF    03.6
0588:  CALL   3CD
0589:  MOVF   77,W
058A:  BSF    03.6
058B:  MOVWF  6A
058C:  MOVLW  30
058D:  ADDWF  78,W
058E:  MOVWF  6D
058F:  MOVF   6A,W
0590:  BSF    03.5
0591:  MOVWF  10
0592:  MOVLW  0A
0593:  MOVWF  11
0594:  BCF    03.5
0595:  BCF    03.6
0596:  CALL   3CD
0597:  MOVLW  30
0598:  ADDWF  77,W
0599:  BSF    03.6
059A:  MOVWF  6F
059B:  MOVLW  30
059C:  ADDWF  78,W
059D:  MOVWF  6E
059E:  MOVF   6C,W
059F:  MOVWF  77
05A0:  MOVLW  30
05A1:  SUBWF  6D,W
05A2:  BTFSC  03.2
05A3:  GOTO   5A8
05A4:  BSF    6B.1
05A5:  BTFSC  6B.7
05A6:  BSF    6B.2
05A7:  GOTO   5BC
05A8:  MOVF   6C,W
05A9:  MOVWF  6D
05AA:  MOVLW  20
05AB:  MOVWF  6C
05AC:  MOVLW  30
05AD:  SUBWF  6E,W
05AE:  BTFSC  03.2
05AF:  GOTO   5B4
05B0:  BSF    6B.0
05B1:  BTFSC  6B.7
05B2:  BSF    6B.1
05B3:  GOTO   5BC
05B4:  BTFSS  03.2
05B5:  BSF    6B.0
05B6:  BTFSS  03.2
05B7:  GOTO   5BC
05B8:  MOVF   6D,W
05B9:  MOVWF  6E
05BA:  MOVLW  20
05BB:  MOVWF  6D
05BC:  BTFSC  6B.2
05BD:  GOTO   5C3
05BE:  BTFSC  6B.1
05BF:  GOTO   5C9
05C0:  BTFSC  6B.0
05C1:  GOTO   5CF
05C2:  GOTO   5D5
05C3:  MOVF   6C,W
05C4:  BCF    03.6
05C5:  BTFSS  0C.4
05C6:  GOTO   5C5
05C7:  MOVWF  19
05C8:  BSF    03.6
05C9:  MOVF   6D,W
05CA:  BCF    03.6
05CB:  BTFSS  0C.4
05CC:  GOTO   5CB
05CD:  MOVWF  19
05CE:  BSF    03.6
05CF:  MOVF   6E,W
05D0:  BCF    03.6
05D1:  BTFSS  0C.4
05D2:  GOTO   5D1
05D3:  MOVWF  19
05D4:  BSF    03.6
05D5:  MOVF   6F,W
05D6:  BCF    03.6
05D7:  BTFSS  0C.4
05D8:  GOTO   5D7
05D9:  MOVWF  19
*
06B2:  MOVLW  8E
06B3:  MOVWF  77
06B4:  BSF    03.5
06B5:  MOVF   54,W
06B6:  MOVWF  78
06B7:  MOVF   53,W
06B8:  MOVWF  79
06B9:  CLRF   7A
06BA:  MOVF   78,F
06BB:  BTFSS  03.2
06BC:  GOTO   6C7
06BD:  MOVF   79,W
06BE:  MOVWF  78
06BF:  CLRF   79
06C0:  MOVLW  08
06C1:  SUBWF  77,F
06C2:  MOVF   78,F
06C3:  BTFSS  03.2
06C4:  GOTO   6C7
06C5:  CLRF   77
06C6:  GOTO   6CF
06C7:  BCF    03.0
06C8:  BTFSC  78.7
06C9:  GOTO   6CE
06CA:  RLF    79,F
06CB:  RLF    78,F
06CC:  DECF   77,F
06CD:  GOTO   6C7
06CE:  BCF    78.7
06CF:  BCF    03.5
06D0:  BSF    0A.3
06D1:  BSF    0A.4
06D2:  GOTO   17E (RETURN)
06D3:  BSF    03.5
06D4:  MOVF   53,W
06D5:  BTFSC  03.2
06D6:  GOTO   744
06D7:  MOVWF  5B
06D8:  MOVF   57,W
06D9:  BTFSC  03.2
06DA:  GOTO   744
06DB:  ADDWF  5B,F
06DC:  BTFSC  03.0
06DD:  GOTO   6E5
06DE:  MOVLW  7F
06DF:  SUBWF  5B,F
06E0:  BTFSS  03.0
06E1:  GOTO   744
06E2:  BTFSC  03.2
06E3:  GOTO   744
06E4:  GOTO   6E9
06E5:  MOVLW  81
06E6:  ADDWF  5B,F
06E7:  BTFSC  03.0
06E8:  GOTO   744
06E9:  MOVF   5B,W
06EA:  MOVWF  77
06EB:  CLRF   78
06EC:  CLRF   79
06ED:  CLRF   7A
06EE:  MOVF   54,W
06EF:  MOVWF  5F
06F0:  BSF    5F.7
06F1:  MOVF   55,W
06F2:  MOVWF  5E
06F3:  MOVF   56,W
06F4:  MOVWF  5D
06F5:  MOVLW  18
06F6:  MOVWF  5B
06F7:  CLRF   5C
06F8:  BTFSS  5D.0
06F9:  GOTO   712
06FA:  MOVF   5A,W
06FB:  ADDWF  7A,F
06FC:  BTFSS  03.0
06FD:  GOTO   704
06FE:  INCF   79,F
06FF:  BTFSS  03.2
0700:  GOTO   704
0701:  INCF   78,F
0702:  BTFSC  03.2
0703:  BSF    5C.7
0704:  MOVF   59,W
0705:  ADDWF  79,F
0706:  BTFSS  03.0
0707:  GOTO   70B
0708:  INCF   78,F
0709:  BTFSC  03.2
070A:  BSF    5C.7
070B:  MOVF   58,W
070C:  MOVWF  55
070D:  BSF    55.7
070E:  MOVF   55,W
070F:  ADDWF  78,F
0710:  BTFSC  03.0
0711:  BSF    5C.7
0712:  RLF    5C,F
0713:  RRF    78,F
0714:  RRF    79,F
0715:  RRF    7A,F
0716:  RRF    5F,F
0717:  RRF    5E,F
0718:  RRF    5D,F
0719:  BCF    03.0
071A:  DECFSZ 5B,F
071B:  GOTO   6F7
071C:  MOVLW  01
071D:  ADDWF  77,F
071E:  BTFSC  03.0
071F:  GOTO   744
0720:  BTFSC  78.7
0721:  GOTO   729
0722:  RLF    5F,F
0723:  RLF    7A,F
0724:  RLF    79,F
0725:  RLF    78,F
0726:  DECF   77,F
0727:  BTFSC  03.2
0728:  GOTO   744
0729:  BTFSS  5F.7
072A:  GOTO   73A
072B:  INCF   7A,F
072C:  BTFSS  03.2
072D:  GOTO   73A
072E:  INCF   79,F
072F:  BTFSS  03.2
0730:  GOTO   73A
0731:  INCF   78,F
0732:  BTFSS  03.2
0733:  GOTO   73A
0734:  RRF    78,F
0735:  RRF    79,F
0736:  RRF    7A,F
0737:  INCF   77,F
0738:  BTFSC  03.2
0739:  GOTO   744
073A:  MOVF   54,W
073B:  MOVWF  5C
073C:  MOVF   58,W
073D:  XORWF  5C,F
073E:  BTFSS  5C.7
073F:  GOTO   742
0740:  BSF    78.7
0741:  GOTO   748
0742:  BCF    78.7
0743:  GOTO   748
0744:  CLRF   77
0745:  CLRF   78
0746:  CLRF   79
0747:  CLRF   7A
0748:  BCF    03.5
0749:  BSF    0A.3
074A:  BSF    0A.4
074B:  GOTO   193 (RETURN)
074C:  MOVLW  8E
074D:  MOVWF  77
074E:  BSF    03.5
074F:  MOVF   53,W
0750:  SUBWF  77,F
0751:  MOVF   54,W
0752:  MOVWF  79
0753:  MOVF   55,W
0754:  MOVWF  78
0755:  BSF    79.7
0756:  MOVF   77,F
0757:  BTFSC  03.2
0758:  GOTO   764
0759:  BCF    03.0
075A:  MOVF   79,F
075B:  BTFSS  03.2
075C:  GOTO   760
075D:  MOVF   78,F
075E:  BTFSC  03.2
075F:  GOTO   764
0760:  RRF    79,F
0761:  RRF    78,F
0762:  DECFSZ 77,F
0763:  GOTO   759
0764:  BTFSS  54.7
0765:  GOTO   76B
0766:  COMF   78,F
0767:  COMF   79,F
0768:  INCF   78,F
0769:  BTFSC  03.2
076A:  INCF   79,F
076B:  BCF    03.5
076C:  BSF    0A.3
076D:  BSF    0A.4
076E:  GOTO   1D2 (RETURN)
*
0800:  BSF    03.5
0801:  MOVF   57,W
0802:  BTFSC  03.2
0803:  GOTO   0C7
0804:  MOVWF  63
0805:  MOVF   5B,W
0806:  BTFSC  03.2
0807:  GOTO   0C7
0808:  SUBWF  63,F
0809:  BTFSC  03.0
080A:  GOTO   00C
080B:  GOTO   011
080C:  MOVLW  7F
080D:  ADDWF  63,F
080E:  BTFSC  03.0
080F:  GOTO   0C7
0810:  GOTO   017
0811:  MOVLW  81
0812:  SUBWF  63,F
0813:  BTFSS  03.0
0814:  GOTO   0C7
0815:  BTFSC  03.2
0816:  GOTO   0C7
0817:  MOVF   63,W
0818:  MOVWF  77
0819:  CLRF   78
081A:  CLRF   79
081B:  CLRF   7A
081C:  CLRF   62
081D:  MOVF   58,W
081E:  MOVWF  61
081F:  BSF    61.7
0820:  MOVF   59,W
0821:  MOVWF  60
0822:  MOVF   5A,W
0823:  MOVWF  5F
0824:  MOVLW  19
0825:  MOVWF  63
0826:  MOVF   5E,W
0827:  SUBWF  5F,F
0828:  BTFSC  03.0
0829:  GOTO   03A
082A:  MOVLW  01
082B:  SUBWF  60,F
082C:  BTFSC  03.0
082D:  GOTO   03A
082E:  SUBWF  61,F
082F:  BTFSC  03.0
0830:  GOTO   03A
0831:  SUBWF  62,F
0832:  BTFSC  03.0
0833:  GOTO   03A
0834:  INCF   62,F
0835:  INCF   61,F
0836:  INCF   60,F
0837:  MOVF   5E,W
0838:  ADDWF  5F,F
0839:  GOTO   06C
083A:  MOVF   5D,W
083B:  SUBWF  60,F
083C:  BTFSC  03.0
083D:  GOTO   055
083E:  MOVLW  01
083F:  SUBWF  61,F
0840:  BTFSC  03.0
0841:  GOTO   055
0842:  SUBWF  62,F
0843:  BTFSC  03.0
0844:  GOTO   055
0845:  INCF   62,F
0846:  INCF   61,F
0847:  MOVF   5D,W
0848:  ADDWF  60,F
0849:  MOVF   5E,W
084A:  ADDWF  5F,F
084B:  BTFSS  03.0
084C:  GOTO   06C
084D:  INCF   60,F
084E:  BTFSS  03.2
084F:  GOTO   06C
0850:  INCF   61,F
0851:  BTFSS  03.2
0852:  GOTO   06C
0853:  INCF   62,F
0854:  GOTO   06C
0855:  MOVF   5C,W
0856:  IORLW  80
0857:  SUBWF  61,F
0858:  BTFSC  03.0
0859:  GOTO   06B
085A:  MOVLW  01
085B:  SUBWF  62,F
085C:  BTFSC  03.0
085D:  GOTO   06B
085E:  INCF   62,F
085F:  MOVF   5C,W
0860:  IORLW  80
0861:  ADDWF  61,F
0862:  MOVF   5D,W
0863:  ADDWF  60,F
0864:  BTFSS  03.0
0865:  GOTO   049
0866:  INCF   61,F
0867:  BTFSS  03.2
0868:  GOTO   049
0869:  INCF   62,F
086A:  GOTO   049
086B:  BSF    7A.0
086C:  DECFSZ 63,F
086D:  GOTO   06F
086E:  GOTO   07A
086F:  BCF    03.0
0870:  RLF    5F,F
0871:  RLF    60,F
0872:  RLF    61,F
0873:  RLF    62,F
0874:  BCF    03.0
0875:  RLF    7A,F
0876:  RLF    79,F
0877:  RLF    78,F
0878:  RLF    64,F
0879:  GOTO   026
087A:  BTFSS  64.0
087B:  GOTO   082
087C:  BCF    03.0
087D:  RRF    78,F
087E:  RRF    79,F
087F:  RRF    7A,F
0880:  RRF    64,F
0881:  GOTO   085
0882:  DECF   77,F
0883:  BTFSC  03.2
0884:  GOTO   0C7
0885:  BTFSC  64.7
0886:  GOTO   0AE
0887:  BCF    03.0
0888:  RLF    5F,F
0889:  RLF    60,F
088A:  RLF    61,F
088B:  RLF    62,F
088C:  MOVF   5E,W
088D:  SUBWF  5F,F
088E:  BTFSC  03.0
088F:  GOTO   09A
0890:  MOVLW  01
0891:  SUBWF  60,F
0892:  BTFSC  03.0
0893:  GOTO   09A
0894:  SUBWF  61,F
0895:  BTFSC  03.0
0896:  GOTO   09A
0897:  SUBWF  62,F
0898:  BTFSS  03.0
0899:  GOTO   0BD
089A:  MOVF   5D,W
089B:  SUBWF  60,F
089C:  BTFSC  03.0
089D:  GOTO   0A5
089E:  MOVLW  01
089F:  SUBWF  61,F
08A0:  BTFSC  03.0
08A1:  GOTO   0A5
08A2:  SUBWF  62,F
08A3:  BTFSS  03.0
08A4:  GOTO   0BD
08A5:  MOVF   5C,W
08A6:  IORLW  80
08A7:  SUBWF  61,F
08A8:  BTFSC  03.0
08A9:  GOTO   0AE
08AA:  MOVLW  01
08AB:  SUBWF  62,F
08AC:  BTFSS  03.0
08AD:  GOTO   0BD
08AE:  INCF   7A,F
08AF:  BTFSS  03.2
08B0:  GOTO   0BD
08B1:  INCF   79,F
08B2:  BTFSS  03.2
08B3:  GOTO   0BD
08B4:  INCF   78,F
08B5:  BTFSS  03.2
08B6:  GOTO   0BD
08B7:  INCF   77,F
08B8:  BTFSC  03.2
08B9:  GOTO   0C7
08BA:  RRF    78,F
08BB:  RRF    79,F
08BC:  RRF    7A,F
08BD:  MOVF   58,W
08BE:  MOVWF  63
08BF:  MOVF   5C,W
08C0:  XORWF  63,F
08C1:  BTFSS  63.7
08C2:  GOTO   0C5
08C3:  BSF    78.7
08C4:  GOTO   0CB
08C5:  BCF    78.7
08C6:  GOTO   0CB
08C7:  CLRF   77
08C8:  CLRF   78
08C9:  CLRF   79
08CA:  CLRF   7A
08CB:  BCF    03.5
08CC:  BSF    0A.3
08CD:  BSF    0A.4
08CE:  GOTO   1B0 (RETURN)
08CF:  MOVLW  80
08D0:  BTFSS  03.1
08D1:  GOTO   0D5
08D2:  BSF    03.5
08D3:  XORWF  58,F
08D4:  BCF    03.5
08D5:  BSF    03.5
08D6:  CLRF   5D
08D7:  CLRF   5E
08D8:  MOVF   54,W
08D9:  MOVWF  5C
08DA:  MOVF   58,W
08DB:  XORWF  5C,F
08DC:  MOVF   53,W
08DD:  BTFSC  03.2
08DE:  GOTO   1C3
08DF:  MOVWF  5B
08E0:  MOVWF  77
08E1:  MOVF   57,W
08E2:  BTFSC  03.2
08E3:  GOTO   1CC
08E4:  SUBWF  5B,F
08E5:  BTFSC  03.2
08E6:  GOTO   168
08E7:  BTFSS  03.0
08E8:  GOTO   126
08E9:  MOVF   58,W
08EA:  MOVWF  61
08EB:  BSF    61.7
08EC:  MOVF   59,W
08ED:  MOVWF  60
08EE:  MOVF   5A,W
08EF:  MOVWF  5F
08F0:  CLRF   5E
08F1:  BCF    03.0
08F2:  RRF    61,F
08F3:  RRF    60,F
08F4:  RRF    5F,F
08F5:  RRF    5E,F
08F6:  DECFSZ 5B,F
08F7:  GOTO   0F0
08F8:  BTFSS  5C.7
08F9:  GOTO   0FD
08FA:  BSF    5D.0
08FB:  GOTO   1E0
08FC:  BCF    5D.0
08FD:  BCF    5B.0
08FE:  BSF    5D.4
08FF:  MOVLW  D6
0900:  MOVWF  04
0901:  BCF    03.7
0902:  GOTO   1F5
0903:  BCF    5D.4
0904:  BTFSC  5C.7
0905:  GOTO   110
0906:  BTFSS  5B.0
0907:  GOTO   11B
0908:  RRF    61,F
0909:  RRF    60,F
090A:  RRF    5F,F
090B:  RRF    5E,F
090C:  INCF   77,F
090D:  BTFSC  03.2
090E:  GOTO   1DB
090F:  GOTO   11B
0910:  BTFSC  61.7
0911:  GOTO   11E
0912:  BCF    03.0
0913:  RLF    5E,F
0914:  RLF    5F,F
0915:  RLF    60,F
0916:  RLF    61,F
0917:  DECF   77,F
0918:  BTFSC  03.2
0919:  GOTO   1DB
091A:  GOTO   110
091B:  BSF    5D.6
091C:  GOTO   188
091D:  BCF    5D.6
091E:  MOVF   54,W
091F:  MOVWF  5C
0920:  BTFSS  5C.7
0921:  GOTO   124
0922:  BSF    61.7
0923:  GOTO   1D4
0924:  BCF    61.7
0925:  GOTO   1D4
0926:  MOVF   57,W
0927:  MOVWF  5B
0928:  MOVWF  77
0929:  MOVF   53,W
092A:  SUBWF  5B,F
092B:  MOVF   54,W
092C:  MOVWF  61
092D:  BSF    61.7
092E:  MOVF   55,W
092F:  MOVWF  60
0930:  MOVF   56,W
0931:  MOVWF  5F
0932:  CLRF   5E
0933:  BCF    03.0
0934:  RRF    61,F
0935:  RRF    60,F
0936:  RRF    5F,F
0937:  RRF    5E,F
0938:  DECFSZ 5B,F
0939:  GOTO   132
093A:  BTFSS  5C.7
093B:  GOTO   13F
093C:  BSF    5D.1
093D:  GOTO   1E0
093E:  BCF    5D.1
093F:  BCF    5B.0
0940:  BSF    5D.5
0941:  MOVLW  DA
0942:  MOVWF  04
0943:  BCF    03.7
0944:  GOTO   1F5
0945:  BCF    5D.5
0946:  BTFSC  5C.7
0947:  GOTO   152
0948:  BTFSS  5B.0
0949:  GOTO   15D
094A:  RRF    61,F
094B:  RRF    60,F
094C:  RRF    5F,F
094D:  RRF    5E,F
094E:  INCF   77,F
094F:  BTFSC  03.2
0950:  GOTO   1DB
0951:  GOTO   15D
0952:  BTFSC  61.7
0953:  GOTO   160
0954:  BCF    03.0
0955:  RLF    5E,F
0956:  RLF    5F,F
0957:  RLF    60,F
0958:  RLF    61,F
0959:  DECF   77,F
095A:  BTFSC  03.2
095B:  GOTO   1DB
095C:  GOTO   152
095D:  BSF    5D.7
095E:  GOTO   188
095F:  BCF    5D.7
0960:  MOVF   58,W
0961:  MOVWF  5C
0962:  BTFSS  5C.7
0963:  GOTO   166
0964:  BSF    61.7
0965:  GOTO   1D4
0966:  BCF    61.7
0967:  GOTO   1D4
0968:  MOVF   58,W
0969:  MOVWF  61
096A:  BSF    61.7
096B:  MOVF   59,W
096C:  MOVWF  60
096D:  MOVF   5A,W
096E:  MOVWF  5F
096F:  BTFSS  5C.7
0970:  GOTO   175
0971:  BCF    61.7
0972:  BSF    5D.2
0973:  GOTO   1E0
0974:  BCF    5D.2
0975:  CLRF   5E
0976:  BCF    5B.0
0977:  MOVLW  D6
0978:  MOVWF  04
0979:  BCF    03.7
097A:  GOTO   1F5
097B:  BTFSC  5C.7
097C:  GOTO   19E
097D:  MOVF   54,W
097E:  MOVWF  5C
097F:  BTFSS  5B.0
0980:  GOTO   188
0981:  RRF    61,F
0982:  RRF    60,F
0983:  RRF    5F,F
0984:  RRF    5E,F
0985:  INCF   77,F
0986:  BTFSC  03.2
0987:  GOTO   1DB
0988:  BTFSS  5E.7
0989:  GOTO   199
098A:  INCF   5F,F
098B:  BTFSS  03.2
098C:  GOTO   199
098D:  INCF   60,F
098E:  BTFSS  03.2
098F:  GOTO   199
0990:  INCF   61,F
0991:  BTFSS  03.2
0992:  GOTO   199
0993:  RRF    61,F
0994:  RRF    60,F
0995:  RRF    5F,F
0996:  INCF   77,F
0997:  BTFSC  03.2
0998:  GOTO   1DB
0999:  BTFSC  5D.6
099A:  GOTO   11D
099B:  BTFSC  5D.7
099C:  GOTO   15F
099D:  GOTO   1BD
099E:  MOVLW  80
099F:  XORWF  61,F
09A0:  BTFSS  61.7
09A1:  GOTO   1A6
09A2:  GOTO   1E0
09A3:  MOVF   58,W
09A4:  MOVWF  5C
09A5:  GOTO   1B3
09A6:  MOVF   54,W
09A7:  MOVWF  5C
09A8:  MOVF   61,F
09A9:  BTFSS  03.2
09AA:  GOTO   1B3
09AB:  MOVF   60,F
09AC:  BTFSS  03.2
09AD:  GOTO   1B3
09AE:  MOVF   5F,F
09AF:  BTFSS  03.2
09B0:  GOTO   1B3
09B1:  CLRF   77
09B2:  GOTO   1D4
09B3:  BTFSC  61.7
09B4:  GOTO   1BD
09B5:  BCF    03.0
09B6:  RLF    5E,F
09B7:  RLF    5F,F
09B8:  RLF    60,F
09B9:  RLF    61,F
09BA:  DECFSZ 77,F
09BB:  GOTO   1B3
09BC:  GOTO   1DB
09BD:  BTFSS  5C.7
09BE:  GOTO   1C1
09BF:  BSF    61.7
09C0:  GOTO   1D4
09C1:  BCF    61.7
09C2:  GOTO   1D4
09C3:  MOVF   57,W
09C4:  MOVWF  77
09C5:  MOVF   58,W
09C6:  MOVWF  61
09C7:  MOVF   59,W
09C8:  MOVWF  60
09C9:  MOVF   5A,W
09CA:  MOVWF  5F
09CB:  GOTO   1D4
09CC:  MOVF   53,W
09CD:  MOVWF  77
09CE:  MOVF   54,W
09CF:  MOVWF  61
09D0:  MOVF   55,W
09D1:  MOVWF  60
09D2:  MOVF   56,W
09D3:  MOVWF  5F
09D4:  MOVF   61,W
09D5:  MOVWF  78
09D6:  MOVF   60,W
09D7:  MOVWF  79
09D8:  MOVF   5F,W
09D9:  MOVWF  7A
09DA:  GOTO   213
09DB:  CLRF   77
09DC:  CLRF   78
09DD:  CLRF   79
09DE:  CLRF   7A
09DF:  GOTO   213
09E0:  CLRF   5E
09E1:  COMF   5F,F
09E2:  COMF   60,F
09E3:  COMF   61,F
09E4:  COMF   5E,F
09E5:  INCF   5E,F
09E6:  BTFSS  03.2
09E7:  GOTO   1EE
09E8:  INCF   5F,F
09E9:  BTFSS  03.2
09EA:  GOTO   1EE
09EB:  INCF   60,F
09EC:  BTFSC  03.2
09ED:  INCF   61,F
09EE:  BTFSC  5D.0
09EF:  GOTO   0FC
09F0:  BTFSC  5D.1
09F1:  GOTO   13E
09F2:  BTFSC  5D.2
09F3:  GOTO   174
09F4:  GOTO   1A3
09F5:  MOVF   00,W
09F6:  ADDWF  5F,F
09F7:  BTFSS  03.0
09F8:  GOTO   1FF
09F9:  INCF   60,F
09FA:  BTFSS  03.2
09FB:  GOTO   1FF
09FC:  INCF   61,F
09FD:  BTFSC  03.2
09FE:  BSF    5B.0
09FF:  DECF   04,F
0A00:  MOVF   00,W
0A01:  ADDWF  60,F
0A02:  BTFSS  03.0
0A03:  GOTO   207
0A04:  INCF   61,F
0A05:  BTFSC  03.2
0A06:  BSF    5B.0
0A07:  DECF   04,F
0A08:  MOVF   00,W
0A09:  BTFSS  00.7
0A0A:  XORLW  80
0A0B:  ADDWF  61,F
0A0C:  BTFSC  03.0
0A0D:  BSF    5B.0
0A0E:  BTFSC  5D.4
0A0F:  GOTO   103
0A10:  BTFSC  5D.5
0A11:  GOTO   145
0A12:  GOTO   17B
0A13:  BCF    03.5
0A14:  BSF    0A.3
0A15:  BSF    0A.4
0A16:  GOTO   1C4 (RETURN)
*
0A81:  MOVF   0B,W
0A82:  BSF    03.5
0A83:  MOVWF  56
0A84:  BCF    03.5
0A85:  BCF    0B.7
0A86:  BSF    03.5
0A87:  BSF    03.6
0A88:  BSF    0C.7
0A89:  BSF    0C.0
0A8A:  NOP
0A8B:  NOP
0A8C:  BCF    03.6
0A8D:  BTFSS  56.7
0A8E:  GOTO   292
0A8F:  BCF    03.5
0A90:  BSF    0B.7
0A91:  BSF    03.5
0A92:  BCF    03.5
0A93:  BSF    03.6
0A94:  MOVF   0C,W
0A95:  ANDLW  7F
0A96:  BTFSC  03.2
0A97:  GOTO   2F7
0A98:  BSF    03.5
0A99:  BCF    03.6
0A9A:  MOVWF  56
0A9B:  BCF    03.5
0A9C:  BSF    03.6
0A9D:  MOVF   0D,W
0A9E:  BSF    03.5
0A9F:  BCF    03.6
0AA0:  MOVWF  57
0AA1:  BCF    03.5
0AA2:  BSF    03.6
0AA3:  MOVF   0F,W
0AA4:  BSF    03.5
0AA5:  BCF    03.6
0AA6:  MOVWF  58
0AA7:  MOVF   56,W
0AA8:  MOVWF  5D
0AA9:  BCF    0A.3
0AAA:  BCF    03.5
0AAB:  CALL   7E6
0AAC:  BSF    0A.3
0AAD:  BSF    03.5
0AAE:  MOVF   57,W
0AAF:  BCF    03.5
0AB0:  BSF    03.6
0AB1:  MOVWF  0D
0AB2:  BSF    03.5
0AB3:  BCF    03.6
0AB4:  MOVF   58,W
0AB5:  BCF    03.5
0AB6:  BSF    03.6
0AB7:  MOVWF  0F
0AB8:  BCF    03.6
0AB9:  MOVF   0B,W
0ABA:  BSF    03.5
0ABB:  MOVWF  59
0ABC:  BCF    03.5
0ABD:  BCF    0B.7
0ABE:  BSF    03.5
0ABF:  BSF    03.6
0AC0:  BSF    0C.7
0AC1:  BSF    0C.0
0AC2:  NOP
0AC3:  NOP
0AC4:  BCF    03.6
0AC5:  BTFSS  59.7
0AC6:  GOTO   2CA
0AC7:  BCF    03.5
0AC8:  BSF    0B.7
0AC9:  BSF    03.5
0ACA:  BCF    03.5
0ACB:  BSF    03.6
0ACC:  RLF    0C,W
0ACD:  RLF    0E,W
0ACE:  ANDLW  7F
0ACF:  BTFSC  03.2
0AD0:  GOTO   2F7
0AD1:  BSF    03.5
0AD2:  BCF    03.6
0AD3:  MOVWF  56
0AD4:  BCF    03.5
0AD5:  BSF    03.6
0AD6:  MOVF   0D,W
0AD7:  BSF    03.5
0AD8:  BCF    03.6
0AD9:  MOVWF  57
0ADA:  BCF    03.5
0ADB:  BSF    03.6
0ADC:  MOVF   0F,W
0ADD:  BSF    03.5
0ADE:  BCF    03.6
0ADF:  MOVWF  58
0AE0:  MOVF   56,W
0AE1:  MOVWF  5D
0AE2:  BCF    0A.3
0AE3:  BCF    03.5
0AE4:  CALL   7E6
0AE5:  BSF    0A.3
0AE6:  BSF    03.5
0AE7:  MOVF   57,W
0AE8:  BCF    03.5
0AE9:  BSF    03.6
0AEA:  MOVWF  0D
0AEB:  BSF    03.5
0AEC:  BCF    03.6
0AED:  MOVF   58,W
0AEE:  BCF    03.5
0AEF:  BSF    03.6
0AF0:  MOVWF  0F
0AF1:  INCF   0D,F
0AF2:  BTFSC  03.2
0AF3:  INCF   0F,F
0AF4:  BCF    03.6
0AF5:  GOTO   281
0AF6:  BSF    03.6
0AF7:  BCF    03.6
0AF8:  RETURN
0AF9:  MOVF   0B,W
0AFA:  BSF    03.5
0AFB:  MOVWF  54
0AFC:  BCF    03.5
0AFD:  BCF    0B.7
0AFE:  BSF    03.5
0AFF:  BSF    03.6
0B00:  BSF    0C.7
0B01:  BSF    0C.0
0B02:  NOP
0B03:  NOP
0B04:  BCF    03.6
0B05:  BTFSS  54.7
0B06:  GOTO   30A
0B07:  BCF    03.5
0B08:  BSF    0B.7
0B09:  BSF    03.5
0B0A:  BTFSC  03.0
0B0B:  GOTO   345
0B0C:  BCF    03.5
0B0D:  BSF    03.6
0B0E:  MOVF   0C,W
0B0F:  ANDLW  7F
0B10:  BSF    03.5
0B11:  BCF    03.6
0B12:  MOVWF  54
0B13:  BCF    03.5
0B14:  BSF    03.6
0B15:  MOVF   0D,W
0B16:  BSF    03.5
0B17:  BCF    03.6
0B18:  MOVWF  55
0B19:  BCF    03.5
0B1A:  BSF    03.6
0B1B:  MOVF   0F,W
0B1C:  BSF    03.5
0B1D:  BCF    03.6
0B1E:  MOVWF  56
0B1F:  MOVF   54,W
0B20:  MOVWF  5D
0B21:  BCF    0A.3
0B22:  BCF    03.5
0B23:  CALL   7E6
0B24:  BSF    0A.3
0B25:  BSF    03.5
0B26:  MOVF   55,W
0B27:  BCF    03.5
0B28:  BSF    03.6
0B29:  MOVWF  0D
0B2A:  BSF    03.5
0B2B:  BCF    03.6
0B2C:  MOVF   56,W
0B2D:  BCF    03.5
0B2E:  BSF    03.6
0B2F:  MOVWF  0F
0B30:  BCF    03.6
0B31:  MOVF   0B,W
0B32:  BSF    03.5
0B33:  MOVWF  57
0B34:  BCF    03.5
0B35:  BCF    0B.7
0B36:  BSF    03.5
0B37:  BSF    03.6
0B38:  BSF    0C.7
0B39:  BSF    0C.0
0B3A:  NOP
0B3B:  NOP
0B3C:  BCF    03.6
0B3D:  BTFSS  57.7
0B3E:  GOTO   342
0B3F:  BCF    03.5
0B40:  BSF    0B.7
0B41:  BSF    03.5
0B42:  DECFSZ 53,F
0B43:  GOTO   345
0B44:  GOTO   375
0B45:  BCF    03.5
0B46:  BSF    03.6
0B47:  RLF    0C,W
0B48:  RLF    0E,W
0B49:  ANDLW  7F
0B4A:  BSF    03.5
0B4B:  BCF    03.6
0B4C:  MOVWF  54
0B4D:  BCF    03.5
0B4E:  BSF    03.6
0B4F:  MOVF   0D,W
0B50:  BSF    03.5
0B51:  BCF    03.6
0B52:  MOVWF  55
0B53:  BCF    03.5
0B54:  BSF    03.6
0B55:  MOVF   0F,W
0B56:  BSF    03.5
0B57:  BCF    03.6
0B58:  MOVWF  56
0B59:  MOVF   54,W
0B5A:  MOVWF  5D
0B5B:  BCF    0A.3
0B5C:  BCF    03.5
0B5D:  CALL   7E6
0B5E:  BSF    0A.3
0B5F:  BSF    03.5
0B60:  MOVF   55,W
0B61:  BCF    03.5
0B62:  BSF    03.6
0B63:  MOVWF  0D
0B64:  BSF    03.5
0B65:  BCF    03.6
0B66:  MOVF   56,W
0B67:  BCF    03.5
0B68:  BSF    03.6
0B69:  MOVWF  0F
0B6A:  INCF   0D,F
0B6B:  BTFSC  03.2
0B6C:  INCF   0F,F
0B6D:  BCF    03.0
0B6E:  BSF    03.5
0B6F:  BCF    03.6
0B70:  DECFSZ 53,F
0B71:  GOTO   373
0B72:  GOTO   375
0B73:  BCF    03.5
0B74:  GOTO   2F9
0B75:  BCF    03.5
0B76:  RETURN
0B77:  MOVF   78,W
0B78:  BSF    03.5
0B79:  MOVF   56,W
0B7A:  BSF    03.6
0B7B:  MOVWF  10
0B7C:  MOVLW  64
0B7D:  MOVWF  11
0B7E:  BCF    0A.3
0B7F:  BCF    03.5
0B80:  BCF    03.6
0B81:  CALL   3CD
0B82:  BSF    0A.3
0B83:  MOVF   77,W
0B84:  BSF    03.5
0B85:  MOVWF  56
0B86:  MOVF   78,W
0B87:  MOVLW  30
0B88:  BTFSS  03.2
0B89:  GOTO   391
0B8A:  BTFSS  57.1
0B8B:  GOTO   39C
0B8C:  BTFSC  57.3
0B8D:  GOTO   39C
0B8E:  BTFSC  57.4
0B8F:  MOVLW  20
0B90:  GOTO   394
0B91:  BCF    57.3
0B92:  BCF    57.4
0B93:  BSF    57.0
0B94:  ADDWF  78,F
0B95:  MOVF   78,W
0B96:  MOVWF  5D
0B97:  BCF    0A.3
0B98:  BCF    03.5
0B99:  CALL   7E6
0B9A:  BSF    0A.3
0B9B:  BSF    03.5
0B9C:  MOVF   56,W
0B9D:  BSF    03.6
0B9E:  MOVWF  10
0B9F:  MOVLW  0A
0BA0:  MOVWF  11
0BA1:  BCF    0A.3
0BA2:  BCF    03.5
0BA3:  BCF    03.6
0BA4:  CALL   3CD
0BA5:  BSF    0A.3
0BA6:  MOVF   77,W
0BA7:  BSF    03.5
0BA8:  MOVWF  56
0BA9:  MOVF   78,W
0BAA:  MOVLW  30
0BAB:  BTFSS  03.2
0BAC:  GOTO   3B3
0BAD:  BTFSC  57.3
0BAE:  GOTO   3BB
0BAF:  BTFSS  57.0
0BB0:  GOTO   3BB
0BB1:  BTFSC  57.4
0BB2:  MOVLW  20
0BB3:  ADDWF  78,F
0BB4:  MOVF   78,W
0BB5:  MOVWF  5D
0BB6:  BCF    0A.3
0BB7:  BCF    03.5
0BB8:  CALL   7E6
0BB9:  BSF    0A.3
0BBA:  BSF    03.5
0BBB:  MOVLW  30
0BBC:  ADDWF  56,F
0BBD:  MOVF   56,W
0BBE:  MOVWF  5D
0BBF:  BCF    0A.3
0BC0:  BCF    03.5
0BC1:  CALL   7E6
0BC2:  BSF    0A.3
0BC3:  RETURN
0BC4:  MOVLW  20
0BC5:  BSF    03.5
0BC6:  BTFSS  58.4
0BC7:  MOVLW  30
0BC8:  MOVWF  59
0BC9:  MOVF   57,W
0BCA:  MOVWF  77
0BCB:  BTFSS  57.7
0BCC:  GOTO   3D5
0BCD:  COMF   77,F
0BCE:  INCF   77,F
0BCF:  MOVF   77,W
0BD0:  MOVWF  57
0BD1:  MOVLW  2D
0BD2:  MOVWF  59
0BD3:  BSF    58.7
0BD4:  BSF    58.0
0BD5:  MOVF   57,W
0BD6:  BSF    03.6
0BD7:  MOVWF  10
0BD8:  MOVLW  64
0BD9:  MOVWF  11
0BDA:  BCF    0A.3
0BDB:  BCF    03.5
0BDC:  BCF    03.6
0BDD:  CALL   3CD
0BDE:  BSF    0A.3
0BDF:  MOVF   77,W
0BE0:  BSF    03.5
0BE1:  MOVWF  57
0BE2:  MOVLW  30
0BE3:  ADDWF  78,W
0BE4:  MOVWF  5A
0BE5:  MOVF   57,W
0BE6:  BSF    03.6
0BE7:  MOVWF  10
0BE8:  MOVLW  0A
0BE9:  MOVWF  11
0BEA:  BCF    0A.3
0BEB:  BCF    03.5
0BEC:  BCF    03.6
0BED:  CALL   3CD
0BEE:  BSF    0A.3
0BEF:  MOVLW  30
0BF0:  ADDWF  77,W
0BF1:  BSF    03.5
0BF2:  MOVWF  5C
0BF3:  MOVLW  30
0BF4:  ADDWF  78,W
0BF5:  MOVWF  5B
0BF6:  MOVF   59,W
0BF7:  MOVWF  77
0BF8:  MOVLW  30
0BF9:  SUBWF  5A,W
0BFA:  BTFSC  03.2
0BFB:  GOTO   400
0BFC:  BSF    58.1
0BFD:  BTFSC  58.7
0BFE:  BSF    58.2
0BFF:  GOTO   414
0C00:  MOVF   59,W
0C01:  MOVWF  5A
0C02:  MOVLW  20
0C03:  MOVWF  59
0C04:  MOVLW  30
0C05:  SUBWF  5B,W
0C06:  BTFSC  03.2
0C07:  GOTO   40C
0C08:  BSF    58.0
0C09:  BTFSC  58.7
0C0A:  BSF    58.1
0C0B:  GOTO   414
0C0C:  BTFSS  03.2
0C0D:  BSF    58.0
0C0E:  BTFSS  03.2
0C0F:  GOTO   414
0C10:  MOVF   5A,W
0C11:  MOVWF  5B
0C12:  MOVLW  20
0C13:  MOVWF  5A
0C14:  BTFSC  58.2
0C15:  GOTO   41B
0C16:  BTFSC  58.1
0C17:  GOTO   422
0C18:  BTFSC  58.0
0C19:  GOTO   429
0C1A:  GOTO   430
0C1B:  MOVF   59,W
0C1C:  MOVWF  5D
0C1D:  BCF    0A.3
0C1E:  BCF    03.5
0C1F:  CALL   7E6
0C20:  BSF    0A.3
0C21:  BSF    03.5
0C22:  MOVF   5A,W
0C23:  MOVWF  5D
0C24:  BCF    0A.3
0C25:  BCF    03.5
0C26:  CALL   7E6
0C27:  BSF    0A.3
0C28:  BSF    03.5
0C29:  MOVF   5B,W
0C2A:  MOVWF  5D
0C2B:  BCF    0A.3
0C2C:  BCF    03.5
0C2D:  CALL   7E6
0C2E:  BSF    0A.3
0C2F:  BSF    03.5
0C30:  MOVF   5C,W
0C31:  MOVWF  5D
0C32:  BCF    0A.3
0C33:  BCF    03.5
0C34:  CALL   7E6
0C35:  BSF    0A.3
0C36:  RETURN
*
0CDC:  CLRF   5B
0CDD:  MOVF   04,W
0CDE:  MOVWF  5A
0CDF:  BCF    5B.0
0CE0:  BTFSC  03.7
0CE1:  BSF    5B.0
0CE2:  SWAPF  54,W
0CE3:  IORLW  F0
0CE4:  MOVWF  56
0CE5:  ADDWF  56,F
0CE6:  ADDLW  E2
0CE7:  MOVWF  57
0CE8:  ADDLW  32
0CE9:  MOVWF  59
0CEA:  MOVF   54,W
0CEB:  ANDLW  0F
0CEC:  ADDWF  57,F
0CED:  ADDWF  57,F
0CEE:  ADDWF  59,F
0CEF:  ADDLW  E9
0CF0:  MOVWF  58
0CF1:  ADDWF  58,F
0CF2:  ADDWF  58,F
0CF3:  SWAPF  53,W
0CF4:  ANDLW  0F
0CF5:  ADDWF  58,F
0CF6:  ADDWF  59,F
0CF7:  RLF    58,F
0CF8:  RLF    59,F
0CF9:  COMF   59,F
0CFA:  RLF    59,F
0CFB:  MOVF   53,W
0CFC:  ANDLW  0F
0CFD:  ADDWF  59,F
0CFE:  RLF    56,F
0CFF:  MOVLW  07
0D00:  MOVWF  55
0D01:  MOVLW  0A
0D02:  ADDWF  59,F
0D03:  DECF   58,F
0D04:  BTFSS  03.0
0D05:  GOTO   502
0D06:  ADDWF  58,F
0D07:  DECF   57,F
0D08:  BTFSS  03.0
0D09:  GOTO   506
0D0A:  ADDWF  57,F
0D0B:  DECF   56,F
0D0C:  BTFSS  03.0
0D0D:  GOTO   50A
0D0E:  ADDWF  56,F
0D0F:  DECF   55,F
0D10:  BTFSS  03.0
0D11:  GOTO   50E
0D12:  MOVLW  D5
0D13:  MOVWF  04
0D14:  BCF    03.7
0D15:  MOVLW  07
0D16:  ANDWF  5A,W
0D17:  BCF    5A.6
0D18:  ADDWF  04,F
0D19:  MOVLW  D9
0D1A:  SUBWF  04,W
0D1B:  BTFSC  03.2
0D1C:  BSF    5A.6
0D1D:  MOVF   00,W
0D1E:  MOVWF  77
0D1F:  BTFSS  03.2
0D20:  GOTO   529
0D21:  BTFSC  5A.6
0D22:  GOTO   529
0D23:  BTFSC  5A.4
0D24:  GOTO   53F
0D25:  BTFSC  5A.3
0D26:  GOTO   529
0D27:  MOVLW  20
0D28:  GOTO   52C
0D29:  BSF    5A.3
0D2A:  BCF    5A.4
0D2B:  MOVLW  30
0D2C:  ADDWF  77,F
0D2D:  CLRF   54
0D2E:  MOVF   04,W
0D2F:  MOVWF  53
0D30:  BCF    54.0
0D31:  BTFSC  03.7
0D32:  BSF    54.0
0D33:  MOVF   77,W
0D34:  MOVWF  5D
0D35:  BCF    0A.3
0D36:  BCF    03.5
0D37:  CALL   7E6
0D38:  BSF    0A.3
0D39:  BSF    03.5
0D3A:  MOVF   53,W
0D3B:  MOVWF  04
0D3C:  BCF    03.7
0D3D:  BTFSC  54.0
0D3E:  BSF    03.7
0D3F:  INCF   04,F
0D40:  BTFSS  5A.6
0D41:  GOTO   519
*
1253:  CLRF   77
1254:  CLRF   78
1255:  BSF    03.5
1256:  MOVF   58,W
1257:  BCF    03.0
1258:  BTFSC  59.0
1259:  ADDWF  77,F
125A:  RRF    77,F
125B:  RRF    78,F
125C:  BTFSC  59.1
125D:  ADDWF  77,F
125E:  RRF    77,F
125F:  RRF    78,F
1260:  BTFSC  59.2
1261:  ADDWF  77,F
1262:  RRF    77,F
1263:  RRF    78,F
1264:  BTFSC  59.3
1265:  ADDWF  77,F
1266:  RRF    77,F
1267:  RRF    78,F
1268:  BTFSC  59.4
1269:  ADDWF  77,F
126A:  RRF    77,F
126B:  RRF    78,F
126C:  BTFSC  59.5
126D:  ADDWF  77,F
126E:  RRF    77,F
126F:  RRF    78,F
1270:  BTFSC  59.6
1271:  ADDWF  77,F
1272:  RRF    77,F
1273:  RRF    78,F
1274:  BTFSC  59.7
1275:  ADDWF  77,F
1276:  RRF    77,F
1277:  RRF    78,F
1278:  BCF    03.5
1279:  RETURN
127A:  MOVF   00,F
127B:  BTFSC  03.2
127C:  GOTO   298
127D:  BSF    03.5
127E:  CLRF   57
127F:  MOVF   04,W
1280:  MOVWF  56
1281:  BCF    57.0
1282:  BTFSC  03.7
1283:  BSF    57.0
1284:  MOVF   00,W
1285:  MOVWF  5D
1286:  BCF    0A.4
1287:  BCF    03.5
1288:  CALL   7E6
1289:  BSF    0A.4
128A:  BSF    03.5
128B:  MOVF   56,W
128C:  MOVWF  04
128D:  BCF    03.7
128E:  BTFSC  57.0
128F:  BSF    03.7
1290:  INCF   04,F
1291:  BTFSS  03.2
1292:  GOTO   296
1293:  BCF    03.5
1294:  INCF   05,F
1295:  BSF    03.5
1296:  BCF    03.5
1297:  GOTO   27A
1298:  RETURN
*
1384:  BSF    0A.0
1385:  BSF    0A.1
1386:  BCF    0A.2
1387:  ADDWF  02,F
1388:  GOTO   319
1389:  GOTO   326
138A:  GOTO   333
138B:  GOTO   340
138C:  GOTO   34D
138D:  GOTO   35A
138E:  GOTO   367
*
1DA7:  BSF    0A.0
1DA8:  BCF    0A.1
1DA9:  BSF    0A.2
1DAA:  ADDWF  02,F
1DAB:  GOTO   328
1DAC:  GOTO   333
1DAD:  GOTO   33E
1DAE:  GOTO   349
1DAF:  GOTO   354
1DB0:  GOTO   35F
1DB1:  GOTO   36A
1DB2:  BSF    0A.0
1DB3:  BCF    0A.1
1DB4:  BSF    0A.2
1DB5:  ADDWF  02,F
1DB6:  GOTO   3C7
1DB7:  GOTO   3D2
1DB8:  GOTO   3DD
1DB9:  GOTO   3E8
1DBA:  GOTO   3F3
1DBB:  GOTO   3FE
1DBC:  GOTO   409
.................... 
.................... #list
.................... 
.................... #device ADC=10
.................... 
.................... #FUSES NOWDT                    //No Watch Dog Timer
.................... #FUSES NOBROWNOUT               //No brownout reset
.................... #FUSES NOLVP                    //No low voltage prgming, B3(PIC16) or B5(PIC18) used for I/O
.................... #fuses HS
.................... 
.................... #use delay(crystal=20000000)
*
010D:  MOVLW  6A
010E:  MOVWF  04
010F:  BSF    03.7
0110:  MOVF   00,W
0111:  BTFSC  03.2
0112:  GOTO   120
0113:  MOVLW  06
0114:  MOVWF  78
0115:  CLRF   77
0116:  DECFSZ 77,F
0117:  GOTO   116
0118:  DECFSZ 78,F
0119:  GOTO   115
011A:  MOVLW  7B
011B:  MOVWF  77
011C:  DECFSZ 77,F
011D:  GOTO   11C
011E:  DECFSZ 00,F
011F:  GOTO   113
0120:  RETURN
.................... 
.................... //#include <lcd.c>
.................... 
.................... #use I2C(master, I2C1 , FAST = 100000, STREAM = I2C_LCD)  // Include I2C_LCD driver source code
0121:  BCF    14.7
0122:  BCF    0C.3
0123:  BSF    03.5
0124:  MOVF   63,W
0125:  BCF    03.5
0126:  MOVWF  13
0127:  MOVLW  02
0128:  BTFSC  14.7
0129:  GOTO   131
012A:  BSF    03.5
012B:  BTFSC  14.2
012C:  GOTO   12B
012D:  MOVLW  00
012E:  BTFSC  11.6
012F:  MOVLW  01
0130:  BCF    03.5
0131:  MOVWF  78
0132:  RETURN
.................... #include <I2C_LCD.c>
.................... // CCS C driver code for I2C LCDs (HD44780 compliant controllers)
.................... // https://simple-circuit.com/
.................... 
.................... 
.................... 
.................... #define LCD_BACKLIGHT          0x08
.................... #define LCD_NOBACKLIGHT        0x00
.................... #define LCD_FIRST_ROW          0x80
.................... #define LCD_SECOND_ROW         0xC0
.................... #define LCD_THIRD_ROW          0x94
.................... #define LCD_FOURTH_ROW         0xD4
.................... #define LCD_CLEAR              0x01
.................... #define LCD_RETURN_HOME        0x02
.................... #define LCD_ENTRY_MODE_SET     0x04
.................... #define LCD_CURSOR_OFF         0x0C
.................... #define LCD_UNDERLINE_ON       0x0E
.................... #define LCD_BLINK_CURSOR_ON    0x0F
.................... #define LCD_MOVE_CURSOR_LEFT   0x10
.................... #define LCD_MOVE_CURSOR_RIGHT  0x14
.................... #define LCD_TURN_ON            0x0C
.................... #define LCD_TURN_OFF           0x08
.................... #define LCD_SHIFT_LEFT         0x18
.................... #define LCD_SHIFT_RIGHT        0x1E
.................... 
.................... #ifndef LCD_TYPE
....................    #define LCD_TYPE 2           // 0=5x7, 1=5x10, 2=2 lines
.................... #endif
.................... 
.................... 
.................... int1 RS;
.................... unsigned int8 i2c_addr, backlight_val = LCD_BACKLIGHT;
.................... 
.................... void LCD_Write_Nibble(unsigned int8 n);
.................... void LCD_Cmd(unsigned int8 Command);
.................... void LCD_Goto(unsigned int8 col, unsigned int8 row);
.................... void LCD_Out(unsigned int8 LCD_Char);
.................... void LCD_Begin(unsigned int8 _i2c_addr);
.................... void Backlight();
.................... void noBacklight();
.................... void Expander_Write(unsigned int8 value);
.................... 
.................... 
.................... 
.................... void LCD_Write_Nibble(unsigned int8 n) {
....................   n |= RS;
*
014C:  MOVLW  00
014D:  BTFSC  21.0
014E:  MOVLW  01
014F:  BSF    03.5
0150:  IORWF  5F,F
....................   Expander_Write(n);
0151:  MOVF   5F,W
0152:  MOVWF  61
0153:  BCF    03.5
0154:  CALL   133
....................   Expander_Write(n | 0x04);
0155:  BSF    03.5
0156:  MOVF   5F,W
0157:  IORLW  04
0158:  MOVWF  60
0159:  MOVWF  61
015A:  BCF    03.5
015B:  CALL   133
....................   delay_us(1);
015C:  GOTO   15D
015D:  GOTO   15E
015E:  NOP
....................   Expander_Write(n & 0xFB);
015F:  BSF    03.5
0160:  MOVF   5F,W
0161:  ANDLW  FB
0162:  MOVWF  60
0163:  MOVWF  61
0164:  BCF    03.5
0165:  CALL   133
....................   delay_us(50);
0166:  MOVLW  53
0167:  MOVWF  77
0168:  DECFSZ 77,F
0169:  GOTO   168
016A:  RETURN
.................... }
.................... 
.................... void LCD_Cmd(unsigned int8 Command) {
....................   RS = 0;
016B:  BCF    21.0
....................   LCD_Write_Nibble(Command & 0xF0);
016C:  BSF    03.5
016D:  MOVF   59,W
016E:  ANDLW  F0
016F:  MOVWF  5A
0170:  MOVWF  5F
0171:  BCF    03.5
0172:  CALL   14C
....................   LCD_Write_Nibble((Command << 4) & 0xF0);
0173:  BSF    03.5
0174:  SWAPF  59,W
0175:  MOVWF  77
0176:  MOVLW  F0
0177:  ANDWF  77,F
0178:  MOVF   77,W
0179:  ANDLW  F0
017A:  MOVWF  5A
017B:  MOVWF  5F
017C:  BCF    03.5
017D:  CALL   14C
017E:  RETURN
.................... }
.................... 
.................... void LCD_Goto(unsigned int8 row, unsigned int8 col) {
....................   switch(col) {
*
0A48:  BSF    03.5
0A49:  MOVF   57,W
0A4A:  XORLW  02
0A4B:  BCF    03.5
0A4C:  BTFSC  03.2
0A4D:  GOTO   255
0A4E:  XORLW  01
0A4F:  BTFSC  03.2
0A50:  GOTO   260
0A51:  XORLW  07
0A52:  BTFSC  03.2
0A53:  GOTO   26B
0A54:  GOTO   276
....................     case 2:
....................       LCD_Cmd(0xC0 + row-1);
0A55:  MOVLW  C0
0A56:  BSF    03.5
0A57:  ADDWF  56,W
0A58:  ADDLW  FF
0A59:  MOVWF  58
0A5A:  MOVWF  59
0A5B:  BCF    0A.3
0A5C:  BCF    03.5
0A5D:  CALL   16B
0A5E:  BSF    0A.3
....................       break;
0A5F:  GOTO   280
....................     case 3:
....................       LCD_Cmd(0x94 + row-1);
0A60:  MOVLW  94
0A61:  BSF    03.5
0A62:  ADDWF  56,W
0A63:  ADDLW  FF
0A64:  MOVWF  58
0A65:  MOVWF  59
0A66:  BCF    0A.3
0A67:  BCF    03.5
0A68:  CALL   16B
0A69:  BSF    0A.3
....................       break;
0A6A:  GOTO   280
....................     case 4:
....................       LCD_Cmd(0xD4 + row-1);
0A6B:  MOVLW  D4
0A6C:  BSF    03.5
0A6D:  ADDWF  56,W
0A6E:  ADDLW  FF
0A6F:  MOVWF  58
0A70:  MOVWF  59
0A71:  BCF    0A.3
0A72:  BCF    03.5
0A73:  CALL   16B
0A74:  BSF    0A.3
....................     break;
0A75:  GOTO   280
....................     default:      // case 1:
....................       LCD_Cmd(0x80 + row-1);
0A76:  MOVLW  80
0A77:  BSF    03.5
0A78:  ADDWF  56,W
0A79:  ADDLW  FF
0A7A:  MOVWF  58
0A7B:  MOVWF  59
0A7C:  BCF    0A.3
0A7D:  BCF    03.5
0A7E:  CALL   16B
0A7F:  BSF    0A.3
....................   }
0A80:  RETURN
.................... }
.................... 
.................... void LCD_Out(unsigned int8 LCD_Char){
....................   RS = 1;
*
07E6:  BSF    21.0
....................   LCD_Write_Nibble(LCD_Char & 0xF0);
07E7:  BSF    03.5
07E8:  MOVF   5D,W
07E9:  ANDLW  F0
07EA:  MOVWF  5E
07EB:  MOVWF  5F
07EC:  BCF    03.5
07ED:  CALL   14C
....................   LCD_Write_Nibble((LCD_Char << 4) & 0xF0);
07EE:  BSF    03.5
07EF:  SWAPF  5D,W
07F0:  MOVWF  77
07F1:  MOVLW  F0
07F2:  ANDWF  77,F
07F3:  MOVF   77,W
07F4:  ANDLW  F0
07F5:  MOVWF  5E
07F6:  MOVWF  5F
07F7:  BCF    03.5
07F8:  CALL   14C
07F9:  RETURN
.................... }
.................... 
.................... void LCD_Begin(unsigned int8 _i2c_addr) {
....................   i2c_addr = _i2c_addr;
*
017F:  BSF    03.5
0180:  MOVF   53,W
0181:  BCF    03.5
0182:  MOVWF  22
....................   Expander_Write(0);
0183:  BSF    03.5
0184:  CLRF   61
0185:  BCF    03.5
0186:  CALL   133
....................   delay_ms(40);
0187:  MOVLW  28
0188:  BSF    03.6
0189:  MOVWF  6A
018A:  BCF    03.6
018B:  CALL   10D
....................   LCD_Cmd(3);
018C:  MOVLW  03
018D:  BSF    03.5
018E:  MOVWF  59
018F:  BCF    03.5
0190:  CALL   16B
....................   delay_ms(5);
0191:  MOVLW  05
0192:  BSF    03.6
0193:  MOVWF  6A
0194:  BCF    03.6
0195:  CALL   10D
....................   LCD_Cmd(3);
0196:  MOVLW  03
0197:  BSF    03.5
0198:  MOVWF  59
0199:  BCF    03.5
019A:  CALL   16B
....................   delay_ms(5);
019B:  MOVLW  05
019C:  BSF    03.6
019D:  MOVWF  6A
019E:  BCF    03.6
019F:  CALL   10D
....................   LCD_Cmd(3);
01A0:  MOVLW  03
01A1:  BSF    03.5
01A2:  MOVWF  59
01A3:  BCF    03.5
01A4:  CALL   16B
....................   delay_ms(5);
01A5:  MOVLW  05
01A6:  BSF    03.6
01A7:  MOVWF  6A
01A8:  BCF    03.6
01A9:  CALL   10D
....................   LCD_Cmd(LCD_RETURN_HOME);
01AA:  MOVLW  02
01AB:  BSF    03.5
01AC:  MOVWF  59
01AD:  BCF    03.5
01AE:  CALL   16B
....................   delay_ms(5);
01AF:  MOVLW  05
01B0:  BSF    03.6
01B1:  MOVWF  6A
01B2:  BCF    03.6
01B3:  CALL   10D
....................   LCD_Cmd(0x20 | (LCD_TYPE << 2));
01B4:  MOVLW  28
01B5:  BSF    03.5
01B6:  MOVWF  59
01B7:  BCF    03.5
01B8:  CALL   16B
....................   delay_ms(50);
01B9:  MOVLW  32
01BA:  BSF    03.6
01BB:  MOVWF  6A
01BC:  BCF    03.6
01BD:  CALL   10D
....................   LCD_Cmd(LCD_TURN_ON);
01BE:  MOVLW  0C
01BF:  BSF    03.5
01C0:  MOVWF  59
01C1:  BCF    03.5
01C2:  CALL   16B
....................   delay_ms(50);
01C3:  MOVLW  32
01C4:  BSF    03.6
01C5:  MOVWF  6A
01C6:  BCF    03.6
01C7:  CALL   10D
....................   LCD_Cmd(LCD_CLEAR);
01C8:  MOVLW  01
01C9:  BSF    03.5
01CA:  MOVWF  59
01CB:  BCF    03.5
01CC:  CALL   16B
....................   delay_ms(50);
01CD:  MOVLW  32
01CE:  BSF    03.6
01CF:  MOVWF  6A
01D0:  BCF    03.6
01D1:  CALL   10D
....................   LCD_Cmd(LCD_ENTRY_MODE_SET | LCD_RETURN_HOME);
01D2:  MOVLW  06
01D3:  BSF    03.5
01D4:  MOVWF  59
01D5:  BCF    03.5
01D6:  CALL   16B
....................   delay_ms(50);
01D7:  MOVLW  32
01D8:  BSF    03.6
01D9:  MOVWF  6A
01DA:  BCF    03.6
01DB:  CALL   10D
01DC:  BSF    0A.3
01DD:  BSF    0A.4
01DE:  GOTO   11F (RETURN)
.................... }
.................... 
.................... void Backlight() {
....................   backlight_val = LCD_BACKLIGHT;
....................   Expander_Write(0);
.................... }
.................... 
.................... void noBacklight() {
....................   backlight_val = LCD_NOBACKLIGHT;
....................   Expander_Write(0);
.................... }
.................... 
.................... void Expander_Write(unsigned int8 value) {
....................   I2C_Start(I2C_LCD);
*
0133:  BSF    03.5
0134:  BSF    11.0
0135:  BTFSC  11.0
0136:  GOTO   135
....................   I2C_Write(I2C_LCD, i2c_addr);
0137:  BCF    03.5
0138:  MOVF   22,W
0139:  BSF    03.5
013A:  MOVWF  63
013B:  BCF    03.5
013C:  CALL   121
....................   I2C_Write(I2C_LCD, value | backlight_val);
013D:  BSF    03.5
013E:  MOVF   61,W
013F:  BCF    03.5
0140:  IORWF  23,W
0141:  BSF    03.5
0142:  MOVWF  62
0143:  MOVWF  63
0144:  BCF    03.5
0145:  CALL   121
....................   I2C_Stop(I2C_LCD);
0146:  BSF    03.5
0147:  BSF    11.2
0148:  BTFSC  11.2
0149:  GOTO   148
014A:  BCF    03.5
014B:  RETURN
.................... }
.................... 
.................... void lcd_putc( unsigned int8 c) {
....................    switch (c) {
*
07D6:  MOVF   56,W
07D7:  XORLW  0C
07D8:  BCF    03.5
07D9:  BTFSS  03.2
07DA:  GOTO   7E5
....................      case '\f'   : LCD_Cmd(0x01);
07DB:  MOVLW  01
07DC:  BSF    03.5
07DD:  MOVWF  59
07DE:  BCF    03.5
07DF:  CALL   16B
....................                    delay_ms(2);
07E0:  MOVLW  02
07E1:  BSF    03.6
07E2:  MOVWF  6A
07E3:  BCF    03.6
07E4:  CALL   10D
....................                                            break;
....................      
....................    }
.................... }
.................... 
.................... 
.................... #use I2C(master, scl=PIN_C3, sda=PIN_C4 , FAST = 100000)
.................... //!#use fast_io(B)
.................... //!#use fast_io(D)
.................... 
.................... 
.................... #use rs232(uart1, baud=9600,ERRORS)
.................... #include <stdio.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDIO
.................... #define _STDIO
.................... #include <string.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STRING
.................... #define _STRING
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... #include <ctype.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _CTYPE
.................... #define _CTYPE
.................... 
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz")
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ")
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
.................... #define isdigit(x)  isamong(x,"0123456789")
.................... #define isspace(x)  ((x)==' ')
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef")
.................... #define iscntrl(x)  ((x)<' ')
.................... #define isprint(x)  ((x)>=' ')
.................... #define isgraph(x)  ((x)>' ')
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x))
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... 
.................... 
.................... //////////////////////////////////////////////
.................... //// Uncomment the following define to    ////
.................... //// allow some functions to use a        ////
.................... //// quicker algorithm, but use more ROM  ////
.................... ////                                      ////
.................... //// #define FASTER_BUT_MORE_ROM          ////
.................... //////////////////////////////////////////////
.................... 
.................... 
.................... 
.................... /*Copying functions*/
.................... /* standard template:
....................    void *memmove(void *s1, void *s2, size_t n).
....................    Copies max of n characters safely (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... unsigned char *memmove(void *s1,void *s2,size_t n)
.................... {
....................    unsigned char *sc1;
....................    unsigned char *sc2;
....................    sc1=s1;
....................    sc2=s2;
....................    if(sc2<sc1 && sc1 <sc2 +n)
....................       for(sc1+=n,sc2+=n;0<n;--n)
....................          *--sc1=*--sc2;
....................    else
....................       for(;0<n;--n)
....................          *sc1++=*sc2++;
....................   return s1;
....................   }
.................... 
.................... /* Standard template: char *strcpy(char *s1, const char *s2)
....................    copies the string s2 including the null character to s1.
....................    This is a compiler built in to handle the different address
....................    spaces */
.................... 
.................... #define strcopy strcpy
.................... 
.................... /* standard template:
....................    char *strncpy(char *s1, const char *s2, size_t n).
....................    Copies max of n characters (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... char *strncpy(char *s1, char *s2, size_t n)
.................... {
....................   char *s;
.................... 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--)
....................      *s++ = *s2++;
....................   for (; n > 0; n--)
....................      *s++ = '\0';
.................... 
....................   return(s1);
.................... }
.................... /***********************************************************/
.................... 
.................... /*concatenation functions*/
.................... /* standard template: char *strcat(char *s1, const char *s2)
.................... appends s2 to s1*/
.................... 
.................... char *strcat(char *s1, char *s2)
.................... {
....................    unsigned char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0')
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n)
.................... appends not more than n characters from s2 to s1*/
.................... 
.................... char *strncat(char *s1, char *s2, size_t n)
.................... {
....................    char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0' && 0<n)
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................       --n;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... 
.................... /***********************************************************/
.................... 
.................... 
.................... /*comparison functions*/
.................... /* standard template: signed int memcmp(void *s1, void *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int memcmp(void * s1,void *s2,size_t n)
.................... {
.................... unsigned char *su1, *su2;
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n)
.................... {
....................    if(*su1!=*su2)
....................       return ((*su1<*su2)?-1:1);
.................... }
.................... return 0;
.................... }
.................... 
.................... /* standard template: int strcmp(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcmp(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... /* standard template: int strcoll(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcoll(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... /* standard template:
....................    int strncmp(const char *s1, const char *s2, size_t n).
....................    Compares max of n characters (not following 0) from s1 to s2;
....................    returns same as strcmp */
.................... 
.................... signed int strncmp(char *s1, char *s2, size_t n)
.................... {
....................    for (; n > 0; s1++, s2++, n--)
....................       if (*s1 != *s2)
....................          return((*s1 <*s2) ? -1: 1);
....................       else if (*s1 == '\0')
....................          return(0);
....................    return(0);
.................... }
.................... /* standard template:
....................    int strxfrm(const char *s1, const char *s2, size_t n).
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1.
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/
.................... size_t strxfrm(char *s1, char *s2, size_t n)
.................... {
....................    char c;
....................    size_t n1;
....................    
....................    if (!s1 && !n)
....................       n = -1; //find length
.................... 
....................    n1 = 0;
....................    
....................    for (; n1 < n; n1++)
....................    {
....................       c = *s2++;
....................       if (!c)
....................          break;
....................       if (s1)
....................          *s1++ = c;
....................    }
.................... 
....................   return(n1);
.................... }
.................... 
.................... 
.................... 
.................... 
.................... 
.................... /***********************************************************/
.................... /*Search functions*/
.................... /* standard template: void *memchr(const char *s, int c).
....................    Finds first occurrence of c in n characters of s */
.................... 
.................... char *memchr(void *s,unsigned int8 c,size_t n)
.................... {
....................    char uc;
....................    char *su;
....................    uc=c;
....................    for(su=s;0<n;++su,--n)
....................       if(*su==uc)
....................       return su;
....................    return NULL;
.................... }
.................... 
.................... /* standard template: char *strchr(const char *s, int c).
....................    Finds first occurrence of c in s */
.................... 
.................... char *strchr(char *s, char c)
.................... {
....................    for (; *s != c; s++)
....................       if (*s == '\0')
....................          return(0);
....................    return(s);
.................... }
.................... /* standard template:
....................    size_t strcspn(const char *s1, const char *s2).
....................    Computes length of max initial segment of s1 that
....................    consists entirely of characters NOT from s2*/
.................... 
.................... size_t strcspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1 - s1);
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strpbrk(const char *s1, const char *s2).
....................    Locates first occurence of any character from s2 in s1;
....................    returns s1 if s2 is empty string */
.................... 
.................... char *strpbrk(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1);
....................    return(0);
.................... }
.................... 
.................... 
.................... /* standard template: char *strrchr(const char *s, int c).
....................    Finds last occurrence of c in s */
.................... 
.................... char *strrchr(char *s, char c)
.................... {
....................    char *p;
.................... 
....................    for (p = 0; ; s++)
....................    {
....................       if (*s == c)
....................          p = s;
....................       if (*s == '\0')
....................          return(p);
....................    }
.................... }
.................... /* computes length of max initial segment of s1 consisting
....................    entirely of characters from s2 */
.................... 
.................... size_t strspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; ; sc2++)
....................     if (*sc2 == '\0')
....................        return(sc1 - s1);
....................          else if (*sc1 == *sc2)
....................             break;
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strstr(const char *s1, const char *s2);
....................    Locates first occurence of character sequence s2 in s1;
....................    returns 0 if s2 is empty string
.................... 
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the
....................    file to use the faster algorithm */
.................... char *strstr(char *s1, char *s2)
.................... {
....................    char *s, *t;
.................... 
....................    #ifdef FASTER_BUT_MORE_ROM
....................    if (*s2 == '\0')
....................          return(s1);
....................    #endif
.................... 
....................    while (*s1)
....................    {
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t);
.................... 
....................       if (*t == '\0')
....................          return s1;
....................       ++s1;
....................       #ifdef FASTER_BUT_MORE_ROM
....................          while(*s1 != '\0' && *s1 != *s2)
....................             ++s1;
....................       #endif
....................    }
....................    return 0;
.................... }
.................... 
.................... /* standard template: size_t strlen(const char *s).
....................    Computes length of s1 (preceding terminating 0) */
.................... 
.................... size_t strlen(char *s)
.................... {
....................    char *sc;
.................... 
....................    for (sc = s; *sc != 0; sc++);
*
053E:  MOVF   6B,W
053F:  MOVWF  6D
0540:  MOVF   6A,W
0541:  MOVWF  6C
0542:  MOVF   6D,W
0543:  MOVWF  7A
0544:  MOVF   6C,W
0545:  MOVWF  04
0546:  BCF    03.7
0547:  BTFSC  7A.0
0548:  BSF    03.7
0549:  MOVF   00,F
054A:  BTFSC  03.2
054B:  GOTO   550
054C:  INCF   6C,F
054D:  BTFSC  03.2
054E:  INCF   6D,F
054F:  GOTO   542
....................    return(sc - s);
0550:  MOVF   6A,W
0551:  SUBWF  6C,W
0552:  MOVWF  77
0553:  MOVF   6D,W
0554:  MOVWF  7A
0555:  MOVF   6B,W
0556:  BTFSS  03.0
0557:  INCFSZ 6B,W
0558:  SUBWF  7A,F
0559:  MOVF   77,W
055A:  MOVWF  78
.................... }
.................... 
.................... /* standard template: char *strtok(char *s1, const char *s2).
.................... 
....................    Finds next token in s1 delimited by a character from separator
....................    string s2 (which can be different from call to call).  First call
....................    starts at beginning of s1 searching for first character NOT
....................    contained in s2; returns 0 if none is found.
....................    If one is found, it is the start of first token (return value).
....................    Function then searches from there for a character contained in s2.
....................    If none is found, current token extends to end of s1, and subsequent
....................    searches for a token will return 0.  If one is found, it is
....................    overwritten by '\0', which terminates current token.  Function saves
....................    pointer to following character from which next search will start.
....................    Each subsequent call, with 0 as first argument, starts searching
....................    from saved pointer */
.................... 
.................... char *strtok(char *s1, char *s2)
.................... {
....................    char *beg, *end;
....................    static char *save;
*
184A:  BCF    03.6
184B:  CLRF   25
184C:  CLRF   26
.................... 
....................    beg = (s1)? s1: save;
....................    beg += strspn(beg, s2);
....................    if (*beg == '\0')
....................       return(0);
....................       
....................    end = strpbrk(beg, s2);
....................    if (end != '\0')
....................    {
....................       *end = '\0';
....................       end++;
....................       save = end;
....................    }
....................    else
....................       save = beg + strlen(beg);
....................    
....................    return(beg);
.................... }
.................... 
.................... /*****************************************************************/
.................... /*Miscellaneous functions*/
.................... /* standard template
.................... maps error number in errnum to an error message string
.................... Returns: Pointer to string
.................... */
.................... #ifdef _ERRNO
.................... char * strerror(unsigned int8 errnum)
.................... {
.................... static unsigned char s[13];
.................... switch( errnum)
.................... {
.................... case 0:
....................    strcpy(s,"no errors");
....................    return s;
.................... case EDOM :
....................    strcpy(s,"domain error");
....................    return s;
.................... case ERANGE:
....................    strcpy(s,"range error");
....................    return s;
.................... }
.................... }
.................... #ENDIF
.................... 
.................... /* standard template: size_t stricmp(const char *s1, const char *s2).
....................    Compares s1 to s2 ignoring case (upper vs. lower) */
.................... 
.................... signed int stricmp(char *s1, char *s2)
.................... {
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&((char)*s1==(char)*s2+(char)32||(char)*s2==(char)*s1+(char)32));
....................     s1++, s2++)
....................     if (*s1 == '\0')
....................        return(0);
....................  return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... 
.................... /* standard template: char *strlwr(char *s).
....................    Replaces uppercase letters by lowercase;
....................    returns pointer to new string s */
.................... 
.................... char *strlwr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'A' && *p <='Z')
....................          *p += 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... /* standard template: char *strupr(char *s).
....................    Replaces lowercase letters by upercase;
....................    returns pointer to new string s */
.................... 
.................... char *strupr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'a' && *p <='z')
....................          *p -= 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... 
.................... /************************************************************/
.................... 
.................... 
.................... #endif
.................... 
.................... #ifndef getc
.................... #define getc getch
.................... #define getchar getch
.................... #define puts(s) {printf(s); putchar(13); putchar(10);}
.................... #define putc putchar
.................... #endif
.................... /* maps error number to an error message. Writes a sequence of characters to
.................... stderr stream thus: if s is not null then string pointed to by s follwed by
.................... a colon (:) and a space and the appropriate error message returned by strerror
.................... function with argument errno
.................... 
.................... Returns: no value
.................... */
.................... 
.................... #ifdef _ERRNO
.................... void perror(char *s)
.................... {
....................   if(s)
....................   fprintf(STDERR,"%s: ",s);
....................   fprintf(STDERR,"%s\r\n",strerror(errno));
.................... }
.................... #endif
.................... #endif
.................... 
.................... #include <string.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STRING
.................... #define _STRING
.................... #include <stddef.h>
.................... #include <ctype.h>
.................... 
.................... 
.................... 
.................... //////////////////////////////////////////////
.................... //// Uncomment the following define to    ////
.................... //// allow some functions to use a        ////
.................... //// quicker algorithm, but use more ROM  ////
.................... ////                                      ////
.................... //// #define FASTER_BUT_MORE_ROM          ////
.................... //////////////////////////////////////////////
.................... 
.................... 
.................... 
.................... /*Copying functions*/
.................... /* standard template:
....................    void *memmove(void *s1, void *s2, size_t n).
....................    Copies max of n characters safely (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... unsigned char *memmove(void *s1,void *s2,size_t n)
.................... {
....................    unsigned char *sc1;
....................    unsigned char *sc2;
....................    sc1=s1;
....................    sc2=s2;
....................    if(sc2<sc1 && sc1 <sc2 +n)
....................       for(sc1+=n,sc2+=n;0<n;--n)
....................          *--sc1=*--sc2;
....................    else
....................       for(;0<n;--n)
....................          *sc1++=*sc2++;
....................   return s1;
....................   }
.................... 
.................... /* Standard template: char *strcpy(char *s1, const char *s2)
....................    copies the string s2 including the null character to s1.
....................    This is a compiler built in to handle the different address
....................    spaces */
.................... 
.................... #define strcopy strcpy
.................... 
.................... /* standard template:
....................    char *strncpy(char *s1, const char *s2, size_t n).
....................    Copies max of n characters (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... char *strncpy(char *s1, char *s2, size_t n)
.................... {
....................   char *s;
.................... 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--)
....................      *s++ = *s2++;
....................   for (; n > 0; n--)
....................      *s++ = '\0';
.................... 
....................   return(s1);
.................... }
.................... /***********************************************************/
.................... 
.................... /*concatenation functions*/
.................... /* standard template: char *strcat(char *s1, const char *s2)
.................... appends s2 to s1*/
.................... 
.................... char *strcat(char *s1, char *s2)
.................... {
....................    unsigned char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0')
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n)
.................... appends not more than n characters from s2 to s1*/
.................... 
.................... char *strncat(char *s1, char *s2, size_t n)
.................... {
....................    char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0' && 0<n)
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................       --n;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... 
.................... /***********************************************************/
.................... 
.................... 
.................... /*comparison functions*/
.................... /* standard template: signed int memcmp(void *s1, void *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int memcmp(void * s1,void *s2,size_t n)
.................... {
.................... unsigned char *su1, *su2;
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n)
.................... {
....................    if(*su1!=*su2)
....................       return ((*su1<*su2)?-1:1);
.................... }
.................... return 0;
.................... }
.................... 
.................... /* standard template: int strcmp(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcmp(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... /* standard template: int strcoll(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcoll(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... /* standard template:
....................    int strncmp(const char *s1, const char *s2, size_t n).
....................    Compares max of n characters (not following 0) from s1 to s2;
....................    returns same as strcmp */
.................... 
.................... signed int strncmp(char *s1, char *s2, size_t n)
.................... {
....................    for (; n > 0; s1++, s2++, n--)
....................       if (*s1 != *s2)
....................          return((*s1 <*s2) ? -1: 1);
....................       else if (*s1 == '\0')
....................          return(0);
....................    return(0);
.................... }
.................... /* standard template:
....................    int strxfrm(const char *s1, const char *s2, size_t n).
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1.
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/
.................... size_t strxfrm(char *s1, char *s2, size_t n)
.................... {
....................    char c;
....................    size_t n1;
....................    
....................    if (!s1 && !n)
....................       n = -1; //find length
.................... 
....................    n1 = 0;
....................    
....................    for (; n1 < n; n1++)
....................    {
....................       c = *s2++;
....................       if (!c)
....................          break;
....................       if (s1)
....................          *s1++ = c;
....................    }
.................... 
....................   return(n1);
.................... }
.................... 
.................... 
.................... 
.................... 
.................... 
.................... /***********************************************************/
.................... /*Search functions*/
.................... /* standard template: void *memchr(const char *s, int c).
....................    Finds first occurrence of c in n characters of s */
.................... 
.................... char *memchr(void *s,unsigned int8 c,size_t n)
.................... {
....................    char uc;
....................    char *su;
....................    uc=c;
....................    for(su=s;0<n;++su,--n)
....................       if(*su==uc)
....................       return su;
....................    return NULL;
.................... }
.................... 
.................... /* standard template: char *strchr(const char *s, int c).
....................    Finds first occurrence of c in s */
.................... 
.................... char *strchr(char *s, char c)
.................... {
....................    for (; *s != c; s++)
....................       if (*s == '\0')
....................          return(0);
....................    return(s);
.................... }
.................... /* standard template:
....................    size_t strcspn(const char *s1, const char *s2).
....................    Computes length of max initial segment of s1 that
....................    consists entirely of characters NOT from s2*/
.................... 
.................... size_t strcspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1 - s1);
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strpbrk(const char *s1, const char *s2).
....................    Locates first occurence of any character from s2 in s1;
....................    returns s1 if s2 is empty string */
.................... 
.................... char *strpbrk(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1);
....................    return(0);
.................... }
.................... 
.................... 
.................... /* standard template: char *strrchr(const char *s, int c).
....................    Finds last occurrence of c in s */
.................... 
.................... char *strrchr(char *s, char c)
.................... {
....................    char *p;
.................... 
....................    for (p = 0; ; s++)
....................    {
....................       if (*s == c)
....................          p = s;
....................       if (*s == '\0')
....................          return(p);
....................    }
.................... }
.................... /* computes length of max initial segment of s1 consisting
....................    entirely of characters from s2 */
.................... 
.................... size_t strspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; ; sc2++)
....................     if (*sc2 == '\0')
....................        return(sc1 - s1);
....................          else if (*sc1 == *sc2)
....................             break;
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strstr(const char *s1, const char *s2);
....................    Locates first occurence of character sequence s2 in s1;
....................    returns 0 if s2 is empty string
.................... 
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the
....................    file to use the faster algorithm */
.................... char *strstr(char *s1, char *s2)
.................... {
....................    char *s, *t;
.................... 
....................    #ifdef FASTER_BUT_MORE_ROM
....................    if (*s2 == '\0')
....................          return(s1);
....................    #endif
.................... 
....................    while (*s1)
....................    {
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t);
.................... 
....................       if (*t == '\0')
....................          return s1;
....................       ++s1;
....................       #ifdef FASTER_BUT_MORE_ROM
....................          while(*s1 != '\0' && *s1 != *s2)
....................             ++s1;
....................       #endif
....................    }
....................    return 0;
.................... }
.................... 
.................... /* standard template: size_t strlen(const char *s).
....................    Computes length of s1 (preceding terminating 0) */
.................... 
.................... size_t strlen(char *s)
.................... {
....................    char *sc;
.................... 
....................    for (sc = s; *sc != 0; sc++);
....................    return(sc - s);
.................... }
.................... 
.................... /* standard template: char *strtok(char *s1, const char *s2).
.................... 
....................    Finds next token in s1 delimited by a character from separator
....................    string s2 (which can be different from call to call).  First call
....................    starts at beginning of s1 searching for first character NOT
....................    contained in s2; returns 0 if none is found.
....................    If one is found, it is the start of first token (return value).
....................    Function then searches from there for a character contained in s2.
....................    If none is found, current token extends to end of s1, and subsequent
....................    searches for a token will return 0.  If one is found, it is
....................    overwritten by '\0', which terminates current token.  Function saves
....................    pointer to following character from which next search will start.
....................    Each subsequent call, with 0 as first argument, starts searching
....................    from saved pointer */
.................... 
.................... char *strtok(char *s1, char *s2)
.................... {
....................    char *beg, *end;
....................    static char *save;
.................... 
....................    beg = (s1)? s1: save;
....................    beg += strspn(beg, s2);
....................    if (*beg == '\0')
....................       return(0);
....................       
....................    end = strpbrk(beg, s2);
....................    if (end != '\0')
....................    {
....................       *end = '\0';
....................       end++;
....................       save = end;
....................    }
....................    else
....................       save = beg + strlen(beg);
....................    
....................    return(beg);
.................... }
.................... 
.................... /*****************************************************************/
.................... /*Miscellaneous functions*/
.................... /* standard template
.................... maps error number in errnum to an error message string
.................... Returns: Pointer to string
.................... */
.................... #ifdef _ERRNO
.................... char * strerror(unsigned int8 errnum)
.................... {
.................... static unsigned char s[13];
.................... switch( errnum)
.................... {
.................... case 0:
....................    strcpy(s,"no errors");
....................    return s;
.................... case EDOM :
....................    strcpy(s,"domain error");
....................    return s;
.................... case ERANGE:
....................    strcpy(s,"range error");
....................    return s;
.................... }
.................... }
.................... #ENDIF
.................... 
.................... /* standard template: size_t stricmp(const char *s1, const char *s2).
....................    Compares s1 to s2 ignoring case (upper vs. lower) */
.................... 
.................... signed int stricmp(char *s1, char *s2)
.................... {
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&((char)*s1==(char)*s2+(char)32||(char)*s2==(char)*s1+(char)32));
....................     s1++, s2++)
....................     if (*s1 == '\0')
....................        return(0);
....................  return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... 
.................... /* standard template: char *strlwr(char *s).
....................    Replaces uppercase letters by lowercase;
....................    returns pointer to new string s */
.................... 
.................... char *strlwr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'A' && *p <='Z')
....................          *p += 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... /* standard template: char *strupr(char *s).
....................    Replaces lowercase letters by upercase;
....................    returns pointer to new string s */
.................... 
.................... char *strupr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'a' && *p <='z')
....................          *p -= 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... 
.................... /************************************************************/
.................... 
.................... 
.................... #endif
.................... 
.................... #include <stdlib.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... 
.................... #ifndef _STDLIB
.................... #define _STDLIB
.................... 
.................... //---------------------------------------------------------------------------
.................... // Definitions and types
.................... //---------------------------------------------------------------------------
.................... 
.................... #ifndef RAND_MAX
.................... #define RAND_MAX  32767    // The value of which is the maximum value
....................                            // ... returned by the rand function
.................... #endif
.................... 
.................... 
.................... #IF (sizeof(int16*)>1)
.................... #DEFINE LONG_POINTERS 1
.................... #ELSE 
.................... #DEFINE LONG_POINTERS 0
.................... #ENDIF
.................... 
.................... typedef struct {
....................    signed int quot;
....................    signed int rem;
.................... } div_t;
.................... 
.................... typedef struct {
....................    signed long quot;
....................    signed long rem;
.................... } ldiv_t;
.................... 
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... 
.................... //---------------------------------------------------------------------------
.................... // String conversion functions
.................... //---------------------------------------------------------------------------
.................... 
.................... /* Standard template: signed int  atoi(char * s)
....................  * converts the initial portion of the string s to a signed int
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... signed int atoi(char *s);
.................... 
.................... /* Syntax: signed int32  atoi32(char * s)
....................    converts the initial portion of the string s to a signed int32
....................    returns the converted value if any, 0 otherwise*/
.................... #if (sizeof(long)==4)
....................  #define atoi32(s) atol(s)
.................... #else 
....................  signed int32 atoi32(char *s);
.................... #endif
.................... 
.................... #if defined(__PCD__)
.................... // The following functions only work on the 24 bit compiler
.................... // for the 30F, 33F, 24F and 24H parts
.................... /* Syntax: signed int48  atoi48(char * s)
....................    converts the initial portion of the string s to a signed int48
....................    returns the converted value if any, 0 otherwise*/
....................    
.................... signed int48 atoi48(char *s);
.................... 
.................... /* Syntax: signed int64  atoi64(char * s)
....................    converts the initial portion of the string s to a signed int64
....................    returns the converted value if any, 0 otherwise*/
.................... signed int64 atoi64(char *s);
.................... #endif
.................... 
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s)
....................    converts the signed int32 to a string and
....................    returns the converted value if any, 0 otherwise*/
.................... char * itoa(signed int32 num, unsigned int base, char * s);
.................... 
.................... /* Standard template: signed int16  atol(char * s)
....................  * converts the initial portion of the string s to a signed int16
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... signed long atol(char *s);
.................... 
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base)
....................  * converts the initial portion of the string s, represented as an
....................  * integral value of radix base  to a signed long.
....................  * Returns the converted value if any, 0 otherwise
....................  * the final string is returned in the endptr, if endptr is not null
....................  */
.................... signed long strtol(char *s,char *endptr, signed int base);
.................... 
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base)
....................  * converts the initial portion of the string s, represented as an
....................  * integral value of radix base to a unsigned long.
....................  * returns the converted value if any, 0 otherwise
....................  * the final string is returned in the endptr, if endptr is not null
....................  */
.................... unsigned long strtoul(char *s,char *endptr, signed int base);
.................... 
.................... /* Standart template: float strtof(char * s,char *endptr)
....................                       float48 strtof48(char *s,char *endptr);
....................                       float64 strtod(char *s,char *endptr);
....................  * converts the initial portion of the string s to a float32, float48 or float64,
....................  * returns the converted value if any, 0 otherwise
....................  * the final string is returned in the endptr, if endptr is not null                   
.................... */
.................... float strtof(char *s,char **endptr);
.................... #if defined(__PCD__)
.................... float48 strtof48(char *s,char **endptr);
.................... float64 strtod(char *s,char **endptr);
.................... #else
.................... //provided for compatibility
.................... #define strtof48(s, e) strtof(s, e)
.................... #define strtod(s, e) strtof(s, e)
.................... #endif
.................... 
.................... /* Standard template: float32 atof(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... #define atof(s)   strtof(s, (char*)0)
.................... 
.................... #if defined(__PCD__)
.................... // The following functions only work on the 24 bit compiler
.................... // for the 30F, 33F, 24F and 24H parts
.................... 
.................... /* Standard template: float48 atof48(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... #define atof48(s) strtof48(s, 0)
.................... 
.................... /* Standard template: float64 atof64(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... #define atof64(s) strtod(s, 0)
.................... #endif
.................... 
.................... /* Standard template: float32 atoe(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  * also handles E format numbers
....................  */
.................... #if !defined(__PCD__)
.................... float atoe(char * s);
.................... #endif
.................... 
.................... #if defined(__PCD__)
.................... float32 atoe(char * s);
.................... #endif
.................... 
.................... //---------------------------------------------------------------------------
.................... // Pseudo-random sequence generation functions
.................... //---------------------------------------------------------------------------
.................... 
.................... /* The rand function computes a sequence of pseudo-random integers in
....................  * the range 0 to RAND_MAX
....................  *
....................  * Parameters:
....................  *       (none)
....................  *
....................  * Returns:
....................  *       The pseudo-random integer
....................  */
.................... unsigned int16 rand(void);
.................... 
.................... /* The srand function uses the argument as a seed for a new sequence of
....................  * pseudo-random numbers to be returned by subsequent calls to rand.
....................  *
....................  * Parameters:
....................  *       [in] seed: The seed value to start from. You might need to pass
....................  *
....................  * Returns:
....................  *       (none)
....................  *
....................  * Remarks
....................  *          The srand function sets the starting point for generating
....................  *       a series of pseudorandom integers. To reinitialize the
....................  *       generator, use 1 as the seed argument. Any other value for
....................  *       seed sets the generator to a random starting point. rand
....................  *       retrieves the pseudorandom numbers that are generated.
....................  *       Calling rand before any call to srand generates the same
....................  *       sequence as calling srand with seed passed as 1.
....................  *          Usually, you need to pass a time here from outer source
....................  *       so that the numbers will be different every time you run.
....................  */
.................... void srand(unsigned int32 seed);
.................... 
.................... //---------------------------------------------------------------------------
.................... // Memory management functions
.................... //---------------------------------------------------------------------------
.................... 
.................... // Comming soon
.................... 
.................... //---------------------------------------------------------------------------
.................... // Communication with the environment
.................... //---------------------------------------------------------------------------
.................... 
.................... /* The function returns 0 always
....................  */
.................... signed int8 system(char *string);
.................... 
.................... //---------------------------------------------------------------------------
.................... // Searching and sorting utilities
.................... //---------------------------------------------------------------------------
.................... 
.................... /* Performs a binary search of a sorted array..
....................  *
....................  * Parameters:
....................  *       [in] key: Object to search for
....................  *       [in] base: Pointer to base of search data
....................  *       [in] num: Number of elements
....................  *       [in] width: Width of elements
....................  *       [in] compare: Function that compares two elements
....................  *
....................  * Returns:
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed
....................  *       to by base. If key is not found, the function returns NULL. If the
....................  *       array is not in order or contains duplicate records with identical keys,
....................  *       the result is unpredictable.
....................  */
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width,
.................... //              int (*compare)(const void *, const void *));
.................... 
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents
....................  * of the array are sorted into ascending order according to a comparison
....................  * function pointed to by compar.
....................  *
....................  * Parameters:
....................  *       [in] base: Pointer to base of search data
....................  *       [in] num: Number of elements
....................  *       [in] width: Width of elements
....................  *       [in] compare: Function that compares two elements
....................  *
....................  * Returns:
....................  *       (none)
....................  */
.................... //void *qsort(const void *base, size_t num, size_t width,
.................... //              int (*compare)(const void *, const void *));
.................... 
.................... //---------------------------------------------------------------------------
.................... // Integer arithmetic functions
.................... //---------------------------------------------------------------------------
.................... 
.................... #define labs abs
.................... 
.................... div_t div(signed int numer, signed int denom);
.................... ldiv_t ldiv(signed long numer, signed long denom);
.................... 
.................... //---------------------------------------------------------------------------
.................... // Multibyte character functions
.................... //---------------------------------------------------------------------------
.................... 
.................... // Not supported
.................... 
.................... //---------------------------------------------------------------------------
.................... // Multibyte string functions
.................... //---------------------------------------------------------------------------
.................... 
.................... // Not supported
.................... 
.................... 
.................... //---------------------------------------------------------------------------
.................... // Internal implementation
.................... //---------------------------------------------------------------------------
.................... 
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... #include <string.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STRING
.................... #define _STRING
.................... #include <stddef.h>
.................... #include <ctype.h>
.................... 
.................... 
.................... 
.................... //////////////////////////////////////////////
.................... //// Uncomment the following define to    ////
.................... //// allow some functions to use a        ////
.................... //// quicker algorithm, but use more ROM  ////
.................... ////                                      ////
.................... //// #define FASTER_BUT_MORE_ROM          ////
.................... //////////////////////////////////////////////
.................... 
.................... 
.................... 
.................... /*Copying functions*/
.................... /* standard template:
....................    void *memmove(void *s1, void *s2, size_t n).
....................    Copies max of n characters safely (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... unsigned char *memmove(void *s1,void *s2,size_t n)
.................... {
....................    unsigned char *sc1;
....................    unsigned char *sc2;
....................    sc1=s1;
....................    sc2=s2;
....................    if(sc2<sc1 && sc1 <sc2 +n)
....................       for(sc1+=n,sc2+=n;0<n;--n)
....................          *--sc1=*--sc2;
....................    else
....................       for(;0<n;--n)
....................          *sc1++=*sc2++;
....................   return s1;
....................   }
.................... 
.................... /* Standard template: char *strcpy(char *s1, const char *s2)
....................    copies the string s2 including the null character to s1.
....................    This is a compiler built in to handle the different address
....................    spaces */
.................... 
.................... #define strcopy strcpy
.................... 
.................... /* standard template:
....................    char *strncpy(char *s1, const char *s2, size_t n).
....................    Copies max of n characters (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... char *strncpy(char *s1, char *s2, size_t n)
.................... {
....................   char *s;
.................... 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--)
....................      *s++ = *s2++;
....................   for (; n > 0; n--)
....................      *s++ = '\0';
.................... 
....................   return(s1);
.................... }
.................... /***********************************************************/
.................... 
.................... /*concatenation functions*/
.................... /* standard template: char *strcat(char *s1, const char *s2)
.................... appends s2 to s1*/
.................... 
.................... char *strcat(char *s1, char *s2)
.................... {
....................    unsigned char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0')
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n)
.................... appends not more than n characters from s2 to s1*/
.................... 
.................... char *strncat(char *s1, char *s2, size_t n)
.................... {
....................    char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0' && 0<n)
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................       --n;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... 
.................... /***********************************************************/
.................... 
.................... 
.................... /*comparison functions*/
.................... /* standard template: signed int memcmp(void *s1, void *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int memcmp(void * s1,void *s2,size_t n)
.................... {
.................... unsigned char *su1, *su2;
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n)
.................... {
....................    if(*su1!=*su2)
....................       return ((*su1<*su2)?-1:1);
.................... }
.................... return 0;
.................... }
.................... 
.................... /* standard template: int strcmp(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcmp(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... /* standard template: int strcoll(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcoll(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... /* standard template:
....................    int strncmp(const char *s1, const char *s2, size_t n).
....................    Compares max of n characters (not following 0) from s1 to s2;
....................    returns same as strcmp */
.................... 
.................... signed int strncmp(char *s1, char *s2, size_t n)
.................... {
....................    for (; n > 0; s1++, s2++, n--)
....................       if (*s1 != *s2)
....................          return((*s1 <*s2) ? -1: 1);
....................       else if (*s1 == '\0')
....................          return(0);
....................    return(0);
.................... }
.................... /* standard template:
....................    int strxfrm(const char *s1, const char *s2, size_t n).
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1.
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/
.................... size_t strxfrm(char *s1, char *s2, size_t n)
.................... {
....................    char c;
....................    size_t n1;
....................    
....................    if (!s1 && !n)
....................       n = -1; //find length
.................... 
....................    n1 = 0;
....................    
....................    for (; n1 < n; n1++)
....................    {
....................       c = *s2++;
....................       if (!c)
....................          break;
....................       if (s1)
....................          *s1++ = c;
....................    }
.................... 
....................   return(n1);
.................... }
.................... 
.................... 
.................... 
.................... 
.................... 
.................... /***********************************************************/
.................... /*Search functions*/
.................... /* standard template: void *memchr(const char *s, int c).
....................    Finds first occurrence of c in n characters of s */
.................... 
.................... char *memchr(void *s,unsigned int8 c,size_t n)
.................... {
....................    char uc;
....................    char *su;
....................    uc=c;
....................    for(su=s;0<n;++su,--n)
....................       if(*su==uc)
....................       return su;
....................    return NULL;
.................... }
.................... 
.................... /* standard template: char *strchr(const char *s, int c).
....................    Finds first occurrence of c in s */
.................... 
.................... char *strchr(char *s, char c)
.................... {
....................    for (; *s != c; s++)
....................       if (*s == '\0')
....................          return(0);
....................    return(s);
.................... }
.................... /* standard template:
....................    size_t strcspn(const char *s1, const char *s2).
....................    Computes length of max initial segment of s1 that
....................    consists entirely of characters NOT from s2*/
.................... 
.................... size_t strcspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1 - s1);
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strpbrk(const char *s1, const char *s2).
....................    Locates first occurence of any character from s2 in s1;
....................    returns s1 if s2 is empty string */
.................... 
.................... char *strpbrk(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1);
....................    return(0);
.................... }
.................... 
.................... 
.................... /* standard template: char *strrchr(const char *s, int c).
....................    Finds last occurrence of c in s */
.................... 
.................... char *strrchr(char *s, char c)
.................... {
....................    char *p;
.................... 
....................    for (p = 0; ; s++)
....................    {
....................       if (*s == c)
....................          p = s;
....................       if (*s == '\0')
....................          return(p);
....................    }
.................... }
.................... /* computes length of max initial segment of s1 consisting
....................    entirely of characters from s2 */
.................... 
.................... size_t strspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; ; sc2++)
....................     if (*sc2 == '\0')
....................        return(sc1 - s1);
....................          else if (*sc1 == *sc2)
....................             break;
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strstr(const char *s1, const char *s2);
....................    Locates first occurence of character sequence s2 in s1;
....................    returns 0 if s2 is empty string
.................... 
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the
....................    file to use the faster algorithm */
.................... char *strstr(char *s1, char *s2)
.................... {
....................    char *s, *t;
.................... 
....................    #ifdef FASTER_BUT_MORE_ROM
....................    if (*s2 == '\0')
....................          return(s1);
....................    #endif
.................... 
....................    while (*s1)
....................    {
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t);
.................... 
....................       if (*t == '\0')
....................          return s1;
....................       ++s1;
....................       #ifdef FASTER_BUT_MORE_ROM
....................          while(*s1 != '\0' && *s1 != *s2)
....................             ++s1;
....................       #endif
....................    }
....................    return 0;
.................... }
.................... 
.................... /* standard template: size_t strlen(const char *s).
....................    Computes length of s1 (preceding terminating 0) */
.................... 
.................... size_t strlen(char *s)
.................... {
....................    char *sc;
.................... 
....................    for (sc = s; *sc != 0; sc++);
....................    return(sc - s);
.................... }
.................... 
.................... /* standard template: char *strtok(char *s1, const char *s2).
.................... 
....................    Finds next token in s1 delimited by a character from separator
....................    string s2 (which can be different from call to call).  First call
....................    starts at beginning of s1 searching for first character NOT
....................    contained in s2; returns 0 if none is found.
....................    If one is found, it is the start of first token (return value).
....................    Function then searches from there for a character contained in s2.
....................    If none is found, current token extends to end of s1, and subsequent
....................    searches for a token will return 0.  If one is found, it is
....................    overwritten by '\0', which terminates current token.  Function saves
....................    pointer to following character from which next search will start.
....................    Each subsequent call, with 0 as first argument, starts searching
....................    from saved pointer */
.................... 
.................... char *strtok(char *s1, char *s2)
.................... {
....................    char *beg, *end;
....................    static char *save;
.................... 
....................    beg = (s1)? s1: save;
....................    beg += strspn(beg, s2);
....................    if (*beg == '\0')
....................       return(0);
....................       
....................    end = strpbrk(beg, s2);
....................    if (end != '\0')
....................    {
....................       *end = '\0';
....................       end++;
....................       save = end;
....................    }
....................    else
....................       save = beg + strlen(beg);
....................    
....................    return(beg);
.................... }
.................... 
.................... /*****************************************************************/
.................... /*Miscellaneous functions*/
.................... /* standard template
.................... maps error number in errnum to an error message string
.................... Returns: Pointer to string
.................... */
.................... #ifdef _ERRNO
.................... char * strerror(unsigned int8 errnum)
.................... {
.................... static unsigned char s[13];
.................... switch( errnum)
.................... {
.................... case 0:
....................    strcpy(s,"no errors");
....................    return s;
.................... case EDOM :
....................    strcpy(s,"domain error");
....................    return s;
.................... case ERANGE:
....................    strcpy(s,"range error");
....................    return s;
.................... }
.................... }
.................... #ENDIF
.................... 
.................... /* standard template: size_t stricmp(const char *s1, const char *s2).
....................    Compares s1 to s2 ignoring case (upper vs. lower) */
.................... 
.................... signed int stricmp(char *s1, char *s2)
.................... {
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&((char)*s1==(char)*s2+(char)32||(char)*s2==(char)*s1+(char)32));
....................     s1++, s2++)
....................     if (*s1 == '\0')
....................        return(0);
....................  return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... 
.................... /* standard template: char *strlwr(char *s).
....................    Replaces uppercase letters by lowercase;
....................    returns pointer to new string s */
.................... 
.................... char *strlwr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'A' && *p <='Z')
....................          *p += 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... /* standard template: char *strupr(char *s).
....................    Replaces lowercase letters by upercase;
....................    returns pointer to new string s */
.................... 
.................... char *strupr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'a' && *p <='z')
....................          *p -= 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... 
.................... /************************************************************/
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... div_t div(signed int numer, signed int denom)
.................... {
....................    div_t val;
....................    val.quot = numer / denom;
....................    val.rem = numer - (denom * val.quot);
....................    return (val);
.................... }
.................... 
.................... ldiv_t ldiv(signed long numer, signed long denom)
.................... {
....................    ldiv_t val;
.................... 
....................    val.quot = numer / denom;
....................    val.rem = numer - (denom * val.quot);
....................    return (val);
.................... }
.................... 
.................... #if defined(__PCD__)
.................... float32 atoe(char * s)
.................... {
....................    float32 pow10 = 1.0;
....................    float32 result = 0.0;
....................    unsigned int8 sign = 0;
....................    unsigned int8 expsign = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
....................    unsigned int8 i;
....................    float32 exp = 1.0;
....................    unsigned int8 expcnt = 0;
.................... 
....................    c = s[ptr++];
.................... 
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') {
....................       if(c == '-') {
....................          sign = 1;
....................          c = s[ptr++];
....................       }
....................       if(c == '+')
....................          c = s[ptr++];
.................... 
....................       while((c >= '0' && c <= '9')) {
....................          result = 10*result + c - '0';
....................          c = s[ptr++];
....................       }
.................... 
....................       if (c == '.') {
....................          c = s[ptr++];
....................          while((c >= '0' && c <= '9')) {
....................              pow10 = pow10*10;
....................              result += (c - '0')/pow10;
....................              c = s[ptr++];
....................          }
....................       }
.................... 
....................       // Handling the exponent
....................       if (c=='e' || c=='E') {
....................          c = s[ptr++];
.................... 
....................          if(c == '-') {
....................             expsign = 1;
....................             c = s[ptr++];
....................          }
....................          if(c == '+')
....................             c = s[ptr++];
.................... 
....................          while((c >= '0' && c <= '9')) {
....................             expcnt = 10*expcnt + c - '0';
....................             c = s[ptr++];
....................          }
.................... 
....................          for(i=0;i<expcnt;i++)
....................             exp*=10;
.................... 
....................          if(expsign==1)
....................             result/=exp;
....................          else
....................             result*=exp;
....................       }
....................    }
.................... 
....................    if (sign == 1)
....................       result = -1*result;
....................    return(result);
.................... }
.................... #endif
.................... 
.................... #if !defined(__PCD__)
.................... float atoe(char * s)
.................... {
....................    float pow10 = 1.0;
....................    float result = 0.0;
....................    unsigned int8 sign = 0;
....................    unsigned int8 expsign = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
....................    unsigned int8 i;
....................    float exp = 1.0;
....................    unsigned int8 expcnt = 0;
.................... 
....................    c = s[ptr++];
.................... 
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') {
....................       if(c == '-') {
....................          sign = 1;
....................          c = s[ptr++];
....................       }
....................       if(c == '+')
....................          c = s[ptr++];
.................... 
....................       while((c >= '0' && c <= '9')) {
....................          result = 10*result + c - '0';
....................          c = s[ptr++];
....................       }
.................... 
....................       if (c == '.') {
....................          c = s[ptr++];
....................          while((c >= '0' && c <= '9')) {
....................              pow10 = pow10*10;
....................              result += (c - '0')/pow10;
....................              c = s[ptr++];
....................          }
....................       }
.................... 
....................       // Handling the exponent
....................       if (c=='e' || c=='E') {
....................          c = s[ptr++];
.................... 
....................          if(c == '-') {
....................             expsign = 1;
....................             c = s[ptr++];
....................          }
....................          if(c == '+')
....................             c = s[ptr++];
.................... 
....................          while((c >= '0' && c <= '9')) {
....................             expcnt = 10*expcnt + c - '0';
....................             c = s[ptr++];
....................          }
.................... 
....................          for(i=0;i<expcnt;i++)
....................             exp*=10;
.................... 
....................          if(expsign==1)
....................             result/=exp;
....................          else
....................             result*=exp;
....................       }
....................    }
.................... 
....................    if (sign == 1)
....................       result = -1*result;
....................    return(result);
.................... }
.................... #endif
.................... 
.................... signed int atoi(char *s)
.................... {
....................    signed int result;
....................    unsigned int sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    // Omit all preceeding alpha characters
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
.................... 
....................       // Check for hexa number
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9')
....................          {
....................             result = 10*result + (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];
....................             c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (sign == 1 && base == 10)
....................        result = -result;
.................... 
....................    return(result);
.................... }
.................... 
.................... signed long atol(char *s)
.................... {
....................    signed long result;
....................    unsigned int sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9')
....................          {
....................             result = 10*result + (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... 
.................... /* A fast routine to multiply by 10
....................  */
.................... signed int32 mult_with10(int32 num)
.................... {
....................    return ( (num << 1) + (num << 3) );
.................... }
.................... 
.................... #if sizeof(long)==2
.................... signed int32 atoi32(char *s)
.................... {
....................    signed int32 result;
....................    int8 sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9') {
....................             result = (result << 1) + (result << 3);  // result *= 10;
....................             result += (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... #endif
.................... 
.................... #if defined(__PCD__)
.................... 
.................... signed int48 atoi48(char *s)
.................... {
....................    signed int48 result;
....................    int8 sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9') {
....................             result = (result << 1) + (result << 3);  // result *= 10;
....................             result += (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... 
.................... signed int64 atoi64(char *s)
.................... {
....................    signed int64 result;
....................    int8 sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9') {
....................             result = (result << 1) + (result << 3);  // result *= 10;
....................             result += (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... #endif
.................... 
.................... char * itoa(signed int32 num, unsigned int base, char * s)
.................... {
....................      unsigned int32 temp=1;
....................      unsigned int8 i,sign=0,cnt=0;
....................      char c;
.................... 
....................      if(num<0) {
....................          sign=1;        // Check for negative number
....................          num*=-1;
....................      }
.................... 
....................      while(temp>0) {
....................          temp=(num/base);
....................          s[cnt]=(num%base)+'0';    // Conversion
.................... 
....................          if(s[cnt]>0x39)
....................             s[cnt]+=0x7;
.................... 
....................          cnt++;
....................          num=temp;
....................      }
.................... 
....................      if(sign==1) {
....................          s[cnt]=0x2D;      // Negative sign
....................          cnt++;
....................      }
.................... 
....................      for(i = 0;i<(int8)(cnt/2);i++) {
.................... 
....................          c=s[i];
....................          s[i]=s[cnt-i-1];        // Reverse the number
....................          s[cnt-i-1]=c;
....................      }
....................      s[cnt]='\0';     // End the string
....................      return s;
.................... }
.................... 
.................... #if defined(__PCD__)
.................... 
.................... char * itoa(signed int48 num, unsigned int base, char * s)
.................... {
....................      unsigned int48 temp=1;
....................      unsigned int8 i,sign=0,cnt=0;
....................      char c;
.................... 
....................      if(num<0) {
....................          sign=1;        // Check for negative number
....................          num*=-1;
....................      }
.................... 
....................      while(temp>0) {
....................          temp=(num/base);
....................          s[cnt]=(num%base)+'0';    // Conversion
.................... 
....................          if(s[cnt]>0x39)
....................             s[cnt]+=0x7;
.................... 
....................          cnt++;
....................          num=temp;
....................      }
.................... 
....................      if(sign==1) {
....................          s[cnt]=0x2D;      // Negative sign
....................          cnt++;
....................      }
.................... 
....................      for(i = 0;i<(int8)(cnt/2);i++) {
.................... 
....................          c=s[i];
....................          s[i]=s[cnt-i-1];        // Reverse the number
....................          s[cnt-i-1]=c;
....................      }
....................      s[cnt]='\0';     // End the string
....................      return s;
.................... }
.................... 
.................... char * itoa(signed int64 num, unsigned int base, char * s)
.................... {
....................      unsigned int64 temp=1;
....................      unsigned int8 i,sign=0,cnt=0;
....................      char c;
....................      
....................      if(num<0) {
....................          sign=1;        // Check for negative number
....................          num*=-1;        
....................      }
.................... 
....................      while(temp>0) {
....................          temp=(num/base);
....................          s[cnt]=(num%base)+'0';    // Conversion
.................... 
....................          if(s[cnt]>0x39)
....................             s[cnt]+=0x7;
....................             
....................          cnt++;
....................          num=temp;
....................      }
.................... 
....................      if(sign==1) {
....................          s[cnt]=0x2D;      // Negative sign
....................          cnt++;
....................      }
.................... 
....................      for(i = 0;i<(int8)(cnt/2);i++) {
.................... 
....................          c=s[i];
....................          s[i]=s[cnt-i-1];        // Reverse the number
....................          s[cnt-i-1]=c;
....................      }
....................      s[cnt]='\0';     // End the string
....................      return s;
.................... }
.................... 
.................... #endif
.................... 
.................... float strtof(char *s, char **endptr)
.................... {
....................    float pow10 = 1.0;
....................    float result = 0.0;
....................    int1 skip = 1, sign = 0, point = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
.................... 
....................    if (!s)
....................       return 0;
.................... 
....................    for(c=s[ptr++]; c!=0; c=s[ptr++])
....................    {
....................       if (skip && !isspace(c))
....................       {
....................          skip = 0;
....................          if (c == '+')
....................          {
....................             sign = 0;
....................             continue;
....................          }            
....................          else if (c == '-')
....................          {
....................             sign = 1;
....................             continue;
....................          }
....................       }
....................       if (!skip && (c == '.') && !point)
....................          point = 1;
....................       else if (!skip && isdigit(c))
....................       {
....................          c -= '0';
....................          if (point)
....................          {
....................             pow10 = pow10 * 10.0;
....................             result += (float)c / pow10;   
....................          }
....................          else
....................          {
....................             result = 10.0 * result + (float)c;
....................          }
....................       }
....................       else if (!skip)
....................          break;
....................    }
.................... 
....................    if (sign)
....................       result = -1*result;
....................       
....................    if(endptr)
....................    {
....................       if (ptr) {
....................          ptr--;
....................        #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s+ptr; 
....................        #ELSE
....................          *((char *)endptr)=s+ptr;
....................        #ENDIF
....................       }
....................       else
....................       {
....................       #IF LONG_POINTERS
....................       *((int16 *)endptr)= s; 
....................       #ELSE
....................       *((char *)endptr)=s;
....................       #ENDIF
....................       }
....................    }
.................... 
....................    return(result);
.................... }
.................... 
.................... #if defined(__PCD__)
.................... float48 strtof48(char *s, char **endptr)
.................... {
....................    float48 pow10 = 1.0;
....................    float48 result = 0.0;
....................    int1 skip = 1, sign = 0, point = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
.................... 
....................    if (!s)
....................       return 0;
.................... 
....................    for(c=s[ptr++]; c!=0; c=s[ptr++])
....................    {
....................       if (skip && !isspace(c))
....................       {
....................          skip = 0;
....................          if (c == '+')
....................          {
....................             sign = 0;
....................             continue;
....................          }            
....................          else if (c == '-')
....................          {
....................             sign = 1;
....................             continue;
....................          }
....................       }
....................       if (!skip && (c == '.') && !point)
....................          point = 1;
....................       else if (!skip && isdigit(c))
....................       {
....................          c -= '0';
....................          if (point)
....................          {
....................             pow10 = pow10 * 10.0;
....................             result += (float48)c / pow10;   
....................          }
....................          else
....................          {
....................             result = 10.0 * result + (float48)c;
....................          }
....................       }
....................       else if (!skip)
....................          break;
....................    }
.................... 
....................    if (sign)
....................       result = -1*result;
....................       
....................    if(endptr)
....................    {
....................       if (ptr) {
....................          ptr--;
....................        #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s+ptr; 
....................        #ELSE
....................          *((char *)endptr)=s+ptr;
....................        #ENDIF
....................       }
....................       else
....................       {
....................       #IF LONG_POINTERS
....................       *((int16 *)endptr)= s; 
....................       #ELSE
....................       *((char *)endptr)=s;
....................       #ENDIF
....................       }
....................    }
.................... 
....................    return(result);
.................... }
.................... 
.................... float64 strtod(char *s, char **endptr)
.................... {
....................    float64 pow10 = 1.0;
....................    float64 result = 0.0;
....................    int1 skip = 1, sign = 0, point = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
.................... 
....................    if (!s)
....................       return 0;
.................... 
....................    for(c=s[ptr++]; c!=0; c=s[ptr++])
....................    {
....................       if (skip && !isspace(c))
....................       {
....................          skip = 0;
....................          if (c == '+')
....................          {
....................             sign = 0;
....................             continue;
....................          }            
....................          else if (c == '-')
....................          {
....................             sign = 1;
....................             continue;
....................          }
....................       }
....................       if (!skip && (c == '.') && !point)
....................          point = 1;
....................       else if (!skip && isdigit(c))
....................       {
....................          c -= '0';
....................          if (point)
....................          {
....................             pow10 = pow10 * 10.0;
....................             result += (float64)c / pow10;   
....................          }
....................          else
....................          {
....................             result = 10.0 * result + (float64)c;
....................          }
....................       }
....................       else if (!skip)
....................          break;
....................    }
.................... 
....................    if (sign)
....................       result = -1*result;
....................       
....................    if(endptr)
....................    {
....................       if (ptr) {
....................          ptr--;
....................        #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s+ptr; 
....................        #ELSE
....................          *((char *)endptr)=s+ptr;
....................        #ENDIF
....................       }
....................       else
....................       {
....................       #IF LONG_POINTERS
....................       *((int16 *)endptr)= s; 
....................       #ELSE
....................       *((char *)endptr)=s;
....................       #ENDIF
....................       }
....................    }
.................... 
....................    return(result);
.................... }
.................... #endif
.................... 
.................... #ifndef __PCB__
.................... unsigned long strtoul(char *s, char *endptr, signed int base)
.................... {
....................    char *sc,*s1,*sd;
....................    unsigned long x=0;
....................    char sign;
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz";
....................    for(sc=s;isspace(*sc);++sc);
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+';
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base
....................    goto StrtoulGO;
.................... 
....................    else if (base)
....................    {
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X'))
....................          sc+=2;
....................       if(base==8 && *sc =='0')
....................          sc+=1;
....................       if(base==2 && *sc =='0'&&sc[1]=='b')
....................          sc+=2;
.................... 
....................    }
....................    else if(*sc!='0') // base is 0, find base
....................       base=10;
....................    else if (sc[1]=='x' || sc[1]=='X')
....................       base =16,sc+=2;
....................    else if(sc[1]=='b')
....................       base=2,sc+=2;
....................    else
....................       base=8;
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes
....................    sd=memchr(digits,tolower(*sc),base);
....................    for(; sd!=0; )
....................    {
....................       x=x*base+(int16)(sd-digits);
....................       ++sc;
....................       sd=memchr(digits,tolower(*sc),base);
....................    }
....................    if(s1==sc)
....................    {
....................    StrtoulGO:
....................       if (endptr)
....................       {
....................          #IF LONG_POINTERS
....................          *((int16 *)endptr)= s; 
....................          #ELSE
....................          *((char *)endptr)=s;
....................          #ENDIF
....................          }
....................    return 0;
....................    }
....................    if (endptr)
....................    {
....................          #IF LONG_POINTERS
....................          *((int16 *)endptr)= sc; 
....................          #ELSE
....................          *((char *)endptr)=sc; 
....................          #ENDIF
....................    }
....................    return x;
.................... }
.................... 
.................... 
.................... signed long strtol(char *s,char *endptr, signed int base)
.................... {
....................    char *sc,*s1,*sd;
....................    signed long x=0;
....................    char sign;
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz";
....................    for(sc=s;isspace(*sc);++sc);
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+';
....................    if (base <0 || base ==1|| base >36) // invalid base
....................    goto StrtolGO;
....................    else if (base)
....................    {
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X'))
....................          sc+=2;
....................       if(base==8 && *sc =='0')
....................          sc+=1;
....................       if(base==2 && *sc =='0'&&sc[1]=='b')
....................          sc+=2;
.................... 
....................    }
....................    else if(*sc!='0') // base is 0, find base
....................       base=10;
....................    else if (sc[1]=='x' || sc[1]=='X')
....................       base =16,sc+=2;
....................    else if(sc[1]=='b')
....................       base=2,sc+=2;
....................    else
....................       base=8;
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes
.................... 
....................    sd=memchr(digits,tolower(*sc),base);
....................    for(;sd!=0;)
....................    {
....................       x=x*base+(int16)(sd-digits);
....................       ++sc;
....................       sd=memchr(digits,tolower(*sc),base);
....................    }
....................    if(s1==sc)
....................    {
....................    StrtolGO:
....................       if (endptr)
....................       {
....................          #IF LONG_POINTERS
....................          *((int16 *)endptr)= s; 
....................          #ELSE
....................          *((char *)endptr)=s;
....................          #ENDIF
....................       }
....................    return 0;
....................    }
....................    if(sign=='-')
....................       x  =-x;
....................    if (endptr)
....................    {
....................         #IF LONG_POINTERS
....................          *((int16 *)endptr)= sc; 
....................         #ELSE
....................         *((char *)endptr)=sc;
....................         #ENDIF
....................    }
....................    return x;
.................... }
.................... #endif
.................... 
.................... signed int8 system(char *string)
.................... {
....................    return 0;
.................... }
.................... 
.................... size_t mblen(char *s,size_t n)
.................... {
....................    return strlen(s);
.................... }
.................... 
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n)
.................... {
....................    *pwc=*s;
....................    return 1;
.................... }
.................... 
.................... int8 wctomb(char *s,wchar_t wchar)
.................... {
....................    *s=wchar;
....................    return 1;
.................... }
.................... 
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n)
.................... {
....................    strncpy((char *)pwcs,s,n);
....................    return strlen((char *)pwcs);
.................... }
.................... 
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n)
.................... {
....................    strncpy(s,(char *)pwcs,n);
....................    return strlen(s);
.................... }
.................... 
.................... //---------------------------------------------------------------------------
.................... // The random number implementation
.................... //---------------------------------------------------------------------------
.................... 
.................... unsigned int32 _Randseed;
.................... 
.................... unsigned int16 rand(void)
.................... {
....................    _Randseed = _Randseed * 1103515245 + 12345;
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX);
.................... }
.................... 
.................... void srand(unsigned int32 seed)
.................... {
....................    _Randseed = seed;
.................... }
.................... 
.................... //---------------------------------------------------------------------------
.................... // Searching and sorting utilities implementation
.................... //---------------------------------------------------------------------------
.................... 
.................... #if !defined(__PCD__)
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2); 
.................... #else 
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2); 
.................... #endif
.................... 
.................... 
.................... 
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) {
....................    unsigned int m,j,i,l;
....................    int1 done;
....................    unsigned int8 t[16];
.................... 
....................    m = qitems/2;
....................    while( m > 0 ) {
....................      for(j=0; j<(qitems-m); ++j) {
....................         i = j;
....................         do
....................         {
....................            done=1;
....................            l = i+m;
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) {
....................               memcpy(t, qdata+i*qsize, qsize);
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize);
....................               memcpy(qdata+l*qsize, t, qsize);
....................               if(m <= i)
....................                 i -= m;
....................                 done = 0;
....................            }
....................         } while(!done);
....................      }
....................      m = m/2;
....................    }
.................... }
.................... 
.................... 
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp)
.................... {
....................    char *p, *q;
....................    size_t n;
....................    size_t pivot;
....................    signed int val;
.................... 
....................    p = base;
....................    n = num;
.................... 
....................    while (n > 0)
....................    {
....................       pivot = n >> 1;
....................       q = p + width * pivot;
.................... 
....................       val = (*cmp)(key, q);
.................... 
....................       if (val < 0)
....................          n = pivot;
....................       else if (val == 0)
....................          return ((char *)q);
....................       else {
....................          p = q + width;
....................          n -= pivot + 1;
....................       }
....................    }
.................... 
....................    return NULL;      // There's no match
.................... }
.................... 
.................... 
.................... #endif
.................... 
.................... #include"dht11.h"
.................... #define DHT11_PIN PIN_C0    // connection pin between DHT11 and mcu
.................... short Time_out;
.................... 
.................... void start_signal(){
....................   output_drive(DHT11_PIN);    // configure connection pin as output
*
05FF:  BCF    20.0
0600:  MOVF   20,W
0601:  BSF    03.5
0602:  MOVWF  07
....................   output_low(DHT11_PIN);      // connection pin output low
0603:  BCF    03.5
0604:  BCF    20.0
0605:  MOVF   20,W
0606:  BSF    03.5
0607:  MOVWF  07
0608:  BCF    03.5
0609:  BCF    07.0
....................   delay_ms(25);
060A:  MOVLW  19
060B:  BSF    03.6
060C:  MOVWF  6A
060D:  BCF    03.6
060E:  CALL   10D
....................   output_high(DHT11_PIN);     // connection pin output high
060F:  BCF    20.0
0610:  MOVF   20,W
0611:  BSF    03.5
0612:  MOVWF  07
0613:  BCF    03.5
0614:  BSF    07.0
....................   delay_us(30);
0615:  MOVLW  31
0616:  MOVWF  77
0617:  DECFSZ 77,F
0618:  GOTO   617
0619:  GOTO   61A
....................   output_float(DHT11_PIN);    // configure connection pin as input
061A:  BSF    20.0
061B:  MOVF   20,W
061C:  BSF    03.5
061D:  MOVWF  07
061E:  BCF    03.5
061F:  BSF    0A.3
0620:  BSF    0A.4
0621:  GOTO   139 (RETURN)
.................... }
.................... 
.................... 
.................... short check_response(){
....................   delay_us(40);
0622:  MOVLW  42
0623:  MOVWF  77
0624:  DECFSZ 77,F
0625:  GOTO   624
0626:  NOP
....................   if(!input(DHT11_PIN)){      // read and test if connection pin is low
0627:  BSF    20.0
0628:  MOVF   20,W
0629:  BSF    03.5
062A:  MOVWF  07
062B:  BCF    03.5
062C:  BTFSC  07.0
062D:  GOTO   63F
....................     delay_us(80);
062E:  MOVLW  85
062F:  MOVWF  77
0630:  DECFSZ 77,F
0631:  GOTO   630
....................     if(input(DHT11_PIN)){     // read and test if connection pin is high
0632:  BSF    20.0
0633:  MOVF   20,W
0634:  BSF    03.5
0635:  MOVWF  07
0636:  BCF    03.5
0637:  BTFSS  07.0
0638:  GOTO   63F
....................       delay_us(50);
0639:  MOVLW  53
063A:  MOVWF  77
063B:  DECFSZ 77,F
063C:  GOTO   63B
....................       return 1;
063D:  MOVLW  01
063E:  MOVWF  78
....................     }
....................   }
063F:  BSF    0A.3
0640:  BSF    0A.4
0641:  GOTO   13E (RETURN)
.................... }
.................... unsigned int8 Read_Data(){
0642:  BSF    03.5
0643:  CLRF   55
....................   unsigned int8 i, k, _data = 0;        // k is used to count 1 bit reading duration
....................   if(Time_out)
0644:  BCF    03.5
0645:  BTFSS  21.1
0646:  GOTO   647
....................     break;
....................   for(i = 0; i < 8; i++){
0647:  BSF    03.5
0648:  CLRF   53
0649:  MOVF   53,W
064A:  SUBLW  07
064B:  BTFSS  03.0
064C:  GOTO   6AE
....................     k = 0;
064D:  CLRF   54
....................     while(!input(DHT11_PIN)){           // Wait until DHT11 pin get raised
064E:  BCF    03.5
064F:  BSF    20.0
0650:  MOVF   20,W
0651:  BSF    03.5
0652:  MOVWF  07
0653:  BCF    03.5
0654:  BTFSC  07.0
0655:  GOTO   665
....................       k++;
0656:  BSF    03.5
0657:  INCF   54,F
....................       if(k > 250){
0658:  MOVF   54,W
0659:  SUBLW  FA
065A:  BTFSC  03.0
065B:  GOTO   660
....................         Time_out = 1;
065C:  BCF    03.5
065D:  BSF    21.1
....................         break;
065E:  GOTO   665
065F:  BSF    03.5
....................       }
....................       delay_us(1);
0660:  GOTO   661
0661:  GOTO   662
0662:  NOP
0663:  GOTO   64E
0664:  BCF    03.5
....................     }
....................     delay_us(30);
0665:  MOVLW  31
0666:  MOVWF  77
0667:  DECFSZ 77,F
0668:  GOTO   667
0669:  GOTO   66A
....................     if(!input(DHT11_PIN))
066A:  BSF    20.0
066B:  MOVF   20,W
066C:  BSF    03.5
066D:  MOVWF  07
066E:  BCF    03.5
066F:  BTFSC  07.0
0670:  GOTO   684
....................       bit_clear(_data, (7 - i));        // Clear bit (7 - i)
0671:  BSF    03.5
0672:  MOVF   53,W
0673:  SUBLW  07
0674:  MOVWF  56
0675:  MOVLW  01
0676:  MOVWF  77
0677:  MOVF   56,W
0678:  MOVWF  78
0679:  BTFSC  03.2
067A:  GOTO   67F
067B:  BCF    03.0
067C:  RLF    77,F
067D:  DECFSZ 78,F
067E:  GOTO   67B
067F:  MOVF   77,W
0680:  XORLW  FF
0681:  ANDWF  55,F
0682:  GOTO   6AA
0683:  BCF    03.5
....................     else{
....................       bit_set(_data, (7 - i));          // Set bit (7 - i)
0684:  BSF    03.5
0685:  MOVF   53,W
0686:  SUBLW  07
0687:  MOVWF  56
0688:  MOVLW  01
0689:  MOVWF  77
068A:  MOVF   56,W
068B:  MOVWF  78
068C:  BTFSC  03.2
068D:  GOTO   692
068E:  BCF    03.0
068F:  RLF    77,F
0690:  DECFSZ 78,F
0691:  GOTO   68E
0692:  MOVF   77,W
0693:  IORWF  55,F
....................       while(input(DHT11_PIN)){          // Wait until DHT11 pin goes low
0694:  BCF    03.5
0695:  BSF    20.0
0696:  MOVF   20,W
0697:  BSF    03.5
0698:  MOVWF  07
0699:  BCF    03.5
069A:  BTFSS  07.0
069B:  GOTO   6AB
....................         k++;
069C:  BSF    03.5
069D:  INCF   54,F
....................         if(k > 250){
069E:  MOVF   54,W
069F:  SUBLW  FA
06A0:  BTFSC  03.0
06A1:  GOTO   6A6
....................         Time_out = 1;
06A2:  BCF    03.5
06A3:  BSF    21.1
....................         break;
06A4:  GOTO   6AB
06A5:  BSF    03.5
....................       }
....................       delay_us(1);}
06A6:  GOTO   6A7
06A7:  GOTO   6A8
06A8:  NOP
06A9:  GOTO   694
06AA:  BCF    03.5
....................     }
06AB:  BSF    03.5
06AC:  INCF   53,F
06AD:  GOTO   649
....................   }
....................   return _data;
06AE:  MOVF   55,W
06AF:  MOVWF  78
06B0:  BCF    03.5
06B1:  RETURN
....................   
....................   }
....................   
....................   
....................   
.................... 
.................... #include "BH1750.c"
.................... #include "BH1750.h"
....................  
.................... #use I2C(master, I2C1, FAST = 100000)
*
01DF:  BCF    14.7
01E0:  BCF    0C.3
01E1:  BSF    03.5
01E2:  MOVF   5C,W
01E3:  BCF    03.5
01E4:  MOVWF  13
01E5:  MOVLW  02
01E6:  BTFSC  14.7
01E7:  GOTO   1EF
01E8:  BSF    03.5
01E9:  BTFSC  14.2
01EA:  GOTO   1E9
01EB:  MOVLW  00
01EC:  BTFSC  11.6
01ED:  MOVLW  01
01EE:  BCF    03.5
01EF:  MOVWF  78
01F0:  RETURN
*
076F:  BCF    14.6
0770:  BSF    03.5
0771:  BSF    11.3
0772:  BTFSC  11.3
0773:  GOTO   772
0774:  BTFSC  77.0
0775:  BCF    11.5
0776:  BTFSS  77.0
0777:  BSF    11.5
0778:  BSF    11.4
0779:  BTFSC  11.4
077A:  GOTO   779
077B:  BCF    03.5
077C:  MOVF   13,W
077D:  MOVWF  78
077E:  RETURN
.................... 
.................... 
.................... #define   BH1750_address_w         0x46                               
.................... #define   BH1750_address_r         0x47 
....................          
.................... #define   power_down               0x00
.................... #define    power_up                  0x01
.................... #define  reset                     0x07 
.................... #define  cont_H_res_mode1        0x10 
.................... #define  cont_H_res_mode2        0x11  
.................... #define  cont_L_res_mode         0x13                                          
.................... #define  one_time_H_res_mode1     0x20 
.................... #define  one_time_H_res_mode2     0x21
.................... #define  one_time_L_res_mode     0x23                                     
....................                         
.................... 
.................... void BH1750_init();
.................... void BH1750_write(unsigned char cmd);                                           
.................... unsigned long BH1750_read_word(); 
.................... unsigned long get_lux_value(unsigned char mode, unsigned long delay_time);          
.................... 
....................                                       
....................               
.................... void BH1750_init()
.................... { 
.................... 	delay_ms(100);  
*
0204:  MOVLW  64
0205:  BSF    03.6
0206:  MOVWF  6A
0207:  BCF    03.6
0208:  CALL   10D
.................... 	BH1750_write(power_down);
0209:  BSF    03.5
020A:  CLRF   58
020B:  BCF    03.5
020C:  CALL   1F1
020D:  BSF    0A.3
020E:  BSF    0A.4
020F:  GOTO   124 (RETURN)
.................... }                  
....................               
.................... 
.................... void BH1750_write(unsigned char cmd)
.................... { 
.................... 	I2C_start();
*
01F1:  BSF    03.5
01F2:  BSF    11.0
01F3:  BTFSC  11.0
01F4:  GOTO   1F3
.................... 	I2C_write(BH1750_address_w);        
01F5:  MOVLW  46
01F6:  MOVWF  5C
01F7:  BCF    03.5
01F8:  CALL   1DF
.................... 	I2C_write(cmd);                
01F9:  BSF    03.5
01FA:  MOVF   58,W
01FB:  MOVWF  5C
01FC:  BCF    03.5
01FD:  CALL   1DF
.................... 	I2C_stop();	
01FE:  BSF    03.5
01FF:  BSF    11.2
0200:  BTFSC  11.2
0201:  GOTO   200
0202:  BCF    03.5
0203:  RETURN
.................... }
.................... 
....................               
....................                                    
.................... unsigned long BH1750_read_word()
*
078B:  BSF    03.5
078C:  CLRF   59
078D:  CLRF   58
078E:  CLRF   5A
078F:  CLRF   5B
.................... {                      
.................... 	register unsigned long value = 0; 
.................... 	unsigned char lb = 0;
.................... 	unsigned char hb = 0;
.................... 	I2C_start();
0790:  BSF    11.0
0791:  BTFSC  11.0
0792:  GOTO   791
.................... 	I2C_write(BH1750_address_r);      
0793:  MOVLW  47
0794:  MOVWF  5C
0795:  BCF    03.5
0796:  CALL   1DF
.................... 	hb = I2C_read(1);  
0797:  MOVLW  01
0798:  MOVWF  77
0799:  CALL   76F
079A:  MOVF   78,W
079B:  BSF    03.5
079C:  MOVWF  5B
.................... 	lb = I2C_read(0);
079D:  CLRF   77
079E:  BCF    03.5
079F:  CALL   76F
07A0:  MOVF   78,W
07A1:  BSF    03.5
07A2:  MOVWF  5A
.................... 	I2C_stop();                           
07A3:  BSF    11.2
07A4:  BTFSC  11.2
07A5:  GOTO   7A4
.................... 	value = make16(hb, lb);     
07A6:  MOVF   5B,W
07A7:  MOVWF  59
07A8:  MOVF   5A,W
07A9:  MOVWF  58
.................... 	return value;
07AA:  MOVF   58,W
07AB:  MOVWF  78
07AC:  MOVF   59,W
07AD:  MOVWF  79
.................... } 
.................... 
.................... 
.................... unsigned long get_lux_value(unsigned char mode, unsigned long delay_time)
*
077F:  BSF    03.5
0780:  CLRF   57
0781:  CLRF   56
.................... {
.................... 	register unsigned long lux_value = 0;  
.................... 	BH1750_write(power_up);
0782:  MOVLW  01
0783:  MOVWF  58
0784:  BCF    03.5
0785:  CALL   1F1
.................... 	BH1750_write(mode);
0786:  BSF    03.5
0787:  MOVF   53,W
0788:  MOVWF  58
0789:  BCF    03.5
078A:  CALL   1F1
.................... 	lux_value = BH1750_read_word(); 
*
07AE:  MOVF   79,W
07AF:  MOVWF  57
07B0:  MOVF   78,W
07B1:  MOVWF  56
.................... 	delay_ms(delay_time);
07B2:  MOVF   55,W
07B3:  MOVWF  58
07B4:  INCF   58,F
07B5:  DECF   58,F
07B6:  BTFSC  03.2
07B7:  GOTO   7C0
07B8:  MOVLW  FF
07B9:  BCF    03.5
07BA:  BSF    03.6
07BB:  MOVWF  6A
07BC:  BCF    03.6
07BD:  CALL   10D
07BE:  BSF    03.5
07BF:  GOTO   7B5
07C0:  MOVF   54,W
07C1:  BCF    03.5
07C2:  BSF    03.6
07C3:  MOVWF  6A
07C4:  BCF    03.6
07C5:  CALL   10D
.................... 	BH1750_write(power_down);
07C6:  BSF    03.5
07C7:  CLRF   58
07C8:  BCF    03.5
07C9:  CALL   1F1
.................... 	return lux_value;                                 
07CA:  BSF    03.5
07CB:  MOVF   56,W
07CC:  MOVWF  78
07CD:  MOVF   57,W
07CE:  MOVWF  79
07CF:  BCF    03.5
07D0:  BSF    0A.3
07D1:  BSF    0A.4
07D2:  GOTO   1E0 (RETURN)
.................... }                                
.................... 
.................... //t l nhiet do, h l do am , w la do am dat
.................... unsigned int8 t,T_byte2, h,RH_byte2, CheckSum ;
.................... unsigned int16 adc_value;
.................... unsigned int8 w; 
.................... unsigned int16 lux = 0;   //lux l cam bien anh sang
.................... 
.................... short q = 0, d = 0 ,b = 0, p = 0;
.................... 
.................... //define button
.................... #define BACK      pin_b6
.................... #define ONOFF     pin_b5
.................... #define DW        pin_b4
.................... #define RIGHT     pin_b3
.................... #define GO        pin_b2
.................... #define LEFT      pin_b1
.................... #define UP        pin_b0
....................         
.................... //define device 
.................... #define FAN     pin_a1
.................... #define LED     pin_a2
.................... #define BOMB    pin_a3
.................... #define SPRAY   pin_a4
.................... 
.................... 
.................... //WEB
....................    
.................... char *SSID="UZI";                   //your wifi
*
184D:  MOVLW  55
184E:  MOVWF  37
184F:  MOVLW  5A
1850:  MOVWF  38
1851:  MOVLW  49
1852:  MOVWF  39
1853:  CLRF   3A
1854:  CLRF   36
1855:  MOVLW  37
1856:  MOVWF  35
.................... char *PASS="QQQ123456";             //your wifi
1857:  MOVLW  51
1858:  MOVWF  3D
1859:  MOVWF  3E
185A:  MOVWF  3F
185B:  MOVLW  31
185C:  MOVWF  40
185D:  MOVLW  32
185E:  MOVWF  41
185F:  MOVLW  33
1860:  MOVWF  42
1861:  MOVLW  34
1862:  MOVWF  43
1863:  MOVLW  35
1864:  MOVWF  44
1865:  MOVLW  36
1866:  MOVWF  45
1867:  CLRF   46
1868:  CLRF   3C
1869:  MOVLW  3D
186A:  MOVWF  3B
.................... char *WEBSITE="192.168.137.1";      //your web
186B:  MOVLW  31
186C:  MOVWF  49
186D:  MOVLW  39
186E:  MOVWF  4A
186F:  MOVLW  32
1870:  MOVWF  4B
1871:  MOVLW  2E
1872:  MOVWF  4C
1873:  MOVLW  31
1874:  MOVWF  4D
1875:  MOVLW  36
1876:  MOVWF  4E
1877:  MOVLW  38
1878:  MOVWF  4F
1879:  MOVLW  2E
187A:  MOVWF  50
187B:  MOVLW  31
187C:  MOVWF  51
187D:  MOVLW  33
187E:  MOVWF  52
187F:  MOVLW  37
1880:  MOVWF  53
1881:  MOVLW  2E
1882:  MOVWF  54
1883:  MOVLW  31
1884:  MOVWF  55
1885:  CLRF   56
1886:  CLRF   48
1887:  MOVLW  49
1888:  MOVWF  47
.................... 
.................... 
.................... void ESP8266_init()
....................       {
....................        printf("AT\r\n");delay_ms(500);
*
02D6:  MOVLW  04
02D7:  BSF    03.6
02D8:  MOVWF  0D
02D9:  MOVLW  00
02DA:  MOVWF  0F
02DB:  BCF    03.6
02DC:  CALL   210
02DD:  MOVLW  02
02DE:  BSF    03.5
02DF:  MOVWF  53
02E0:  MOVLW  FA
02E1:  BCF    03.5
02E2:  BSF    03.6
02E3:  MOVWF  6A
02E4:  BCF    03.6
02E5:  CALL   10D
02E6:  BSF    03.5
02E7:  DECFSZ 53,F
02E8:  GOTO   2E0
....................        printf("ATE0\r\n");delay_ms(500);
02E9:  MOVLW  07
02EA:  BCF    03.5
02EB:  BSF    03.6
02EC:  MOVWF  0D
02ED:  MOVLW  00
02EE:  MOVWF  0F
02EF:  BCF    03.6
02F0:  CALL   210
02F1:  MOVLW  02
02F2:  BSF    03.5
02F3:  MOVWF  53
02F4:  MOVLW  FA
02F5:  BCF    03.5
02F6:  BSF    03.6
02F7:  MOVWF  6A
02F8:  BCF    03.6
02F9:  CALL   10D
02FA:  BSF    03.5
02FB:  DECFSZ 53,F
02FC:  GOTO   2F4
....................        printf("AT+CWMODE=1\r\n");delay_ms(500);
02FD:  MOVLW  0B
02FE:  BCF    03.5
02FF:  BSF    03.6
0300:  MOVWF  0D
0301:  MOVLW  00
0302:  MOVWF  0F
0303:  BCF    03.6
0304:  CALL   210
0305:  MOVLW  02
0306:  BSF    03.5
0307:  MOVWF  53
0308:  MOVLW  FA
0309:  BCF    03.5
030A:  BSF    03.6
030B:  MOVWF  6A
030C:  BCF    03.6
030D:  CALL   10D
030E:  BSF    03.5
030F:  DECFSZ 53,F
0310:  GOTO   308
....................        printf("AT+CWJAP=\"%s\",\"%s\"\r\n",SSID,PASS);delay_ms(2000); // thay mat khau va tai khoan tuong ung
0311:  MOVLW  12
0312:  BCF    03.5
0313:  BSF    03.6
0314:  MOVWF  0D
0315:  MOVLW  00
0316:  MOVWF  0F
0317:  BCF    03.0
0318:  MOVLW  0A
0319:  MOVWF  6A
031A:  BCF    03.6
031B:  CALL   262
031C:  MOVF   35,W
031D:  MOVWF  04
031E:  BCF    03.7
031F:  BTFSC  36.0
0320:  BSF    03.7
0321:  CALL   2B8
0322:  MOVLW  22
0323:  BTFSS  0C.4
0324:  GOTO   323
0325:  MOVWF  19
0326:  MOVLW  2C
0327:  BTFSS  0C.4
0328:  GOTO   327
0329:  MOVWF  19
032A:  MOVLW  22
032B:  BTFSS  0C.4
032C:  GOTO   32B
032D:  MOVWF  19
032E:  MOVF   3B,W
032F:  MOVWF  04
0330:  BCF    03.7
0331:  BTFSC  3C.0
0332:  BSF    03.7
0333:  CALL   2B8
0334:  MOVLW  22
0335:  BTFSS  0C.4
0336:  GOTO   335
0337:  MOVWF  19
0338:  MOVLW  0D
0339:  BTFSS  0C.4
033A:  GOTO   339
033B:  MOVWF  19
033C:  MOVLW  0A
033D:  BTFSS  0C.4
033E:  GOTO   33D
033F:  MOVWF  19
0340:  MOVLW  08
0341:  BSF    03.5
0342:  MOVWF  53
0343:  MOVLW  FA
0344:  BCF    03.5
0345:  BSF    03.6
0346:  MOVWF  6A
0347:  BCF    03.6
0348:  CALL   10D
0349:  BSF    03.5
034A:  DECFSZ 53,F
034B:  GOTO   343
....................        printf("AT+CIPMUX=0\r\n");delay_ms(500);
034C:  MOVLW  1D
034D:  BCF    03.5
034E:  BSF    03.6
034F:  MOVWF  0D
0350:  MOVLW  00
0351:  MOVWF  0F
0352:  BCF    03.6
0353:  CALL   210
0354:  MOVLW  02
0355:  BSF    03.5
0356:  MOVWF  53
0357:  MOVLW  FA
0358:  BCF    03.5
0359:  BSF    03.6
035A:  MOVWF  6A
035B:  BCF    03.6
035C:  CALL   10D
035D:  BSF    03.5
035E:  DECFSZ 53,F
035F:  GOTO   357
0360:  BCF    03.5
0361:  BSF    0A.3
0362:  BSF    0A.4
0363:  GOTO   12E (RETURN)
....................       }
.................... void ConnectWithWebServer(){
....................        int length; 
....................        char mang[90];
....................        sprintf(mang,"GET /fix/last.php?update&v1=%i&v2=%i&v3=%i&v4=%05lu HTTP/1.1\r\nHost: 192.168.137.1\r\n\r\n",t,h,w,lux);
*
0455:  MOVLW  01
0456:  MOVWF  58
0457:  MOVLW  10
0458:  MOVWF  57
0459:  MOVLW  24
045A:  BSF    03.6
045B:  MOVWF  0D
045C:  MOVLW  00
045D:  MOVWF  0F
045E:  BCF    03.0
045F:  MOVLW  1C
0460:  MOVWF  6A
0461:  BCF    03.6
0462:  CALL   375
0463:  MOVF   2B,W
0464:  BSF    03.6
0465:  MOVWF  6A
0466:  MOVLW  18
0467:  MOVWF  6B
0468:  BCF    03.6
0469:  CALL   3E6
046A:  MOVLW  33
046B:  BSF    03.6
046C:  MOVWF  0D
046D:  MOVLW  00
046E:  MOVWF  0F
046F:  BCF    03.0
0470:  MOVLW  04
0471:  MOVWF  6A
0472:  BCF    03.6
0473:  CALL   375
0474:  MOVF   2D,W
0475:  BSF    03.6
0476:  MOVWF  6A
0477:  MOVLW  18
0478:  MOVWF  6B
0479:  BCF    03.6
047A:  CALL   3E6
047B:  MOVLW  36
047C:  BSF    03.6
047D:  MOVWF  0D
047E:  MOVLW  00
047F:  MOVWF  0F
0480:  BCF    03.0
0481:  MOVLW  04
0482:  MOVWF  6A
0483:  BCF    03.6
0484:  CALL   375
0485:  MOVF   32,W
0486:  BSF    03.6
0487:  MOVWF  6A
0488:  MOVLW  18
0489:  MOVWF  6B
048A:  BCF    03.6
048B:  CALL   3E6
048C:  MOVLW  39
048D:  BSF    03.6
048E:  MOVWF  0D
048F:  MOVLW  00
0490:  MOVWF  0F
0491:  BCF    03.0
0492:  MOVLW  04
0493:  MOVWF  6A
0494:  BCF    03.6
0495:  CALL   375
0496:  MOVLW  08
0497:  MOVWF  04
0498:  MOVF   34,W
0499:  BSF    03.6
049A:  MOVWF  6B
049B:  BCF    03.6
049C:  MOVF   33,W
049D:  BSF    03.6
049E:  MOVWF  6A
*
0510:  MOVLW  3D
0511:  BCF    03.5
0512:  MOVWF  0D
0513:  MOVLW  00
0514:  MOVWF  0F
0515:  BSF    03.0
0516:  MOVLW  22
0517:  MOVWF  6A
0518:  BCF    03.6
0519:  CALL   375
....................        printf("AT+CIPSTART=\"TCP\",\"%s\",80\r\n",WEBSITE);delay_ms(150);  //wait connect
051A:  MOVLW  4F
051B:  BSF    03.6
051C:  MOVWF  0D
051D:  MOVLW  00
051E:  MOVWF  0F
051F:  BCF    03.0
0520:  MOVLW  13
0521:  MOVWF  6A
0522:  BCF    03.6
0523:  CALL   262
0524:  MOVF   47,W
0525:  MOVWF  04
0526:  BCF    03.7
0527:  BTFSC  48.0
0528:  BSF    03.7
0529:  CALL   2B8
052A:  MOVLW  59
052B:  BSF    03.6
052C:  MOVWF  0D
052D:  MOVLW  00
052E:  MOVWF  0F
052F:  BSF    03.0
0530:  MOVLW  06
0531:  MOVWF  6A
0532:  BCF    03.6
0533:  CALL   262
0534:  MOVLW  96
0535:  BSF    03.6
0536:  MOVWF  6A
0537:  BCF    03.6
0538:  CALL   10D
....................        length=strlen(mang);
0539:  MOVLW  01
053A:  BSF    03.6
053B:  MOVWF  6B
053C:  MOVLW  10
053D:  MOVWF  6A
*
055B:  MOVF   78,W
055C:  BSF    03.5
055D:  BCF    03.6
055E:  MOVWF  53
....................        printf("AT+CIPSEND=%i\r\n",length);delay_ms(150);
055F:  MOVLW  5D
0560:  BCF    03.5
0561:  BSF    03.6
0562:  MOVWF  0D
0563:  MOVLW  00
0564:  MOVWF  0F
0565:  BCF    03.0
0566:  MOVLW  0B
0567:  MOVWF  6A
0568:  BCF    03.6
0569:  CALL   262
056A:  BSF    03.5
056B:  MOVF   53,W
056C:  BCF    03.5
056D:  BSF    03.6
056E:  MOVWF  6A
056F:  MOVLW  18
0570:  MOVWF  6B
*
05DA:  MOVLW  0D
05DB:  BTFSS  0C.4
05DC:  GOTO   5DB
05DD:  MOVWF  19
05DE:  MOVLW  0A
05DF:  BTFSS  0C.4
05E0:  GOTO   5DF
05E1:  MOVWF  19
05E2:  MOVLW  96
05E3:  BSF    03.6
05E4:  MOVWF  6A
05E5:  BCF    03.6
05E6:  CALL   10D
....................        printf(mang);delay_ms(150);
05E7:  MOVLW  10
05E8:  MOVWF  04
05E9:  BSF    03.7
05EA:  CALL   2B8
05EB:  MOVLW  96
05EC:  BSF    03.6
05ED:  MOVWF  6A
05EE:  BCF    03.6
05EF:  CALL   10D
....................        printf("AT+CIPCLOSE\r\n");delay_ms(150);
05F0:  MOVLW  65
05F1:  BSF    03.6
05F2:  MOVWF  0D
05F3:  MOVLW  00
05F4:  MOVWF  0F
05F5:  BCF    03.6
05F6:  CALL   210
05F7:  MOVLW  96
05F8:  BSF    03.6
05F9:  MOVWF  6A
05FA:  BCF    03.6
05FB:  CALL   10D
05FC:  BSF    0A.3
05FD:  BSF    0A.4
05FE:  GOTO   133 (RETURN)
....................       }
.................... 
.................... //WEB
....................  
.................... 
.................... 
.................... //DS1307
....................    
.................... short button_state;
.................... char time[] = "TIME:     :  :  ";
*
1889:  MOVLW  54
188A:  MOVWF  59
188B:  MOVLW  49
188C:  MOVWF  5A
188D:  MOVLW  4D
188E:  MOVWF  5B
188F:  MOVLW  45
1890:  MOVWF  5C
1891:  MOVLW  3A
1892:  MOVWF  5D
1893:  MOVLW  20
1894:  MOVWF  5E
1895:  MOVWF  5F
1896:  MOVWF  60
1897:  MOVWF  61
1898:  MOVWF  62
1899:  MOVLW  3A
189A:  MOVWF  63
189B:  MOVLW  20
189C:  MOVWF  64
189D:  MOVWF  65
189E:  MOVLW  3A
189F:  MOVWF  66
18A0:  MOVLW  20
18A1:  MOVWF  67
18A2:  MOVWF  68
18A3:  CLRF   69
.................... char calendar[] = "  /  /20  ";
18A4:  MOVWF  6A
18A5:  MOVWF  6B
18A6:  MOVLW  2F
18A7:  MOVWF  6C
18A8:  MOVLW  20
18A9:  MOVWF  6D
18AA:  MOVWF  6E
18AB:  MOVLW  2F
18AC:  MOVWF  6F
18AD:  MOVLW  32
18AE:  MOVWF  70
18AF:  MOVLW  30
18B0:  MOVWF  71
18B1:  MOVLW  20
18B2:  MOVWF  72
18B3:  MOVWF  73
18B4:  CLRF   74
.................... char alarm1[] = "P_ON  : 00:00:00";
18B5:  MOVLW  50
18B6:  BSF    03.5
18B7:  MOVWF  20
18B8:  MOVLW  5F
18B9:  MOVWF  21
18BA:  MOVLW  4F
18BB:  MOVWF  22
18BC:  MOVLW  4E
18BD:  MOVWF  23
18BE:  MOVLW  20
18BF:  MOVWF  24
18C0:  MOVWF  25
18C1:  MOVLW  3A
18C2:  MOVWF  26
18C3:  MOVLW  20
18C4:  MOVWF  27
18C5:  MOVLW  30
18C6:  MOVWF  28
18C7:  MOVWF  29
18C8:  MOVLW  3A
18C9:  MOVWF  2A
18CA:  MOVLW  30
18CB:  MOVWF  2B
18CC:  MOVWF  2C
18CD:  MOVLW  3A
18CE:  MOVWF  2D
18CF:  MOVLW  30
18D0:  MOVWF  2E
18D1:  MOVWF  2F
18D2:  CLRF   30
.................... char alarm2[] = "P_OFF : 00:00:00";
18D3:  MOVLW  50
18D4:  MOVWF  31
18D5:  MOVLW  5F
18D6:  MOVWF  32
18D7:  MOVLW  4F
18D8:  MOVWF  33
18D9:  MOVLW  46
18DA:  MOVWF  34
18DB:  MOVWF  35
18DC:  MOVLW  20
18DD:  MOVWF  36
18DE:  MOVLW  3A
18DF:  MOVWF  37
18E0:  MOVLW  20
18E1:  MOVWF  38
18E2:  MOVLW  30
18E3:  MOVWF  39
18E4:  MOVWF  3A
18E5:  MOVLW  3A
18E6:  MOVWF  3B
18E7:  MOVLW  30
18E8:  MOVWF  3C
18E9:  MOVWF  3D
18EA:  MOVLW  3A
18EB:  MOVWF  3E
18EC:  MOVLW  30
18ED:  MOVWF  3F
18EE:  MOVWF  40
18EF:  CLRF   41
.................... unsigned int8 second, second10, minute, minute10,
....................                hour, hour10, date, date10, month, month10,
....................                year, year10, day, alarm1_minute=0, alarm1_hour=0,
....................                alarm2_minute=0, alarm2_hour=0, i, j;
.................... void ds1307_display(){
....................   second10  =  (second & 0x70) >> 4;
*
1299:  MOVF   75,W
129A:  ANDLW  70
129B:  MOVWF  77
129C:  SWAPF  77,W
129D:  MOVWF  76
129E:  MOVLW  0F
129F:  ANDWF  76,F
....................   second = second & 0x0F;
12A0:  ANDWF  75,F
....................   minute10  =  (minute & 0x70) >> 4;
12A1:  MOVF   7B,W
12A2:  ANDLW  70
12A3:  MOVWF  77
12A4:  SWAPF  77,W
12A5:  MOVWF  7C
12A6:  MOVLW  0F
12A7:  ANDWF  7C,F
....................   minute = minute & 0x0F;
12A8:  ANDWF  7B,F
....................   hour10  =  (hour & 0x30) >> 4;
12A9:  MOVF   7D,W
12AA:  ANDLW  30
12AB:  MOVWF  77
12AC:  SWAPF  77,W
12AD:  MOVWF  7E
12AE:  MOVLW  0F
12AF:  ANDWF  7E,F
....................   hour = hour & 0x0F;
12B0:  ANDWF  7D,F
....................   date10  =  (date & 0x30) >> 4;
12B1:  BSF    03.5
12B2:  MOVF   42,W
12B3:  ANDLW  30
12B4:  MOVWF  77
12B5:  SWAPF  77,W
12B6:  MOVWF  43
12B7:  MOVLW  0F
12B8:  ANDWF  43,F
....................   date = date & 0x0F;
12B9:  ANDWF  42,F
....................   month10  =  (month & 0x10) >> 4;
12BA:  MOVF   44,W
12BB:  ANDLW  10
12BC:  MOVWF  77
12BD:  SWAPF  77,W
12BE:  MOVWF  45
12BF:  MOVLW  0F
12C0:  ANDWF  45,F
....................   month = month & 0x0F;
12C1:  ANDWF  44,F
....................   year10  =  (year & 0xF0) >> 4;
12C2:  MOVF   46,W
12C3:  ANDLW  F0
12C4:  MOVWF  77
12C5:  SWAPF  77,W
12C6:  MOVWF  47
12C7:  MOVLW  0F
12C8:  ANDWF  47,F
....................   year = year & 0x0F;
12C9:  ANDWF  46,F
....................   time[15]  = second  + 48;
12CA:  MOVLW  30
12CB:  ADDWF  75,W
12CC:  BCF    03.5
12CD:  MOVWF  68
....................   time[14]  = second10  + 48;
12CE:  MOVLW  30
12CF:  ADDWF  76,W
12D0:  MOVWF  67
....................   time[12]  = minute  + 48;
12D1:  MOVLW  30
12D2:  ADDWF  7B,W
12D3:  MOVWF  65
....................   time[11]  = minute10  + 48;
12D4:  MOVLW  30
12D5:  ADDWF  7C,W
12D6:  MOVWF  64
....................   time[9]  = hour  + 48;
12D7:  MOVLW  30
12D8:  ADDWF  7D,W
12D9:  MOVWF  62
....................   time[8]  = hour10  + 48;
12DA:  MOVLW  30
12DB:  ADDWF  7E,W
12DC:  MOVWF  61
....................   calendar[9]  = year  + 48;
12DD:  MOVLW  30
12DE:  BSF    03.5
12DF:  ADDWF  46,W
12E0:  MOVWF  73
....................   calendar[8]  = year10  + 48;
12E1:  MOVLW  30
12E2:  ADDWF  47,W
12E3:  MOVWF  72
....................   calendar[4]  = month + 48;
12E4:  MOVLW  30
12E5:  ADDWF  44,W
12E6:  BCF    03.5
12E7:  MOVWF  6E
....................   calendar[3]  = month10 + 48;
12E8:  MOVLW  30
12E9:  BSF    03.5
12EA:  ADDWF  45,W
12EB:  BCF    03.5
12EC:  MOVWF  6D
....................   calendar[1]  = date + 48;
12ED:  MOVLW  30
12EE:  BSF    03.5
12EF:  ADDWF  42,W
12F0:  BCF    03.5
12F1:  MOVWF  6B
....................   calendar[0]  = date10 + 48;
12F2:  MOVLW  30
12F3:  BSF    03.5
12F4:  ADDWF  43,W
12F5:  BCF    03.5
12F6:  MOVWF  6A
....................   lcd_goto(1, 1);                              // Go to column 1 row 1
12F7:  MOVLW  01
12F8:  BSF    03.5
12F9:  MOVWF  56
12FA:  MOVWF  57
12FB:  BCF    0A.4
12FC:  BSF    0A.3
12FD:  BCF    03.5
12FE:  CALL   248
12FF:  BSF    0A.4
1300:  BCF    0A.3
....................   printf(lcd_out, time);                        // Display time
1301:  MOVLW  59
1302:  MOVWF  04
1303:  BCF    03.7
1304:  CALL   27A
....................   lcd_goto(1, 2);                              // Go to column 1 row 2
1305:  MOVLW  01
1306:  BSF    03.5
1307:  MOVWF  56
1308:  MOVLW  02
1309:  MOVWF  57
130A:  BCF    0A.4
130B:  BSF    0A.3
130C:  BCF    03.5
130D:  CALL   248
130E:  BSF    0A.4
130F:  BCF    0A.3
....................   switch(day){
1310:  MOVLW  01
1311:  BSF    03.5
1312:  SUBWF  48,W
1313:  ADDLW  F9
1314:  BTFSC  03.0
1315:  GOTO   375
1316:  ADDLW  07
1317:  BCF    03.5
1318:  GOTO   384
....................     case 1: lcd_out("DATE:Su"); break;
1319:  MOVLW  6C
131A:  BSF    03.6
131B:  MOVWF  0D
131C:  MOVLW  00
131D:  MOVWF  0F
131E:  BCF    0A.4
131F:  BSF    0A.3
1320:  BCF    03.6
1321:  CALL   281
1322:  BSF    0A.4
1323:  BCF    0A.3
1324:  BSF    03.5
1325:  GOTO   375
....................     case 2: lcd_out("DATE:Mo"); break;
1326:  MOVLW  70
1327:  BSF    03.6
1328:  MOVWF  0D
1329:  MOVLW  00
132A:  MOVWF  0F
132B:  BCF    0A.4
132C:  BSF    0A.3
132D:  BCF    03.6
132E:  CALL   281
132F:  BSF    0A.4
1330:  BCF    0A.3
1331:  BSF    03.5
1332:  GOTO   375
....................     case 3: lcd_out("DATE:Tu"); break;
1333:  MOVLW  74
1334:  BSF    03.6
1335:  MOVWF  0D
1336:  MOVLW  00
1337:  MOVWF  0F
1338:  BCF    0A.4
1339:  BSF    0A.3
133A:  BCF    03.6
133B:  CALL   281
133C:  BSF    0A.4
133D:  BCF    0A.3
133E:  BSF    03.5
133F:  GOTO   375
....................     case 4: lcd_out("DATE:We"); break;
1340:  MOVLW  78
1341:  BSF    03.6
1342:  MOVWF  0D
1343:  MOVLW  00
1344:  MOVWF  0F
1345:  BCF    0A.4
1346:  BSF    0A.3
1347:  BCF    03.6
1348:  CALL   281
1349:  BSF    0A.4
134A:  BCF    0A.3
134B:  BSF    03.5
134C:  GOTO   375
....................     case 5: lcd_out("DATE:Th"); break;
134D:  MOVLW  7C
134E:  BSF    03.6
134F:  MOVWF  0D
1350:  MOVLW  00
1351:  MOVWF  0F
1352:  BCF    0A.4
1353:  BSF    0A.3
1354:  BCF    03.6
1355:  CALL   281
1356:  BSF    0A.4
1357:  BCF    0A.3
1358:  BSF    03.5
1359:  GOTO   375
....................     case 6: lcd_out("DATE:Fr"); break;
135A:  MOVLW  80
135B:  BSF    03.6
135C:  MOVWF  0D
135D:  MOVLW  00
135E:  MOVWF  0F
135F:  BCF    0A.4
1360:  BSF    0A.3
1361:  BCF    03.6
1362:  CALL   281
1363:  BSF    0A.4
1364:  BCF    0A.3
1365:  BSF    03.5
1366:  GOTO   375
....................     case 7: lcd_out("DATE:Sa"); break;}
1367:  MOVLW  84
1368:  BSF    03.6
1369:  MOVWF  0D
136A:  MOVLW  00
136B:  MOVWF  0F
136C:  BCF    0A.4
136D:  BSF    0A.3
136E:  BCF    03.6
136F:  CALL   281
1370:  BSF    0A.4
1371:  BCF    0A.3
1372:  BSF    03.5
1373:  GOTO   375
1374:  BSF    03.5
....................   lcd_goto(9, 2);                              // Go to column 9 row 2
1375:  MOVLW  09
1376:  MOVWF  56
1377:  MOVLW  02
1378:  MOVWF  57
1379:  BCF    0A.4
137A:  BSF    0A.3
137B:  BCF    03.5
137C:  CALL   248
137D:  BSF    0A.4
137E:  BCF    0A.3
....................   printf(lcd_out, calendar);                    // Display calendar
137F:  MOVLW  6A
1380:  MOVWF  04
1381:  BCF    03.7
1382:  CALL   27A
1383:  RETURN
.................... }
.................... 
.................... void alarm_display(){                            // Display alarms info
....................   alarm1[12]  = alarm1_minute % 10  + 48;
*
1554:  BSF    03.5
1555:  MOVF   49,W
1556:  BSF    03.6
1557:  MOVWF  10
1558:  MOVLW  0A
1559:  MOVWF  11
155A:  BCF    0A.4
155B:  BCF    03.5
155C:  BCF    03.6
155D:  CALL   3CD
155E:  BSF    0A.4
155F:  MOVLW  30
1560:  ADDWF  77,W
1561:  BSF    03.5
1562:  MOVWF  2C
....................   alarm1[11]  = alarm1_minute/10 + 48;
1563:  MOVF   49,W
1564:  BSF    03.6
1565:  MOVWF  10
1566:  MOVLW  0A
1567:  MOVWF  11
1568:  BCF    0A.4
1569:  BCF    03.5
156A:  BCF    03.6
156B:  CALL   3CD
156C:  BSF    0A.4
156D:  MOVLW  30
156E:  ADDWF  78,W
156F:  BSF    03.5
1570:  MOVWF  2B
....................   alarm1[9]  = alarm1_hour%10  + 48;
1571:  MOVF   4A,W
1572:  BSF    03.6
1573:  MOVWF  10
1574:  MOVLW  0A
1575:  MOVWF  11
1576:  BCF    0A.4
1577:  BCF    03.5
1578:  BCF    03.6
1579:  CALL   3CD
157A:  BSF    0A.4
157B:  MOVLW  30
157C:  ADDWF  77,W
157D:  BSF    03.5
157E:  MOVWF  29
....................   alarm1[8]  = alarm1_hour/10  + 48;
157F:  MOVF   4A,W
1580:  BSF    03.6
1581:  MOVWF  10
1582:  MOVLW  0A
1583:  MOVWF  11
1584:  BCF    0A.4
1585:  BCF    03.5
1586:  BCF    03.6
1587:  CALL   3CD
1588:  BSF    0A.4
1589:  MOVLW  30
158A:  ADDWF  78,W
158B:  BSF    03.5
158C:  MOVWF  28
....................   lcd_goto(21, 1);                             // Go to column 1 row 3
158D:  MOVLW  15
158E:  MOVWF  56
158F:  MOVLW  01
1590:  MOVWF  57
1591:  BCF    0A.4
1592:  BSF    0A.3
1593:  BCF    03.5
1594:  CALL   248
1595:  BSF    0A.4
1596:  BCF    0A.3
....................   printf(lcd_out, alarm1);
1597:  MOVLW  A0
1598:  MOVWF  04
1599:  BCF    03.7
159A:  CALL   27A
....................   lcd_goto(38, 1);
159B:  MOVLW  26
159C:  BSF    03.5
159D:  MOVWF  56
159E:  MOVLW  01
159F:  MOVWF  57
15A0:  BCF    0A.4
15A1:  BSF    0A.3
15A2:  BCF    03.5
15A3:  CALL   248
15A4:  BSF    0A.4
15A5:  BCF    0A.3
....................   
....................   alarm2[12]  = alarm2_minute % 10  + 48;
15A6:  BSF    03.5
15A7:  MOVF   4B,W
15A8:  BSF    03.6
15A9:  MOVWF  10
15AA:  MOVLW  0A
15AB:  MOVWF  11
15AC:  BCF    0A.4
15AD:  BCF    03.5
15AE:  BCF    03.6
15AF:  CALL   3CD
15B0:  BSF    0A.4
15B1:  MOVLW  30
15B2:  ADDWF  77,W
15B3:  BSF    03.5
15B4:  MOVWF  3D
....................   alarm2[11]  = alarm2_minute/10 + 48;
15B5:  MOVF   4B,W
15B6:  BSF    03.6
15B7:  MOVWF  10
15B8:  MOVLW  0A
15B9:  MOVWF  11
15BA:  BCF    0A.4
15BB:  BCF    03.5
15BC:  BCF    03.6
15BD:  CALL   3CD
15BE:  BSF    0A.4
15BF:  MOVLW  30
15C0:  ADDWF  78,W
15C1:  BSF    03.5
15C2:  MOVWF  3C
....................   alarm2[9]  = alarm2_hour%10  + 48;
15C3:  MOVF   4C,W
15C4:  BSF    03.6
15C5:  MOVWF  10
15C6:  MOVLW  0A
15C7:  MOVWF  11
15C8:  BCF    0A.4
15C9:  BCF    03.5
15CA:  BCF    03.6
15CB:  CALL   3CD
15CC:  BSF    0A.4
15CD:  MOVLW  30
15CE:  ADDWF  77,W
15CF:  BSF    03.5
15D0:  MOVWF  3A
....................   alarm2[8]  = alarm2_hour/10  + 48;
15D1:  MOVF   4C,W
15D2:  BSF    03.6
15D3:  MOVWF  10
15D4:  MOVLW  0A
15D5:  MOVWF  11
15D6:  BCF    0A.4
15D7:  BCF    03.5
15D8:  BCF    03.6
15D9:  CALL   3CD
15DA:  BSF    0A.4
15DB:  MOVLW  30
15DC:  ADDWF  78,W
15DD:  BSF    03.5
15DE:  MOVWF  39
....................   lcd_goto(21, 2);                             // Go to column 1 row 4
15DF:  MOVLW  15
15E0:  MOVWF  56
15E1:  MOVLW  02
15E2:  MOVWF  57
15E3:  BCF    0A.4
15E4:  BSF    0A.3
15E5:  BCF    03.5
15E6:  CALL   248
15E7:  BSF    0A.4
15E8:  BCF    0A.3
....................   printf(lcd_out, alarm2);
15E9:  MOVLW  B1
15EA:  MOVWF  04
15EB:  BCF    03.7
15EC:  CALL   27A
....................   lcd_goto(38, 2);
15ED:  MOVLW  26
15EE:  BSF    03.5
15EF:  MOVWF  56
15F0:  MOVLW  02
15F1:  MOVWF  57
15F2:  BCF    0A.4
15F3:  BSF    0A.3
15F4:  BCF    03.5
15F5:  CALL   248
15F6:  BSF    0A.4
15F7:  BCF    0A.3
....................    
.................... }
.................... 
.................... void ds1307_write(unsigned int8 address, data_){
....................   i2c_start();                                   // Start I2C
*
1747:  BSF    03.5
1748:  BSF    11.0
1749:  BTFSC  11.0
174A:  GOTO   749
....................   i2c_write(0xD0);                               // DS1307 address
174B:  MOVLW  D0
174C:  MOVWF  5C
174D:  BCF    0A.4
174E:  BCF    03.5
174F:  CALL   1DF
1750:  BSF    0A.4
....................   i2c_write(address);                            // Send register address
1751:  BSF    03.5
1752:  MOVF   53,W
1753:  MOVWF  5C
1754:  BCF    0A.4
1755:  BCF    03.5
1756:  CALL   1DF
1757:  BSF    0A.4
....................   i2c_write(data_);                              // Write data to the selected register
1758:  BSF    03.5
1759:  MOVF   54,W
175A:  MOVWF  5C
175B:  BCF    0A.4
175C:  BCF    03.5
175D:  CALL   1DF
175E:  BSF    0A.4
....................   i2c_stop();                                    // Stop I2C
175F:  BSF    03.5
1760:  BSF    11.2
1761:  BTFSC  11.2
1762:  GOTO   761
1763:  BCF    03.5
1764:  RETURN
.................... }
.................... 
.................... 
.................... void ds1307_read(){
....................    i2c_start();                                  // Start I2C
*
11FD:  BSF    03.5
11FE:  BSF    11.0
11FF:  BTFSC  11.0
1200:  GOTO   1FF
....................    i2c_write(0xD0);                              // DS1307 address
1201:  MOVLW  D0
1202:  MOVWF  5C
1203:  BCF    0A.4
1204:  BCF    03.5
1205:  CALL   1DF
1206:  BSF    0A.4
....................    i2c_write(0);                                 // Send register address
1207:  BSF    03.5
1208:  CLRF   5C
1209:  BCF    0A.4
120A:  BCF    03.5
120B:  CALL   1DF
120C:  BSF    0A.4
....................    i2c_start();                                  // Restart I2C
120D:  BSF    03.5
120E:  BSF    11.1
120F:  BTFSC  11.1
1210:  GOTO   20F
....................    i2c_write(0xD1);                              // Initialize data read
1211:  MOVLW  D1
1212:  MOVWF  5C
1213:  BCF    0A.4
1214:  BCF    03.5
1215:  CALL   1DF
1216:  BSF    0A.4
....................    second =i2c_read(1);                          // Read seconds from register 0
1217:  MOVLW  01
1218:  MOVWF  77
1219:  BCF    0A.4
121A:  CALL   76F
121B:  BSF    0A.4
121C:  MOVF   78,W
121D:  MOVWF  75
....................    minute =i2c_read(1);                          // Read minuts from register 1
121E:  MOVLW  01
121F:  MOVWF  77
1220:  BCF    0A.4
1221:  CALL   76F
1222:  BSF    0A.4
1223:  MOVF   78,W
1224:  MOVWF  7B
....................    hour = i2c_read(1);                           // Read hour from register 2
1225:  MOVLW  01
1226:  MOVWF  77
1227:  BCF    0A.4
1228:  CALL   76F
1229:  BSF    0A.4
122A:  MOVF   78,W
122B:  MOVWF  7D
....................    day = i2c_read(1);                            // Read day from register 3
122C:  MOVLW  01
122D:  MOVWF  77
122E:  BCF    0A.4
122F:  CALL   76F
1230:  BSF    0A.4
1231:  MOVF   78,W
1232:  BSF    03.5
1233:  MOVWF  48
....................    date = i2c_read(1);                           // Read date from register 4
1234:  MOVLW  01
1235:  MOVWF  77
1236:  BCF    0A.4
1237:  BCF    03.5
1238:  CALL   76F
1239:  BSF    0A.4
123A:  MOVF   78,W
123B:  BSF    03.5
123C:  MOVWF  42
....................    month = i2c_read(1);                          // Read month from register 5
123D:  MOVLW  01
123E:  MOVWF  77
123F:  BCF    0A.4
1240:  BCF    03.5
1241:  CALL   76F
1242:  BSF    0A.4
1243:  MOVF   78,W
1244:  BSF    03.5
1245:  MOVWF  44
....................    year = i2c_read(0);                           // Read year from register 6
1246:  CLRF   77
1247:  BCF    0A.4
1248:  BCF    03.5
1249:  CALL   76F
124A:  BSF    0A.4
124B:  MOVF   78,W
124C:  BSF    03.5
124D:  MOVWF  46
....................    i2c_stop();                                   // Stop I2C
124E:  BSF    11.2
124F:  BTFSC  11.2
1250:  GOTO   24F
1251:  BCF    03.5
1252:  RETURN
.................... }
.................... 
.................... void alarm_check(){
....................  if((alarm1_minute == ((minute & 0x0F) + (minute >> 4) * 10)) &&
....................  (alarm1_hour == ((hour & 0x0F) + (hour >> 4) * 10)) && (second == 0))
*
14F3:  MOVF   7B,W
14F4:  ANDLW  0F
14F5:  BSF    03.5
14F6:  MOVWF  55
14F7:  SWAPF  7B,W
14F8:  MOVWF  77
14F9:  MOVLW  0F
14FA:  ANDWF  77,F
14FB:  MOVF   77,W
14FC:  MOVWF  57
14FD:  MOVWF  58
14FE:  MOVLW  0A
14FF:  MOVWF  59
1500:  BCF    03.5
1501:  CALL   253
1502:  MOVF   78,W
1503:  BSF    03.5
1504:  ADDWF  55,W
1505:  SUBWF  49,W
1506:  BTFSS  03.2
1507:  GOTO   523
1508:  MOVF   7D,W
1509:  ANDLW  0F
150A:  MOVWF  55
150B:  SWAPF  7D,W
150C:  MOVWF  77
150D:  MOVLW  0F
150E:  ANDWF  77,F
150F:  MOVF   77,W
1510:  MOVWF  57
1511:  MOVWF  58
1512:  MOVLW  0A
1513:  MOVWF  59
1514:  BCF    03.5
1515:  CALL   253
1516:  MOVF   78,W
1517:  BSF    03.5
1518:  ADDWF  55,W
1519:  SUBWF  4A,W
151A:  BTFSS  03.2
151B:  GOTO   523
151C:  MOVF   75,F
151D:  BTFSS  03.2
151E:  GOTO   523
....................    output_high(SPRAY);                          // Alarm1 ON
151F:  BCF    05.4
1520:  BCF    03.5
1521:  BSF    05.4
1522:  BSF    03.5
....................  if((alarm2_minute == ((minute & 0x0F) + (minute >> 4) * 10)) &&
....................  (alarm2_hour == ((hour & 0x0F) + (hour >> 4) * 10)) && (second == 0))
1523:  MOVF   7B,W
1524:  ANDLW  0F
1525:  MOVWF  55
1526:  SWAPF  7B,W
1527:  MOVWF  77
1528:  MOVLW  0F
1529:  ANDWF  77,F
152A:  MOVF   77,W
152B:  MOVWF  57
152C:  MOVWF  58
152D:  MOVLW  0A
152E:  MOVWF  59
152F:  BCF    03.5
1530:  CALL   253
1531:  MOVF   78,W
1532:  BSF    03.5
1533:  ADDWF  55,W
1534:  SUBWF  4B,W
1535:  BTFSS  03.2
1536:  GOTO   552
1537:  MOVF   7D,W
1538:  ANDLW  0F
1539:  MOVWF  55
153A:  SWAPF  7D,W
153B:  MOVWF  77
153C:  MOVLW  0F
153D:  ANDWF  77,F
153E:  MOVF   77,W
153F:  MOVWF  57
1540:  MOVWF  58
1541:  MOVLW  0A
1542:  MOVWF  59
1543:  BCF    03.5
1544:  CALL   253
1545:  MOVF   78,W
1546:  BSF    03.5
1547:  ADDWF  55,W
1548:  SUBWF  4C,W
1549:  BTFSS  03.2
154A:  GOTO   552
154B:  MOVF   75,F
154C:  BTFSS  03.2
154D:  GOTO   552
....................    output_low(SPRAY);                           // Alarm1 OFF
154E:  BCF    05.4
154F:  BCF    03.5
1550:  BCF    05.4
1551:  BSF    03.5
.................... }
.................... 
.................... 
.................... int8 edit(int8 parameter, int8 xx, int8 yy){
....................   while(TRUE){
....................     if(input(LEFT) && input(RIGHT)) button_state = 0;
*
1604:  BSF    03.5
1605:  BSF    06.1
1606:  BCF    03.5
1607:  BTFSS  06.1
1608:  GOTO   60E
1609:  BSF    03.5
160A:  BSF    06.3
160B:  BCF    03.5
160C:  BTFSC  06.3
160D:  BCF    21.6
....................     while(!input(UP)){
160E:  BSF    03.5
160F:  BSF    06.0
1610:  BCF    03.5
1611:  BTFSC  06.0
1612:  GOTO   673
....................       parameter++;
1613:  BSF    03.5
1614:  INCF   53,F
....................       if(((i == 1) || (i == 6)) && parameter > 23)
1615:  DECFSZ 4D,W
1616:  GOTO   618
1617:  GOTO   61C
1618:  MOVF   4D,W
1619:  SUBLW  06
161A:  BTFSS  03.2
161B:  GOTO   620
161C:  MOVF   53,W
161D:  SUBLW  17
161E:  BTFSS  03.0
....................         parameter = 0;
161F:  CLRF   53
....................       if(((i == 2) || (i == 7)) && parameter > 59)
1620:  MOVF   4D,W
1621:  SUBLW  02
1622:  BTFSC  03.2
1623:  GOTO   628
1624:  MOVF   4D,W
1625:  SUBLW  07
1626:  BTFSS  03.2
1627:  GOTO   62C
1628:  MOVF   53,W
1629:  SUBLW  3B
162A:  BTFSS  03.0
....................         parameter = 0;
162B:  CLRF   53
....................       if(i == 3 && parameter > 31)
162C:  MOVF   4D,W
162D:  SUBLW  03
162E:  BTFSS  03.2
162F:  GOTO   636
1630:  MOVF   53,W
1631:  SUBLW  1F
1632:  BTFSC  03.0
1633:  GOTO   636
....................         parameter = 1;
1634:  MOVLW  01
1635:  MOVWF  53
....................       if(i == 4 && parameter > 12)
1636:  MOVF   4D,W
1637:  SUBLW  04
1638:  BTFSS  03.2
1639:  GOTO   640
163A:  MOVF   53,W
163B:  SUBLW  0C
163C:  BTFSC  03.0
163D:  GOTO   640
....................         parameter = 1;
163E:  MOVLW  01
163F:  MOVWF  53
....................       if(i == 5 && parameter > 99)
1640:  MOVF   4D,W
1641:  SUBLW  05
1642:  BTFSS  03.2
1643:  GOTO   648
1644:  MOVF   53,W
1645:  SUBLW  63
1646:  BTFSS  03.0
....................         parameter = 0;
1647:  CLRF   53
....................       lcd_goto(xx, yy);
1648:  MOVF   54,W
1649:  MOVWF  56
164A:  MOVF   55,W
164B:  MOVWF  57
164C:  BCF    0A.4
164D:  BSF    0A.3
164E:  BCF    03.5
164F:  CALL   248
1650:  BSF    0A.4
1651:  BCF    0A.3
....................     printf(lcd_out,"%02u", parameter);
1652:  BSF    03.5
1653:  MOVF   53,W
1654:  MOVWF  56
1655:  MOVLW  01
1656:  MOVWF  57
1657:  BCF    0A.4
1658:  BSF    0A.3
1659:  BCF    03.5
165A:  CALL   377
165B:  BSF    0A.4
165C:  BCF    0A.3
....................     if((i == 6) || (i == 7)){
165D:  BSF    03.5
165E:  MOVF   4D,W
165F:  SUBLW  06
1660:  BTFSC  03.2
1661:  GOTO   666
1662:  MOVF   4D,W
1663:  SUBLW  07
1664:  BTFSS  03.2
1665:  GOTO   66A
....................       ds1307_read();
1666:  BCF    03.5
1667:  CALL   1FD
....................       ds1307_display();}
1668:  CALL   299
1669:  BSF    03.5
....................       delay_ms(200);}
166A:  MOVLW  C8
166B:  BCF    03.5
166C:  BSF    03.6
166D:  MOVWF  6A
166E:  BCF    0A.4
166F:  BCF    03.6
1670:  CALL   10D
1671:  BSF    0A.4
1672:  GOTO   60E
....................     lcd_goto(xx, yy);
1673:  BSF    03.5
1674:  MOVF   54,W
1675:  MOVWF  56
1676:  MOVF   55,W
1677:  MOVWF  57
1678:  BCF    0A.4
1679:  BSF    0A.3
167A:  BCF    03.5
167B:  CALL   248
167C:  BSF    0A.4
167D:  BCF    0A.3
....................     lcd_out("  ");
167E:  MOVLW  88
167F:  BSF    03.6
1680:  MOVWF  0D
1681:  MOVLW  00
1682:  MOVWF  0F
1683:  BCF    0A.4
1684:  BSF    0A.3
1685:  BCF    03.6
1686:  CALL   281
1687:  BSF    0A.4
1688:  BCF    0A.3
....................     j = 0;
1689:  BSF    03.5
168A:  CLRF   4E
....................     while((input(LEFT) || button_state || (i==6) || (i==7)) && (input(RIGHT) || 
....................       button_state || ((i != 6) && (i != 7))) && input(UP) && j < 5){
168B:  BSF    06.1
168C:  BCF    03.5
168D:  BTFSC  06.1
168E:  GOTO   69D
168F:  BTFSC  21.6
1690:  GOTO   69D
1691:  BSF    03.5
1692:  MOVF   4D,W
1693:  SUBLW  06
1694:  BTFSS  03.2
1695:  GOTO   698
1696:  BCF    03.5
1697:  GOTO   69D
1698:  MOVF   4D,W
1699:  SUBLW  07
169A:  BTFSS  03.2
169B:  GOTO   6C5
169C:  BCF    03.5
169D:  BSF    03.5
169E:  BSF    06.3
169F:  BCF    03.5
16A0:  BTFSC  06.3
16A1:  GOTO   6AE
16A2:  BTFSC  21.6
16A3:  GOTO   6AE
16A4:  BSF    03.5
16A5:  MOVF   4D,W
16A6:  SUBLW  06
16A7:  BTFSC  03.2
16A8:  GOTO   6C5
16A9:  MOVF   4D,W
16AA:  SUBLW  07
16AB:  BTFSC  03.2
16AC:  GOTO   6C5
16AD:  BCF    03.5
16AE:  BSF    03.5
16AF:  BSF    06.0
16B0:  BCF    03.5
16B1:  BTFSC  06.0
16B2:  GOTO   6B5
16B3:  BSF    03.5
16B4:  GOTO   6C5
16B5:  BSF    03.5
16B6:  MOVF   4E,W
16B7:  SUBLW  04
16B8:  BTFSS  03.0
16B9:  GOTO   6C5
....................       j++;
16BA:  INCF   4E,F
....................      delay_ms(100);}
16BB:  MOVLW  64
16BC:  BCF    03.5
16BD:  BSF    03.6
16BE:  MOVWF  6A
16BF:  BCF    0A.4
16C0:  BCF    03.6
16C1:  CALL   10D
16C2:  BSF    0A.4
16C3:  BSF    03.5
16C4:  GOTO   68B
....................     lcd_goto(xx, yy);
16C5:  MOVF   54,W
16C6:  MOVWF  56
16C7:  MOVF   55,W
16C8:  MOVWF  57
16C9:  BCF    0A.4
16CA:  BSF    0A.3
16CB:  BCF    03.5
16CC:  CALL   248
16CD:  BSF    0A.4
16CE:  BCF    0A.3
....................     printf(lcd_out,"%02u", parameter);
16CF:  BSF    03.5
16D0:  MOVF   53,W
16D1:  MOVWF  56
16D2:  MOVLW  01
16D3:  MOVWF  57
16D4:  BCF    0A.4
16D5:  BSF    0A.3
16D6:  BCF    03.5
16D7:  CALL   377
16D8:  BSF    0A.4
16D9:  BCF    0A.3
....................     j = 0;
16DA:  BSF    03.5
16DB:  CLRF   4E
....................     while((input(LEFT)||button_state||(i == 6) || (i == 7)) && (input(RIGHT) || 
....................       button_state || ((i != 6) && (i != 7))) && input(UP) && j < 5){
16DC:  BSF    06.1
16DD:  BCF    03.5
16DE:  BTFSC  06.1
16DF:  GOTO   6EE
16E0:  BTFSC  21.6
16E1:  GOTO   6EE
16E2:  BSF    03.5
16E3:  MOVF   4D,W
16E4:  SUBLW  06
16E5:  BTFSS  03.2
16E6:  GOTO   6E9
16E7:  BCF    03.5
16E8:  GOTO   6EE
16E9:  MOVF   4D,W
16EA:  SUBLW  07
16EB:  BTFSS  03.2
16EC:  GOTO   716
16ED:  BCF    03.5
16EE:  BSF    03.5
16EF:  BSF    06.3
16F0:  BCF    03.5
16F1:  BTFSC  06.3
16F2:  GOTO   6FF
16F3:  BTFSC  21.6
16F4:  GOTO   6FF
16F5:  BSF    03.5
16F6:  MOVF   4D,W
16F7:  SUBLW  06
16F8:  BTFSC  03.2
16F9:  GOTO   716
16FA:  MOVF   4D,W
16FB:  SUBLW  07
16FC:  BTFSC  03.2
16FD:  GOTO   716
16FE:  BCF    03.5
16FF:  BSF    03.5
1700:  BSF    06.0
1701:  BCF    03.5
1702:  BTFSC  06.0
1703:  GOTO   706
1704:  BSF    03.5
1705:  GOTO   716
1706:  BSF    03.5
1707:  MOVF   4E,W
1708:  SUBLW  04
1709:  BTFSS  03.0
170A:  GOTO   716
....................       j++;
170B:  INCF   4E,F
....................       delay_ms(100);}
170C:  MOVLW  64
170D:  BCF    03.5
170E:  BSF    03.6
170F:  MOVWF  6A
1710:  BCF    0A.4
1711:  BCF    03.6
1712:  CALL   10D
1713:  BSF    0A.4
1714:  BSF    03.5
1715:  GOTO   6DC
....................     if((i != 6) && (i != 7) && !input(LEFT) && !button_state){
1716:  MOVF   4D,W
1717:  SUBLW  06
1718:  BTFSC  03.2
1719:  GOTO   72D
171A:  MOVF   4D,W
171B:  SUBLW  07
171C:  BTFSC  03.2
171D:  GOTO   72D
171E:  BSF    06.1
171F:  BCF    03.5
1720:  BTFSS  06.1
1721:  GOTO   724
1722:  BSF    03.5
1723:  GOTO   72D
1724:  BTFSS  21.6
1725:  GOTO   728
1726:  BSF    03.5
1727:  GOTO   72D
....................       button_state = 1; return parameter;}
1728:  BSF    21.6
1729:  BSF    03.5
172A:  MOVF   53,W
172B:  MOVWF  78
172C:  GOTO   745
....................     if((i == 6) || (i == 7)){
172D:  MOVF   4D,W
172E:  SUBLW  06
172F:  BTFSC  03.2
1730:  GOTO   735
1731:  MOVF   4D,W
1732:  SUBLW  07
1733:  BTFSS  03.2
1734:  GOTO   744
....................       if(!input(RIGHT) && (!button_state)){
1735:  BSF    06.3
1736:  BCF    03.5
1737:  BTFSC  06.3
1738:  GOTO   741
1739:  BTFSC  21.6
173A:  GOTO   741
....................         button_state = 1; return parameter;}
173B:  BSF    21.6
173C:  BSF    03.5
173D:  MOVF   53,W
173E:  MOVWF  78
173F:  GOTO   745
1740:  BCF    03.5
....................       ds1307_read();
1741:  CALL   1FD
....................       ds1307_display();
1742:  CALL   299
1743:  BSF    03.5
....................     }
1744:  GOTO   605
....................   } 
1745:  BCF    03.5
1746:  RETURN
.................... }
.................... 
.................... //DS1307
.................... 
.................... unsigned int8 pos_x=1,pos_y=1,pos_go=1,pos=1;
.................... int1 status=0;
.................... 
.................... void xoa_LCD()
.................... {
....................       lcd_putc('\f');
*
07D3:  MOVLW  0C
07D4:  BSF    03.5
07D5:  MOVWF  56
*
07E5:  RETURN
.................... }
.................... 
.................... void xoa_pos_LCD()
.................... {
....................    lcd_goto(1,1);
*
0ED4:  MOVLW  01
0ED5:  BSF    03.5
0ED6:  MOVWF  56
0ED7:  MOVWF  57
0ED8:  BCF    03.5
0ED9:  CALL   248
....................    lcd_out(" ");
0EDA:  MOVLW  8A
0EDB:  BSF    03.6
0EDC:  MOVWF  0D
0EDD:  MOVLW  00
0EDE:  MOVWF  0F
0EDF:  BCF    03.6
0EE0:  CALL   281
....................    lcd_goto(1,2);
0EE1:  MOVLW  01
0EE2:  BSF    03.5
0EE3:  MOVWF  56
0EE4:  MOVLW  02
0EE5:  MOVWF  57
0EE6:  BCF    03.5
0EE7:  CALL   248
....................    lcd_out(" ");
0EE8:  MOVLW  8B
0EE9:  BSF    03.6
0EEA:  MOVWF  0D
0EEB:  MOVLW  00
0EEC:  MOVWF  0F
0EED:  BCF    03.6
0EEE:  CALL   281
....................    lcd_goto(21,1);
0EEF:  MOVLW  15
0EF0:  BSF    03.5
0EF1:  MOVWF  56
0EF2:  MOVLW  01
0EF3:  MOVWF  57
0EF4:  BCF    03.5
0EF5:  CALL   248
....................    lcd_out(" ");
0EF6:  MOVLW  8C
0EF7:  BSF    03.6
0EF8:  MOVWF  0D
0EF9:  MOVLW  00
0EFA:  MOVWF  0F
0EFB:  BCF    03.6
0EFC:  CALL   281
....................    lcd_goto(21,2);
0EFD:  MOVLW  15
0EFE:  BSF    03.5
0EFF:  MOVWF  56
0F00:  MOVLW  02
0F01:  MOVWF  57
0F02:  BCF    03.5
0F03:  CALL   248
....................    lcd_out(" ");
0F04:  MOVLW  8D
0F05:  BSF    03.6
0F06:  MOVWF  0D
0F07:  MOVLW  00
0F08:  MOVWF  0F
0F09:  BCF    03.6
0F0A:  CALL   281
....................    lcd_goto(7,1);
0F0B:  MOVLW  07
0F0C:  BSF    03.5
0F0D:  MOVWF  56
0F0E:  MOVLW  01
0F0F:  MOVWF  57
0F10:  BCF    03.5
0F11:  CALL   248
....................    lcd_out(" ");
0F12:  MOVLW  8E
0F13:  BSF    03.6
0F14:  MOVWF  0D
0F15:  MOVLW  00
0F16:  MOVWF  0F
0F17:  BCF    03.6
0F18:  CALL   281
....................    lcd_goto(7,2);
0F19:  MOVLW  07
0F1A:  BSF    03.5
0F1B:  MOVWF  56
0F1C:  MOVLW  02
0F1D:  MOVWF  57
0F1E:  BCF    03.5
0F1F:  CALL   248
....................    lcd_out(" ");
0F20:  MOVLW  8F
0F21:  BSF    03.6
0F22:  MOVWF  0D
0F23:  MOVLW  00
0F24:  MOVWF  0F
0F25:  BCF    03.6
0F26:  CALL   281
....................    lcd_goto(27,1);
0F27:  MOVLW  1B
0F28:  BSF    03.5
0F29:  MOVWF  56
0F2A:  MOVLW  01
0F2B:  MOVWF  57
0F2C:  BCF    03.5
0F2D:  CALL   248
....................    lcd_out(" ");
0F2E:  MOVLW  90
0F2F:  BSF    03.6
0F30:  MOVWF  0D
0F31:  MOVLW  00
0F32:  MOVWF  0F
0F33:  BCF    03.6
0F34:  CALL   281
....................    lcd_goto(27,2);
0F35:  MOVLW  1B
0F36:  BSF    03.5
0F37:  MOVWF  56
0F38:  MOVLW  02
0F39:  MOVWF  57
0F3A:  BCF    03.5
0F3B:  CALL   248
....................    lcd_out(" ");
0F3C:  MOVLW  91
0F3D:  BSF    03.6
0F3E:  MOVWF  0D
0F3F:  MOVLW  00
0F40:  MOVWF  0F
0F41:  BCF    03.6
0F42:  CALL   281
....................    lcd_goto(12,1);
0F43:  MOVLW  0C
0F44:  BSF    03.5
0F45:  MOVWF  56
0F46:  MOVLW  01
0F47:  MOVWF  57
0F48:  BCF    03.5
0F49:  CALL   248
....................    lcd_out(" ");
0F4A:  MOVLW  92
0F4B:  BSF    03.6
0F4C:  MOVWF  0D
0F4D:  MOVLW  00
0F4E:  MOVWF  0F
0F4F:  BCF    03.6
0F50:  CALL   281
....................    lcd_goto(12,2);
0F51:  MOVLW  0C
0F52:  BSF    03.5
0F53:  MOVWF  56
0F54:  MOVLW  02
0F55:  MOVWF  57
0F56:  BCF    03.5
0F57:  CALL   248
....................    lcd_out(" ");
0F58:  MOVLW  93
0F59:  BSF    03.6
0F5A:  MOVWF  0D
0F5B:  MOVLW  00
0F5C:  MOVWF  0F
0F5D:  BCF    03.6
0F5E:  CALL   281
....................    lcd_goto(32,1);
0F5F:  MOVLW  20
0F60:  BSF    03.5
0F61:  MOVWF  56
0F62:  MOVLW  01
0F63:  MOVWF  57
0F64:  BCF    03.5
0F65:  CALL   248
....................    lcd_out(" ");
0F66:  MOVLW  94
0F67:  BSF    03.6
0F68:  MOVWF  0D
0F69:  MOVLW  00
0F6A:  MOVWF  0F
0F6B:  BCF    03.6
0F6C:  CALL   281
....................    lcd_goto(32,2);
0F6D:  MOVLW  20
0F6E:  BSF    03.5
0F6F:  MOVWF  56
0F70:  MOVLW  02
0F71:  MOVWF  57
0F72:  BCF    03.5
0F73:  CALL   248
....................    lcd_out(" ");
0F74:  MOVLW  95
0F75:  BSF    03.6
0F76:  MOVWF  0D
0F77:  MOVLW  00
0F78:  MOVWF  0F
0F79:  BCF    03.6
0F7A:  CALL   281
0F7B:  RETURN
.................... }
.................... 
.................... int phim_ONOFF(int1 status)
*
0A17:  BSF    03.5
0A18:  BCF    55.0
0A19:  BTFSC  54.0
0A1A:  BSF    55.0
.................... {
....................    int1 mode = status;
....................    if(input(ONOFF)==0)
0A1B:  BSF    06.5
0A1C:  BCF    03.5
0A1D:  BTFSC  06.5
0A1E:  GOTO   23F
....................    {
....................       delay_ms(20);
0A1F:  MOVLW  14
0A20:  BSF    03.6
0A21:  MOVWF  6A
0A22:  BCF    0A.3
0A23:  BCF    03.6
0A24:  CALL   10D
0A25:  BSF    0A.3
....................       if(input(ONOFF)==0)
0A26:  BSF    03.5
0A27:  BSF    06.5
0A28:  BCF    03.5
0A29:  BTFSC  06.5
0A2A:  GOTO   23F
....................       {
....................          xoa_LCD();
0A2B:  BCF    0A.3
0A2C:  CALL   7D3
0A2D:  BSF    0A.3
....................          mode = !mode;
0A2E:  MOVLW  01
0A2F:  BSF    03.5
0A30:  XORWF  55,F
....................          if(pos_go==2 && pos == 3 ){
0A31:  MOVF   51,W
0A32:  SUBLW  02
0A33:  BTFSS  03.2
0A34:  GOTO   239
0A35:  MOVF   52,W
0A36:  SUBLW  03
0A37:  BTFSC  03.2
....................             mode = 1; } 
0A38:  BSF    55.0
....................          while(input(ONOFF)==0);
0A39:  BSF    06.5
0A3A:  BCF    03.5
0A3B:  BTFSC  06.5
0A3C:  GOTO   23F
0A3D:  BSF    03.5
0A3E:  GOTO   239
....................       }
....................    }
....................    
....................    return mode;
0A3F:  MOVLW  00
0A40:  BSF    03.5
0A41:  BTFSC  55.0
0A42:  MOVLW  01
0A43:  MOVWF  78
0A44:  BCF    03.5
0A45:  BSF    0A.3
0A46:  BSF    0A.4
0A47:  GOTO   1EF (RETURN)
.................... }
.................... 
.................... int phim_LEFT(unsigned int8 pos_x)
*
0F7C:  BSF    03.5
0F7D:  MOVF   53,W
0F7E:  MOVWF  54
.................... {
....................    unsigned int8 pos_temp = pos_x;
....................    if(input(LEFT)==0)
0F7F:  BSF    06.1
0F80:  BCF    03.5
0F81:  BTFSC  06.1
0F82:  GOTO   79B
....................    {
....................       delay_ms(20);
0F83:  MOVLW  14
0F84:  BSF    03.6
0F85:  MOVWF  6A
0F86:  BCF    0A.3
0F87:  BCF    03.6
0F88:  CALL   10D
0F89:  BSF    0A.3
....................       if(input(LEFT)==0)
0F8A:  BSF    03.5
0F8B:  BSF    06.1
0F8C:  BCF    03.5
0F8D:  BTFSC  06.1
0F8E:  GOTO   79B
....................       {
....................          xoa_pos_LCD();
0F8F:  CALL   6D4
....................          pos_temp--;
0F90:  BSF    03.5
0F91:  DECFSZ 54,F
....................          if(pos_temp<1)   pos_temp=1;
0F92:  GOTO   795
0F93:  MOVLW  01
0F94:  MOVWF  54
....................          while(input(LEFT)==0);
0F95:  BSF    06.1
0F96:  BCF    03.5
0F97:  BTFSC  06.1
0F98:  GOTO   79B
0F99:  BSF    03.5
0F9A:  GOTO   795
....................       }
....................    }
....................    
....................    return pos_temp;
0F9B:  BSF    03.5
0F9C:  MOVF   54,W
0F9D:  MOVWF  78
0F9E:  BCF    03.5
0F9F:  BSF    0A.3
0FA0:  BSF    0A.4
0FA1:  GOTO   211 (RETURN)
.................... }
.................... 
.................... int phim_RIGHT(unsigned int8 pos_x)
0FA2:  BSF    03.5
0FA3:  MOVF   53,W
0FA4:  MOVWF  54
.................... {
....................    unsigned int8 pos_temp = pos_x;
....................    if(input(RIGHT)==0)
0FA5:  BSF    06.3
0FA6:  BCF    03.5
0FA7:  BTFSC  06.3
0FA8:  GOTO   7C4
....................    {
....................       delay_ms(20);
0FA9:  MOVLW  14
0FAA:  BSF    03.6
0FAB:  MOVWF  6A
0FAC:  BCF    0A.3
0FAD:  BCF    03.6
0FAE:  CALL   10D
0FAF:  BSF    0A.3
....................       if(input(RIGHT)==0)
0FB0:  BSF    03.5
0FB1:  BSF    06.3
0FB2:  BCF    03.5
0FB3:  BTFSC  06.3
0FB4:  GOTO   7C4
....................       {
....................          xoa_pos_LCD();
0FB5:  CALL   6D4
....................          pos_temp++;
0FB6:  BSF    03.5
0FB7:  INCF   54,F
....................          if(pos_temp>2)   pos_temp=2;
0FB8:  MOVF   54,W
0FB9:  SUBLW  02
0FBA:  BTFSC  03.0
0FBB:  GOTO   7BE
0FBC:  MOVLW  02
0FBD:  MOVWF  54
....................          while(input(RIGHT)==0);
0FBE:  BSF    06.3
0FBF:  BCF    03.5
0FC0:  BTFSC  06.3
0FC1:  GOTO   7C4
0FC2:  BSF    03.5
0FC3:  GOTO   7BE
....................       }
....................    }
....................    
....................    return pos_temp;
0FC4:  BSF    03.5
0FC5:  MOVF   54,W
0FC6:  MOVWF  78
0FC7:  BCF    03.5
0FC8:  BSF    0A.3
0FC9:  BSF    0A.4
0FCA:  GOTO   21A (RETURN)
.................... }
.................... 
.................... int phim_UP(unsigned int8 pos_y)
0FCB:  BSF    03.5
0FCC:  MOVF   53,W
0FCD:  MOVWF  54
.................... {
....................    unsigned int8 pos_temp = pos_y;
....................    if(input(UP)==0)
0FCE:  BSF    06.0
0FCF:  BCF    03.5
0FD0:  BTFSC  06.0
0FD1:  GOTO   7EA
....................    {
....................       delay_ms(20);
0FD2:  MOVLW  14
0FD3:  BSF    03.6
0FD4:  MOVWF  6A
0FD5:  BCF    0A.3
0FD6:  BCF    03.6
0FD7:  CALL   10D
0FD8:  BSF    0A.3
....................       if(input(UP)==0)
0FD9:  BSF    03.5
0FDA:  BSF    06.0
0FDB:  BCF    03.5
0FDC:  BTFSC  06.0
0FDD:  GOTO   7EA
....................       {
....................          xoa_pos_LCD();
0FDE:  CALL   6D4
....................          pos_temp--;
0FDF:  BSF    03.5
0FE0:  DECFSZ 54,F
....................          if(pos_temp<1)   pos_temp=1;
0FE1:  GOTO   7E4
0FE2:  MOVLW  01
0FE3:  MOVWF  54
....................          while(input(UP)==0);
0FE4:  BSF    06.0
0FE5:  BCF    03.5
0FE6:  BTFSC  06.0
0FE7:  GOTO   7EA
0FE8:  BSF    03.5
0FE9:  GOTO   7E4
....................       }
....................    }
....................    
....................    return pos_temp;
0FEA:  BSF    03.5
0FEB:  MOVF   54,W
0FEC:  MOVWF  78
0FED:  BCF    03.5
0FEE:  BSF    0A.3
0FEF:  BSF    0A.4
0FF0:  GOTO   223 (RETURN)
.................... }
.................... 
.................... int phim_DW(unsigned int8 pos_y)
*
1000:  BSF    03.5
1001:  MOVF   53,W
1002:  MOVWF  54
.................... {
....................    unsigned int8 pos_temp = pos_y;
....................    if(input(DW)==0)
1003:  BSF    06.4
1004:  BCF    03.5
1005:  BTFSC  06.4
1006:  GOTO   02E
....................    {
....................       delay_ms(20);
1007:  MOVLW  14
1008:  BSF    03.6
1009:  MOVWF  6A
100A:  BCF    0A.4
100B:  BCF    03.6
100C:  CALL   10D
100D:  BSF    0A.4
....................       if(input(DW)==0)
100E:  BSF    03.5
100F:  BSF    06.4
1010:  BCF    03.5
1011:  BTFSC  06.4
1012:  GOTO   02E
....................       {
....................          xoa_pos_LCD();
1013:  BCF    0A.4
1014:  BSF    0A.3
1015:  CALL   6D4
1016:  BSF    0A.4
1017:  BCF    0A.3
....................          pos_temp++;
1018:  BSF    03.5
1019:  INCF   54,F
....................          if(pos_temp>4)   pos_temp=4;
101A:  MOVF   54,W
101B:  SUBLW  04
101C:  BTFSC  03.0
101D:  GOTO   020
101E:  MOVLW  04
101F:  MOVWF  54
....................          if(pos_go==1 && pos == 3 ){
1020:  DECFSZ 51,W
1021:  GOTO   028
1022:  MOVF   52,W
1023:  SUBLW  03
1024:  BTFSS  03.2
1025:  GOTO   028
....................             pos_temp = 3; } 
1026:  MOVLW  03
1027:  MOVWF  54
....................          while(input(DW)==0);
1028:  BSF    06.4
1029:  BCF    03.5
102A:  BTFSC  06.4
102B:  GOTO   02E
102C:  BSF    03.5
102D:  GOTO   028
....................       }
....................    }
....................    return pos_temp;
102E:  BSF    03.5
102F:  MOVF   54,W
1030:  MOVWF  78
1031:  BCF    03.5
1032:  BSF    0A.3
1033:  BSF    0A.4
1034:  GOTO   22C (RETURN)
.................... }
.................... 
.................... int phim_GO(unsigned int8 pos_go)
*
0DCA:  BSF    03.5
0DCB:  MOVF   53,W
0DCC:  MOVWF  54
.................... {
....................    unsigned int8 pos_temp = pos_go;
....................    if(input(GO)==0)
0DCD:  BSF    06.2
0DCE:  BCF    03.5
0DCF:  BTFSC  06.2
0DD0:  GOTO   661
....................    {
....................       delay_ms(20);
0DD1:  MOVLW  14
0DD2:  BSF    03.6
0DD3:  MOVWF  6A
0DD4:  BCF    0A.3
0DD5:  BCF    03.6
0DD6:  CALL   10D
0DD7:  BSF    0A.3
....................       if(input(GO)==0)
0DD8:  BSF    03.5
0DD9:  BSF    06.2
0DDA:  BCF    03.5
0DDB:  BTFSC  06.2
0DDC:  GOTO   661
....................       {
....................          xoa_LCD();
0DDD:  BCF    0A.3
0DDE:  CALL   7D3
0DDF:  BSF    0A.3
....................          pos_temp++;
0DE0:  BSF    03.5
0DE1:  INCF   54,F
....................          if(pos_temp>2)
0DE2:  MOVF   54,W
0DE3:  SUBLW  02
0DE4:  BTFSC  03.0
0DE5:  GOTO   65B
....................          {   
....................             pos_temp=2;
0DE6:  MOVLW  02
0DE7:  MOVWF  54
....................                //Mode Manual
....................                if((pos==1) && (pos_y==1) && (pos_x == 1)){
0DE8:  DECFSZ 52,W
0DE9:  GOTO   5F4
0DEA:  DECFSZ 50,W
0DEB:  GOTO   5F4
0DEC:  DECFSZ 4F,W
0DED:  GOTO   5F4
....................                         output_high(FAN); q=1 ;   //FAN ON
0DEE:  BCF    05.1
0DEF:  BCF    03.5
0DF0:  BSF    05.1
0DF1:  BSF    21.2
....................                }else if ((pos==1) && (pos_y==1) && (pos_x==2)){
0DF2:  GOTO   65A
0DF3:  BSF    03.5
0DF4:  DECFSZ 52,W
0DF5:  GOTO   602
0DF6:  DECFSZ 50,W
0DF7:  GOTO   602
0DF8:  MOVF   4F,W
0DF9:  SUBLW  02
0DFA:  BTFSS  03.2
0DFB:  GOTO   602
....................                         output_low(FAN); q=0;   //FAN OFF   
0DFC:  BCF    05.1
0DFD:  BCF    03.5
0DFE:  BCF    05.1
0DFF:  BCF    21.2
....................                }else if ((pos==1) && (pos_y==2) && (pos_x==1)){
0E00:  GOTO   65A
0E01:  BSF    03.5
0E02:  DECFSZ 52,W
0E03:  GOTO   610
0E04:  MOVF   50,W
0E05:  SUBLW  02
0E06:  BTFSS  03.2
0E07:  GOTO   610
0E08:  DECFSZ 4F,W
0E09:  GOTO   610
....................                         output_high(LED); d=1;   //LED ON
0E0A:  BCF    05.2
0E0B:  BCF    03.5
0E0C:  BSF    05.2
0E0D:  BSF    21.3
....................                }else if ((pos==1) && (pos_y==2) && (pos_x==2)){
0E0E:  GOTO   65A
0E0F:  BSF    03.5
0E10:  DECFSZ 52,W
0E11:  GOTO   620
0E12:  MOVF   50,W
0E13:  SUBLW  02
0E14:  BTFSS  03.2
0E15:  GOTO   620
0E16:  MOVF   4F,W
0E17:  SUBLW  02
0E18:  BTFSS  03.2
0E19:  GOTO   620
....................                         output_low(LED); d=0;    //LED OFF
0E1A:  BCF    05.2
0E1B:  BCF    03.5
0E1C:  BCF    05.2
0E1D:  BCF    21.3
....................                }else if ((pos==1) && (pos_y==3) && (pos_x==1)){
0E1E:  GOTO   65A
0E1F:  BSF    03.5
0E20:  DECFSZ 52,W
0E21:  GOTO   62E
0E22:  MOVF   50,W
0E23:  SUBLW  03
0E24:  BTFSS  03.2
0E25:  GOTO   62E
0E26:  DECFSZ 4F,W
0E27:  GOTO   62E
....................                         output_high(BOMB); b=1;  //BOMB ON
0E28:  BCF    05.3
0E29:  BCF    03.5
0E2A:  BSF    05.3
0E2B:  BSF    21.4
....................                }else if ((pos==1) && (pos_y==3) && (pos_x==2)){
0E2C:  GOTO   65A
0E2D:  BSF    03.5
0E2E:  DECFSZ 52,W
0E2F:  GOTO   63E
0E30:  MOVF   50,W
0E31:  SUBLW  03
0E32:  BTFSS  03.2
0E33:  GOTO   63E
0E34:  MOVF   4F,W
0E35:  SUBLW  02
0E36:  BTFSS  03.2
0E37:  GOTO   63E
....................                         output_low(BOMB); b=0; //BOMB OFF
0E38:  BCF    05.3
0E39:  BCF    03.5
0E3A:  BCF    05.3
0E3B:  BCF    21.4
....................                }else if ((pos==1) && (pos_y==4) && (pos_x==1)){
0E3C:  GOTO   65A
0E3D:  BSF    03.5
0E3E:  DECFSZ 52,W
0E3F:  GOTO   64C
0E40:  MOVF   50,W
0E41:  SUBLW  04
0E42:  BTFSS  03.2
0E43:  GOTO   64C
0E44:  DECFSZ 4F,W
0E45:  GOTO   64C
....................                         output_high(SPRAY); p=1;   //SPRAY ON
0E46:  BCF    05.4
0E47:  BCF    03.5
0E48:  BSF    05.4
0E49:  BSF    21.5
....................                }else if ((pos==1) && (pos_y==4) && (pos_x==2)){
0E4A:  GOTO   65A
0E4B:  BSF    03.5
0E4C:  DECFSZ 52,W
0E4D:  GOTO   65B
0E4E:  MOVF   50,W
0E4F:  SUBLW  04
0E50:  BTFSS  03.2
0E51:  GOTO   65B
0E52:  MOVF   4F,W
0E53:  SUBLW  02
0E54:  BTFSS  03.2
0E55:  GOTO   65B
....................                         output_low(SPRAY); p=0; //SPRAY OFF
0E56:  BCF    05.4
0E57:  BCF    03.5
0E58:  BCF    05.4
0E59:  BCF    21.5
0E5A:  BSF    03.5
....................                }
....................                //  
....................          }
.................... 
....................          
....................          while(input(GO )==0);
0E5B:  BSF    06.2
0E5C:  BCF    03.5
0E5D:  BTFSC  06.2
0E5E:  GOTO   661
0E5F:  BSF    03.5
0E60:  GOTO   65B
....................       }
....................    }
....................    
....................    return pos_temp;
0E61:  BSF    03.5
0E62:  MOVF   54,W
0E63:  MOVWF  78
0E64:  BCF    03.5
0E65:  BSF    0A.3
0E66:  BSF    0A.4
0E67:  GOTO   1FF (RETURN)
.................... }
.................... 
.................... 
.................... int phim_BACK(unsigned int8 pos_go)
0E68:  BSF    03.5
0E69:  MOVF   53,W
0E6A:  MOVWF  54
.................... {
....................    unsigned int8 pos_temp = pos_go;
....................    if(input(BACK)==0)
0E6B:  BSF    06.6
0E6C:  BCF    03.5
0E6D:  BTFSC  06.6
0E6E:  GOTO   6CD
....................    {
....................       delay_ms(20);
0E6F:  MOVLW  14
0E70:  BSF    03.6
0E71:  MOVWF  6A
0E72:  BCF    0A.3
0E73:  BCF    03.6
0E74:  CALL   10D
0E75:  BSF    0A.3
....................       if(input(BACK)==0)
0E76:  BSF    03.5
0E77:  BSF    06.6
0E78:  BCF    03.5
0E79:  BTFSC  06.6
0E7A:  GOTO   6CD
....................       {
....................          xoa_LCD();
0E7B:  BCF    0A.3
0E7C:  CALL   7D3
0E7D:  BSF    0A.3
....................          pos_temp--;
0E7E:  BSF    03.5
0E7F:  DECFSZ 54,F
....................          if(pos_temp<1)   pos_temp=1;
0E80:  GOTO   683
0E81:  MOVLW  01
0E82:  MOVWF  54
....................          if(pos_go==2 && pos == 1){
0E83:  MOVF   53,W
0E84:  SUBLW  02
0E85:  BTFSS  03.2
0E86:  GOTO   69F
0E87:  DECFSZ 52,W
0E88:  GOTO   69F
....................             pos_y = 1;
0E89:  MOVLW  01
0E8A:  MOVWF  50
....................              output_low(FAN) ; q = 0;
0E8B:  BCF    05.1
0E8C:  BCF    03.5
0E8D:  BCF    05.1
0E8E:  BCF    21.2
....................              output_low(LED); d = 0;
0E8F:  BSF    03.5
0E90:  BCF    05.2
0E91:  BCF    03.5
0E92:  BCF    05.2
0E93:  BCF    21.3
....................              output_low(BOMB); b = 0;
0E94:  BSF    03.5
0E95:  BCF    05.3
0E96:  BCF    03.5
0E97:  BCF    05.3
0E98:  BCF    21.4
....................              output_low(SPRAY); p= 0;       
0E99:  BSF    03.5
0E9A:  BCF    05.4
0E9B:  BCF    03.5
0E9C:  BCF    05.4
0E9D:  BCF    21.5
0E9E:  BSF    03.5
....................          } 
....................           if(pos_go==2 && pos == 2){
0E9F:  MOVF   53,W
0EA0:  SUBLW  02
0EA1:  BTFSS  03.2
0EA2:  GOTO   6BB
0EA3:  MOVF   52,W
0EA4:  SUBLW  02
0EA5:  BTFSS  03.2
0EA6:  GOTO   6BB
....................             //pos_y = 1;
....................              output_low(FAN) ; q = 0;
0EA7:  BCF    05.1
0EA8:  BCF    03.5
0EA9:  BCF    05.1
0EAA:  BCF    21.2
....................              output_low(LED); d = 0;
0EAB:  BSF    03.5
0EAC:  BCF    05.2
0EAD:  BCF    03.5
0EAE:  BCF    05.2
0EAF:  BCF    21.3
....................              output_low(BOMB); b = 0;
0EB0:  BSF    03.5
0EB1:  BCF    05.3
0EB2:  BCF    03.5
0EB3:  BCF    05.3
0EB4:  BCF    21.4
....................              output_low(SPRAY); p= 0;       
0EB5:  BSF    03.5
0EB6:  BCF    05.4
0EB7:  BCF    03.5
0EB8:  BCF    05.4
0EB9:  BCF    21.5
0EBA:  BSF    03.5
....................          }
....................           if(pos_go==2 && pos == 3){
0EBB:  MOVF   53,W
0EBC:  SUBLW  02
0EBD:  BTFSS  03.2
0EBE:  GOTO   6C7
0EBF:  MOVF   52,W
0EC0:  SUBLW  03
0EC1:  BTFSS  03.2
0EC2:  GOTO   6C7
....................              output_low(SPRAY); 
0EC3:  BCF    05.4
0EC4:  BCF    03.5
0EC5:  BCF    05.4
0EC6:  BSF    03.5
....................              }
....................          while(input(BACK)==0);
0EC7:  BSF    06.6
0EC8:  BCF    03.5
0EC9:  BTFSC  06.6
0ECA:  GOTO   6CD
0ECB:  BSF    03.5
0ECC:  GOTO   6C7
....................       }
....................    }
....................    
....................    return pos_temp;
0ECD:  BSF    03.5
0ECE:  MOVF   54,W
0ECF:  MOVWF  78
0ED0:  BCF    03.5
0ED1:  BSF    0A.3
0ED2:  BSF    0A.4
0ED3:  GOTO   208 (RETURN)
.................... }
.................... 
.................... void pos_xy_current(unsigned int8 pos_x,pos_y,pos)
.................... {
....................   // unsigned int8 col;
....................    if(pos_go==2&&(pos==1))
*
105B:  BSF    03.5
105C:  MOVF   51,W
105D:  SUBLW  02
105E:  BTFSS  03.2
105F:  GOTO   140
1060:  DECFSZ 55,W
1061:  GOTO   140
....................    { 
....................       if(pos_y&&(pos_x==1)){
1062:  MOVF   54,F
1063:  BTFSC  03.2
1064:  GOTO   0D0
1065:  DECFSZ 53,W
1066:  GOTO   0D0
....................          switch (pos_y)
1067:  MOVF   54,W
1068:  XORLW  01
1069:  BCF    03.5
106A:  BTFSC  03.2
106B:  GOTO   073
106C:  XORLW  03
106D:  BTFSC  03.2
106E:  GOTO   08A
106F:  XORLW  01
1070:  BTFSC  03.2
1071:  GOTO   0A1
1072:  GOTO   0B8
....................          {
....................             case 1: 
....................                lcd_goto(7,1);
1073:  MOVLW  07
1074:  BSF    03.5
1075:  MOVWF  56
1076:  MOVLW  01
1077:  MOVWF  57
1078:  BCF    0A.4
1079:  BSF    0A.3
107A:  BCF    03.5
107B:  CALL   248
107C:  BSF    0A.4
107D:  BCF    0A.3
....................                lcd_out(">");
107E:  MOVLW  96
107F:  BSF    03.6
1080:  MOVWF  0D
1081:  MOVLW  00
1082:  MOVWF  0F
1083:  BCF    0A.4
1084:  BSF    0A.3
1085:  BCF    03.6
1086:  CALL   281
1087:  BSF    0A.4
1088:  BCF    0A.3
....................                break;
1089:  GOTO   0CE
....................             case 2:  
....................                lcd_goto(7,2);
108A:  MOVLW  07
108B:  BSF    03.5
108C:  MOVWF  56
108D:  MOVLW  02
108E:  MOVWF  57
108F:  BCF    0A.4
1090:  BSF    0A.3
1091:  BCF    03.5
1092:  CALL   248
1093:  BSF    0A.4
1094:  BCF    0A.3
....................                lcd_out(">");
1095:  MOVLW  97
1096:  BSF    03.6
1097:  MOVWF  0D
1098:  MOVLW  00
1099:  MOVWF  0F
109A:  BCF    0A.4
109B:  BSF    0A.3
109C:  BCF    03.6
109D:  CALL   281
109E:  BSF    0A.4
109F:  BCF    0A.3
....................                break;
10A0:  GOTO   0CE
....................             case 3:  
....................                lcd_goto(27,1);
10A1:  MOVLW  1B
10A2:  BSF    03.5
10A3:  MOVWF  56
10A4:  MOVLW  01
10A5:  MOVWF  57
10A6:  BCF    0A.4
10A7:  BSF    0A.3
10A8:  BCF    03.5
10A9:  CALL   248
10AA:  BSF    0A.4
10AB:  BCF    0A.3
....................                lcd_out(">");
10AC:  MOVLW  98
10AD:  BSF    03.6
10AE:  MOVWF  0D
10AF:  MOVLW  00
10B0:  MOVWF  0F
10B1:  BCF    0A.4
10B2:  BSF    0A.3
10B3:  BCF    03.6
10B4:  CALL   281
10B5:  BSF    0A.4
10B6:  BCF    0A.3
....................                break;   
10B7:  GOTO   0CE
....................                
....................             default:
....................                lcd_goto(27,2);
10B8:  MOVLW  1B
10B9:  BSF    03.5
10BA:  MOVWF  56
10BB:  MOVLW  02
10BC:  MOVWF  57
10BD:  BCF    0A.4
10BE:  BSF    0A.3
10BF:  BCF    03.5
10C0:  CALL   248
10C1:  BSF    0A.4
10C2:  BCF    0A.3
....................                lcd_out(">");
10C3:  MOVLW  99
10C4:  BSF    03.6
10C5:  MOVWF  0D
10C6:  MOVLW  00
10C7:  MOVWF  0F
10C8:  BCF    0A.4
10C9:  BSF    0A.3
10CA:  BCF    03.6
10CB:  CALL   281
10CC:  BSF    0A.4
10CD:  BCF    0A.3
....................                break;      
....................          }
....................       }
10CE:  GOTO   13E
10CF:  BSF    03.5
....................     
....................       else if((pos_y)&&(pos_x==2)){
10D0:  MOVF   54,F
10D1:  BTFSC  03.2
10D2:  GOTO   13F
10D3:  MOVF   53,W
10D4:  SUBLW  02
10D5:  BTFSS  03.2
10D6:  GOTO   13F
....................          switch (pos_y)
10D7:  MOVF   54,W
10D8:  XORLW  01
10D9:  BCF    03.5
10DA:  BTFSC  03.2
10DB:  GOTO   0E3
10DC:  XORLW  03
10DD:  BTFSC  03.2
10DE:  GOTO   0FA
10DF:  XORLW  01
10E0:  BTFSC  03.2
10E1:  GOTO   111
10E2:  GOTO   128
....................          {
....................             case 1: 
....................                lcd_goto(12,1);
10E3:  MOVLW  0C
10E4:  BSF    03.5
10E5:  MOVWF  56
10E6:  MOVLW  01
10E7:  MOVWF  57
10E8:  BCF    0A.4
10E9:  BSF    0A.3
10EA:  BCF    03.5
10EB:  CALL   248
10EC:  BSF    0A.4
10ED:  BCF    0A.3
....................                lcd_out(">");
10EE:  MOVLW  9A
10EF:  BSF    03.6
10F0:  MOVWF  0D
10F1:  MOVLW  00
10F2:  MOVWF  0F
10F3:  BCF    0A.4
10F4:  BSF    0A.3
10F5:  BCF    03.6
10F6:  CALL   281
10F7:  BSF    0A.4
10F8:  BCF    0A.3
....................                break;
10F9:  GOTO   13E
....................             case 2:  
....................                lcd_goto(12,2);
10FA:  MOVLW  0C
10FB:  BSF    03.5
10FC:  MOVWF  56
10FD:  MOVLW  02
10FE:  MOVWF  57
10FF:  BCF    0A.4
1100:  BSF    0A.3
1101:  BCF    03.5
1102:  CALL   248
1103:  BSF    0A.4
1104:  BCF    0A.3
....................                lcd_out(">");
1105:  MOVLW  9B
1106:  BSF    03.6
1107:  MOVWF  0D
1108:  MOVLW  00
1109:  MOVWF  0F
110A:  BCF    0A.4
110B:  BSF    0A.3
110C:  BCF    03.6
110D:  CALL   281
110E:  BSF    0A.4
110F:  BCF    0A.3
....................                break;
1110:  GOTO   13E
....................             case 3:  
....................                lcd_goto(32,1);
1111:  MOVLW  20
1112:  BSF    03.5
1113:  MOVWF  56
1114:  MOVLW  01
1115:  MOVWF  57
1116:  BCF    0A.4
1117:  BSF    0A.3
1118:  BCF    03.5
1119:  CALL   248
111A:  BSF    0A.4
111B:  BCF    0A.3
....................                lcd_out(">");
111C:  MOVLW  9C
111D:  BSF    03.6
111E:  MOVWF  0D
111F:  MOVLW  00
1120:  MOVWF  0F
1121:  BCF    0A.4
1122:  BSF    0A.3
1123:  BCF    03.6
1124:  CALL   281
1125:  BSF    0A.4
1126:  BCF    0A.3
....................                break;   
1127:  GOTO   13E
....................                
....................             default:
....................                lcd_goto(32,2);
1128:  MOVLW  20
1129:  BSF    03.5
112A:  MOVWF  56
112B:  MOVLW  02
112C:  MOVWF  57
112D:  BCF    0A.4
112E:  BSF    0A.3
112F:  BCF    03.5
1130:  CALL   248
1131:  BSF    0A.4
1132:  BCF    0A.3
....................                lcd_out(">");
1133:  MOVLW  9D
1134:  BSF    03.6
1135:  MOVWF  0D
1136:  MOVLW  00
1137:  MOVWF  0F
1138:  BCF    0A.4
1139:  BSF    0A.3
113A:  BCF    03.6
113B:  CALL   281
113C:  BSF    0A.4
113D:  BCF    0A.3
....................                break;      
113E:  BSF    03.5
....................          }
....................       }
....................        
....................   }
113F:  GOTO   1B7
....................   else if(pos_go==2&&pos==2){
1140:  MOVF   51,W
1141:  SUBLW  02
1142:  BTFSS  03.2
1143:  GOTO   148
1144:  MOVF   55,W
1145:  SUBLW  02
1146:  BTFSC  03.2
....................        
....................        
....................   }
1147:  GOTO   1B7
....................   else if(pos_go==2&&pos==3){
1148:  MOVF   51,W
1149:  SUBLW  02
114A:  BTFSS  03.2
114B:  GOTO   150
114C:  MOVF   55,W
114D:  SUBLW  03
114E:  BTFSC  03.2
....................        
....................        
....................   }
114F:  GOTO   1B7
....................   else
....................    {
....................       switch (pos_y)
1150:  MOVF   54,W
1151:  XORLW  01
1152:  BCF    03.5
1153:  BTFSC  03.2
1154:  GOTO   15C
1155:  XORLW  03
1156:  BTFSC  03.2
1157:  GOTO   172
1158:  XORLW  01
1159:  BTFSC  03.2
115A:  GOTO   189
115B:  GOTO   1A0
....................       {
....................          case 1: 
....................             lcd_goto(1,1);
115C:  MOVLW  01
115D:  BSF    03.5
115E:  MOVWF  56
115F:  MOVWF  57
1160:  BCF    0A.4
1161:  BSF    0A.3
1162:  BCF    03.5
1163:  CALL   248
1164:  BSF    0A.4
1165:  BCF    0A.3
....................             lcd_out(">");
1166:  MOVLW  9E
1167:  BSF    03.6
1168:  MOVWF  0D
1169:  MOVLW  00
116A:  MOVWF  0F
116B:  BCF    0A.4
116C:  BSF    0A.3
116D:  BCF    03.6
116E:  CALL   281
116F:  BSF    0A.4
1170:  BCF    0A.3
....................             break;
1171:  GOTO   1B6
....................          case 2:  
....................             lcd_goto(1,2);
1172:  MOVLW  01
1173:  BSF    03.5
1174:  MOVWF  56
1175:  MOVLW  02
1176:  MOVWF  57
1177:  BCF    0A.4
1178:  BSF    0A.3
1179:  BCF    03.5
117A:  CALL   248
117B:  BSF    0A.4
117C:  BCF    0A.3
....................             lcd_out(">");
117D:  MOVLW  9F
117E:  BSF    03.6
117F:  MOVWF  0D
1180:  MOVLW  00
1181:  MOVWF  0F
1182:  BCF    0A.4
1183:  BSF    0A.3
1184:  BCF    03.6
1185:  CALL   281
1186:  BSF    0A.4
1187:  BCF    0A.3
....................             break;
1188:  GOTO   1B6
....................          case 3:  
....................             lcd_goto(21,1);
1189:  MOVLW  15
118A:  BSF    03.5
118B:  MOVWF  56
118C:  MOVLW  01
118D:  MOVWF  57
118E:  BCF    0A.4
118F:  BSF    0A.3
1190:  BCF    03.5
1191:  CALL   248
1192:  BSF    0A.4
1193:  BCF    0A.3
....................             lcd_out(">");
1194:  MOVLW  A0
1195:  BSF    03.6
1196:  MOVWF  0D
1197:  MOVLW  00
1198:  MOVWF  0F
1199:  BCF    0A.4
119A:  BSF    0A.3
119B:  BCF    03.6
119C:  CALL   281
119D:  BSF    0A.4
119E:  BCF    0A.3
....................             break;   
119F:  GOTO   1B6
....................             
....................          default:
....................             lcd_goto(21,2);
11A0:  MOVLW  15
11A1:  BSF    03.5
11A2:  MOVWF  56
11A3:  MOVLW  02
11A4:  MOVWF  57
11A5:  BCF    0A.4
11A6:  BSF    0A.3
11A7:  BCF    03.5
11A8:  CALL   248
11A9:  BSF    0A.4
11AA:  BCF    0A.3
....................             lcd_out(">");
11AB:  MOVLW  A1
11AC:  BSF    03.6
11AD:  MOVWF  0D
11AE:  MOVLW  00
11AF:  MOVWF  0F
11B0:  BCF    0A.4
11B1:  BSF    0A.3
11B2:  BCF    03.6
11B3:  CALL   281
11B4:  BSF    0A.4
11B5:  BCF    0A.3
....................             break;
11B6:  BSF    03.5
....................       }
....................    }   
11B7:  BCF    03.5
11B8:  BSF    0A.3
11B9:  BSF    0A.4
11BA:  GOTO   246 (RETURN)
.................... }
.................... 
.................... void mode_ON()
.................... {
....................    lcd_goto(2,1);
11BB:  MOVLW  02
11BC:  BSF    03.5
11BD:  MOVWF  56
11BE:  MOVLW  01
11BF:  MOVWF  57
11C0:  BCF    0A.4
11C1:  BSF    0A.3
11C2:  BCF    03.5
11C3:  CALL   248
11C4:  BSF    0A.4
11C5:  BCF    0A.3
....................    lcd_out("TAY");
11C6:  MOVLW  A2
11C7:  BSF    03.6
11C8:  MOVWF  0D
11C9:  MOVLW  00
11CA:  MOVWF  0F
11CB:  BCF    0A.4
11CC:  BSF    0A.3
11CD:  BCF    03.6
11CE:  CALL   281
11CF:  BSF    0A.4
11D0:  BCF    0A.3
....................    lcd_goto(2,2);
11D1:  MOVLW  02
11D2:  BSF    03.5
11D3:  MOVWF  56
11D4:  MOVWF  57
11D5:  BCF    0A.4
11D6:  BSF    0A.3
11D7:  BCF    03.5
11D8:  CALL   248
11D9:  BSF    0A.4
11DA:  BCF    0A.3
....................    lcd_out("AUTO");
11DB:  MOVLW  A4
11DC:  BSF    03.6
11DD:  MOVWF  0D
11DE:  MOVLW  00
11DF:  MOVWF  0F
11E0:  BCF    0A.4
11E1:  BSF    0A.3
11E2:  BCF    03.6
11E3:  CALL   281
11E4:  BSF    0A.4
11E5:  BCF    0A.3
....................    lcd_goto(22,1);
11E6:  MOVLW  16
11E7:  BSF    03.5
11E8:  MOVWF  56
11E9:  MOVLW  01
11EA:  MOVWF  57
11EB:  BCF    0A.4
11EC:  BSF    0A.3
11ED:  BCF    03.5
11EE:  CALL   248
11EF:  BSF    0A.4
11F0:  BCF    0A.3
....................    lcd_out("CLOCK");  
11F1:  MOVLW  A7
11F2:  BSF    03.6
11F3:  MOVWF  0D
11F4:  MOVLW  00
11F5:  MOVWF  0F
11F6:  BCF    0A.4
11F7:  BSF    0A.3
11F8:  BCF    03.6
11F9:  CALL   281
11FA:  BSF    0A.4
11FB:  BCF    0A.3
11FC:  RETURN
.................... }
.................... void pos_relay_2()
.................... {
....................    lcd_goto(2,1); lcd_out("QUAT");
*
139D:  MOVLW  02
139E:  BSF    03.5
139F:  MOVWF  56
13A0:  MOVLW  01
13A1:  MOVWF  57
13A2:  BCF    0A.4
13A3:  BSF    0A.3
13A4:  BCF    03.5
13A5:  CALL   248
13A6:  BSF    0A.4
13A7:  BCF    0A.3
13A8:  MOVLW  AA
13A9:  BSF    03.6
13AA:  MOVWF  0D
13AB:  MOVLW  00
13AC:  MOVWF  0F
13AD:  BCF    0A.4
13AE:  BSF    0A.3
13AF:  BCF    03.6
13B0:  CALL   281
13B1:  BSF    0A.4
13B2:  BCF    0A.3
....................    lcd_goto(2,2); lcd_out("DEN");
13B3:  MOVLW  02
13B4:  BSF    03.5
13B5:  MOVWF  56
13B6:  MOVWF  57
13B7:  BCF    0A.4
13B8:  BSF    0A.3
13B9:  BCF    03.5
13BA:  CALL   248
13BB:  BSF    0A.4
13BC:  BCF    0A.3
13BD:  MOVLW  AD
13BE:  BSF    03.6
13BF:  MOVWF  0D
13C0:  MOVLW  00
13C1:  MOVWF  0F
13C2:  BCF    0A.4
13C3:  BSF    0A.3
13C4:  BCF    03.6
13C5:  CALL   281
13C6:  BSF    0A.4
13C7:  BCF    0A.3
....................    lcd_goto(22,1);lcd_out("BOM"); 
13C8:  MOVLW  16
13C9:  BSF    03.5
13CA:  MOVWF  56
13CB:  MOVLW  01
13CC:  MOVWF  57
13CD:  BCF    0A.4
13CE:  BSF    0A.3
13CF:  BCF    03.5
13D0:  CALL   248
13D1:  BSF    0A.4
13D2:  BCF    0A.3
13D3:  MOVLW  AF
13D4:  BSF    03.6
13D5:  MOVWF  0D
13D6:  MOVLW  00
13D7:  MOVWF  0F
13D8:  BCF    0A.4
13D9:  BSF    0A.3
13DA:  BCF    03.6
13DB:  CALL   281
13DC:  BSF    0A.4
13DD:  BCF    0A.3
....................    lcd_goto(22,2);lcd_out("PHUN");
13DE:  MOVLW  16
13DF:  BSF    03.5
13E0:  MOVWF  56
13E1:  MOVLW  02
13E2:  MOVWF  57
13E3:  BCF    0A.4
13E4:  BSF    0A.3
13E5:  BCF    03.5
13E6:  CALL   248
13E7:  BSF    0A.4
13E8:  BCF    0A.3
13E9:  MOVLW  B1
13EA:  BSF    03.6
13EB:  MOVWF  0D
13EC:  MOVLW  00
13ED:  MOVWF  0F
13EE:  BCF    0A.4
13EF:  BSF    0A.3
13F0:  BCF    03.6
13F1:  CALL   281
13F2:  BSF    0A.4
13F3:  BCF    0A.3
....................    lcd_goto(8,1); lcd_out("ON");
13F4:  MOVLW  08
13F5:  BSF    03.5
13F6:  MOVWF  56
13F7:  MOVLW  01
13F8:  MOVWF  57
13F9:  BCF    0A.4
13FA:  BSF    0A.3
13FB:  BCF    03.5
13FC:  CALL   248
13FD:  BSF    0A.4
13FE:  BCF    0A.3
13FF:  MOVLW  B4
1400:  BSF    03.6
1401:  MOVWF  0D
1402:  MOVLW  00
1403:  MOVWF  0F
1404:  BCF    0A.4
1405:  BSF    0A.3
1406:  BCF    03.6
1407:  CALL   281
1408:  BSF    0A.4
1409:  BCF    0A.3
....................    lcd_goto(8,2); lcd_out("ON");
140A:  MOVLW  08
140B:  BSF    03.5
140C:  MOVWF  56
140D:  MOVLW  02
140E:  MOVWF  57
140F:  BCF    0A.4
1410:  BSF    0A.3
1411:  BCF    03.5
1412:  CALL   248
1413:  BSF    0A.4
1414:  BCF    0A.3
1415:  MOVLW  B6
1416:  BSF    03.6
1417:  MOVWF  0D
1418:  MOVLW  00
1419:  MOVWF  0F
141A:  BCF    0A.4
141B:  BSF    0A.3
141C:  BCF    03.6
141D:  CALL   281
141E:  BSF    0A.4
141F:  BCF    0A.3
....................    lcd_goto(28,1);lcd_out("ON"); 
1420:  MOVLW  1C
1421:  BSF    03.5
1422:  MOVWF  56
1423:  MOVLW  01
1424:  MOVWF  57
1425:  BCF    0A.4
1426:  BSF    0A.3
1427:  BCF    03.5
1428:  CALL   248
1429:  BSF    0A.4
142A:  BCF    0A.3
142B:  MOVLW  B8
142C:  BSF    03.6
142D:  MOVWF  0D
142E:  MOVLW  00
142F:  MOVWF  0F
1430:  BCF    0A.4
1431:  BSF    0A.3
1432:  BCF    03.6
1433:  CALL   281
1434:  BSF    0A.4
1435:  BCF    0A.3
....................    lcd_goto(28,2);lcd_out("ON");
1436:  MOVLW  1C
1437:  BSF    03.5
1438:  MOVWF  56
1439:  MOVLW  02
143A:  MOVWF  57
143B:  BCF    0A.4
143C:  BSF    0A.3
143D:  BCF    03.5
143E:  CALL   248
143F:  BSF    0A.4
1440:  BCF    0A.3
1441:  MOVLW  BA
1442:  BSF    03.6
1443:  MOVWF  0D
1444:  MOVLW  00
1445:  MOVWF  0F
1446:  BCF    0A.4
1447:  BSF    0A.3
1448:  BCF    03.6
1449:  CALL   281
144A:  BSF    0A.4
144B:  BCF    0A.3
....................    lcd_goto(13,1); lcd_out("OFF");
144C:  MOVLW  0D
144D:  BSF    03.5
144E:  MOVWF  56
144F:  MOVLW  01
1450:  MOVWF  57
1451:  BCF    0A.4
1452:  BSF    0A.3
1453:  BCF    03.5
1454:  CALL   248
1455:  BSF    0A.4
1456:  BCF    0A.3
1457:  MOVLW  BC
1458:  BSF    03.6
1459:  MOVWF  0D
145A:  MOVLW  00
145B:  MOVWF  0F
145C:  BCF    0A.4
145D:  BSF    0A.3
145E:  BCF    03.6
145F:  CALL   281
1460:  BSF    0A.4
1461:  BCF    0A.3
....................    lcd_goto(13,2); lcd_out("OFF");
1462:  MOVLW  0D
1463:  BSF    03.5
1464:  MOVWF  56
1465:  MOVLW  02
1466:  MOVWF  57
1467:  BCF    0A.4
1468:  BSF    0A.3
1469:  BCF    03.5
146A:  CALL   248
146B:  BSF    0A.4
146C:  BCF    0A.3
146D:  MOVLW  BE
146E:  BSF    03.6
146F:  MOVWF  0D
1470:  MOVLW  00
1471:  MOVWF  0F
1472:  BCF    0A.4
1473:  BSF    0A.3
1474:  BCF    03.6
1475:  CALL   281
1476:  BSF    0A.4
1477:  BCF    0A.3
....................    lcd_goto(33,1);lcd_out("OFF"); 
1478:  MOVLW  21
1479:  BSF    03.5
147A:  MOVWF  56
147B:  MOVLW  01
147C:  MOVWF  57
147D:  BCF    0A.4
147E:  BSF    0A.3
147F:  BCF    03.5
1480:  CALL   248
1481:  BSF    0A.4
1482:  BCF    0A.3
1483:  MOVLW  C0
1484:  BSF    03.6
1485:  MOVWF  0D
1486:  MOVLW  00
1487:  MOVWF  0F
1488:  BCF    0A.4
1489:  BSF    0A.3
148A:  BCF    03.6
148B:  CALL   281
148C:  BSF    0A.4
148D:  BCF    0A.3
....................    lcd_goto(33,2);lcd_out("OFF");
148E:  MOVLW  21
148F:  BSF    03.5
1490:  MOVWF  56
1491:  MOVLW  02
1492:  MOVWF  57
1493:  BCF    0A.4
1494:  BSF    0A.3
1495:  BCF    03.5
1496:  CALL   248
1497:  BSF    0A.4
1498:  BCF    0A.3
1499:  MOVLW  C2
149A:  BSF    03.6
149B:  MOVWF  0D
149C:  MOVLW  00
149D:  MOVWF  0F
149E:  BCF    0A.4
149F:  BSF    0A.3
14A0:  BCF    03.6
14A1:  CALL   281
14A2:  BSF    0A.4
14A3:  BCF    0A.3
.................... }
.................... 
.................... void pos_auto_2()
.................... {
....................    lcd_goto(9,2);
*
14B5:  MOVLW  09
14B6:  BSF    03.5
14B7:  MOVWF  56
14B8:  MOVLW  02
14B9:  MOVWF  57
14BA:  BCF    0A.4
14BB:  BSF    0A.3
14BC:  BCF    03.5
14BD:  CALL   248
14BE:  BSF    0A.4
14BF:  BCF    0A.3
....................    lcd_out("Auto");
14C0:  MOVLW  C4
14C1:  BSF    03.6
14C2:  MOVWF  0D
14C3:  MOVLW  00
14C4:  MOVWF  0F
14C5:  BCF    0A.4
14C6:  BSF    0A.3
14C7:  BCF    03.6
14C8:  CALL   281
14C9:  BSF    0A.4
14CA:  BCF    0A.3
....................    lcd_goto(27,1);
14CB:  MOVLW  1B
14CC:  BSF    03.5
14CD:  MOVWF  56
14CE:  MOVLW  01
14CF:  MOVWF  57
14D0:  BCF    0A.4
14D1:  BSF    0A.3
14D2:  BCF    03.5
14D3:  CALL   248
14D4:  BSF    0A.4
14D5:  BCF    0A.3
....................    lcd_out("Running");
14D6:  MOVLW  C7
14D7:  BSF    03.6
14D8:  MOVWF  0D
14D9:  MOVLW  00
14DA:  MOVWF  0F
14DB:  BCF    0A.4
14DC:  BSF    0A.3
14DD:  BCF    03.6
14DE:  CALL   281
14DF:  BSF    0A.4
14E0:  BCF    0A.3
.................... }
.................... 
.................... void pos_tmr_2()
.................... {  
....................     ds1307_read();                       // Read data from DS1307 RTCC
*
14F2:  CALL   1FD
....................     alarm_check();                       // Check if there is an alarm
....................     ds1307_display();                    // Diaplay time and calendar
*
1552:  BCF    03.5
1553:  CALL   299
....................     alarm_display();                     // Display alarms
....................     delay_ms(50); 
*
15F8:  MOVLW  32
15F9:  BSF    03.6
15FA:  MOVWF  6A
15FB:  BCF    0A.4
15FC:  BCF    03.6
15FD:  CALL   10D
15FE:  BSF    0A.4
.................... }
.................... 
.................... int choice_mode(unsigned int8 pos_go,pos_x,pos)
*
1035:  BSF    03.5
1036:  MOVF   55,W
1037:  MOVWF  56
.................... {
....................    unsigned int8 mode = pos;
....................    if(pos_go==1)
1038:  DECFSZ 53,W
1039:  GOTO   055
....................    {
....................       switch(pos_y)
103A:  MOVF   50,W
103B:  XORLW  01
103C:  BCF    03.5
103D:  BTFSC  03.2
103E:  GOTO   046
103F:  XORLW  03
1040:  BTFSC  03.2
1041:  GOTO   04B
1042:  XORLW  01
1043:  BTFSC  03.2
1044:  GOTO   050
1045:  GOTO   054
....................       {
....................          case 1:
....................             mode=1;
1046:  MOVLW  01
1047:  BSF    03.5
1048:  MOVWF  56
....................             break;
1049:  BCF    03.5
104A:  GOTO   054
....................          case 2:
....................             mode=2;
104B:  MOVLW  02
104C:  BSF    03.5
104D:  MOVWF  56
....................             break;
104E:  BCF    03.5
104F:  GOTO   054
....................          case 3:
....................             mode=3;
1050:  MOVLW  03
1051:  BSF    03.5
1052:  MOVWF  56
....................             break;   
1053:  BCF    03.5
1054:  BSF    03.5
....................       }
....................    }
....................    
....................    return mode;
1055:  MOVF   56,W
1056:  MOVWF  78
1057:  BCF    03.5
1058:  BSF    0A.3
1059:  BSF    0A.4
105A:  GOTO   239 (RETURN)
.................... }
.................... 
.................... void pos_current(unsigned int8 mode,pos_go)
.................... {
....................    if(mode==1)
*
138F:  BSF    03.5
1390:  DECFSZ 53,W
1391:  GOTO   4A6
....................    {
....................       switch (pos_go)
1392:  MOVF   54,W
1393:  XORLW  01
1394:  BCF    03.5
1395:  BTFSC  03.2
1396:  GOTO   39B
1397:  XORLW  03
1398:  BTFSC  03.2
1399:  GOTO   39D
139A:  GOTO   4A4
....................       {
....................          case 1:
....................             mode_ON();
139B:  CALL   1BB
....................             break;
139C:  GOTO   4A4
....................          case 2:  
....................             pos_relay_2();
....................             break;
....................       }
....................    }
*
14A4:  GOTO   5FF
14A5:  BSF    03.5
....................    else if(mode==2)
14A6:  MOVF   53,W
14A7:  SUBLW  02
14A8:  BTFSS  03.2
14A9:  GOTO   4E3
....................    {
....................       switch (pos_go)
14AA:  MOVF   54,W
14AB:  XORLW  01
14AC:  BCF    03.5
14AD:  BTFSC  03.2
14AE:  GOTO   4B3
14AF:  XORLW  03
14B0:  BTFSC  03.2
14B1:  GOTO   4B5
14B2:  GOTO   4E1
....................       {
....................          case 1:
....................             mode_ON();
14B3:  CALL   1BB
....................             break;
14B4:  GOTO   4E1
....................          case 2: 
....................             pos_auto_2();
....................             break;
....................       }
....................    }
*
14E1:  GOTO   5FF
14E2:  BSF    03.5
....................    else if(mode==3)
14E3:  MOVF   53,W
14E4:  SUBLW  03
14E5:  BTFSS  03.2
14E6:  GOTO   600
....................    {
....................       switch (pos_go)
14E7:  MOVF   54,W
14E8:  XORLW  01
14E9:  BCF    03.5
14EA:  BTFSC  03.2
14EB:  GOTO   4F0
14EC:  XORLW  03
14ED:  BTFSC  03.2
14EE:  GOTO   4F2
14EF:  GOTO   5FF
....................       {
....................          case 1:
....................             mode_ON();
14F0:  CALL   1BB
....................             break;
14F1:  GOTO   5FF
....................          case 2: 
....................             pos_tmr_2();
....................             break;
*
15FF:  BSF    03.5
....................         
....................       }
....................    }
1600:  BCF    03.5
1601:  BSF    0A.3
1602:  BSF    0A.4
1603:  GOTO   24F (RETURN)
.................... 
.................... }
.................... 
.................... 
.................... void mode_OFF()
.................... {  
....................   
....................     if(pos_go == 1){
*
0C37:  BSF    03.5
0C38:  DECFSZ 51,W
0C39:  GOTO   449
....................     lcd_goto(21,1);
0C3A:  MOVLW  15
0C3B:  MOVWF  56
0C3C:  MOVLW  01
0C3D:  MOVWF  57
0C3E:  BCF    03.5
0C3F:  CALL   248
....................     lcd_out("MODE:NONE");
0C40:  MOVLW  CB
0C41:  BSF    03.6
0C42:  MOVWF  0D
0C43:  MOVLW  00
0C44:  MOVWF  0F
0C45:  BCF    03.6
0C46:  CALL   281
....................     } 
0C47:  GOTO   473
0C48:  BSF    03.5
....................     else if((pos_go==2) && (pos==1 )) {    
0C49:  MOVF   51,W
0C4A:  SUBLW  02
0C4B:  BTFSS  03.2
0C4C:  GOTO   45E
0C4D:  DECFSZ 52,W
0C4E:  GOTO   45E
....................          lcd_goto(26,1);
0C4F:  MOVLW  1A
0C50:  MOVWF  56
0C51:  MOVLW  01
0C52:  MOVWF  57
0C53:  BCF    03.5
0C54:  CALL   248
....................          lcd_out("MODE:MANUAL");
0C55:  MOVLW  D0
0C56:  BSF    03.6
0C57:  MOVWF  0D
0C58:  MOVLW  00
0C59:  MOVWF  0F
0C5A:  BCF    03.6
0C5B:  CALL   281
....................     }else if ((pos_go==2) && (pos==2)){
0C5C:  GOTO   473
0C5D:  BSF    03.5
0C5E:  MOVF   51,W
0C5F:  SUBLW  02
0C60:  BTFSS  03.2
0C61:  GOTO   474
0C62:  MOVF   52,W
0C63:  SUBLW  02
0C64:  BTFSS  03.2
0C65:  GOTO   474
....................          lcd_goto(26,1);
0C66:  MOVLW  1A
0C67:  MOVWF  56
0C68:  MOVLW  01
0C69:  MOVWF  57
0C6A:  BCF    03.5
0C6B:  CALL   248
....................          lcd_out("MODE:AUTO");        
0C6C:  MOVLW  D6
0C6D:  BSF    03.6
0C6E:  MOVWF  0D
0C6F:  MOVLW  00
0C70:  MOVWF  0F
0C71:  BCF    03.6
0C72:  CALL   281
0C73:  BSF    03.5
....................     }
....................     
....................     
....................    lcd_goto(1, 1);                     // Go to column 1 row 1
0C74:  MOVLW  01
0C75:  MOVWF  56
0C76:  MOVWF  57
0C77:  BCF    03.5
0C78:  CALL   248
....................    printf(lcd_out,"Temp = %u",t);           // Display message1
0C79:  MOVLW  DB
0C7A:  BSF    03.6
0C7B:  MOVWF  0D
0C7C:  MOVLW  00
0C7D:  MOVWF  0F
0C7E:  BCF    03.0
0C7F:  MOVLW  07
0C80:  BSF    03.5
0C81:  BCF    03.6
0C82:  MOVWF  53
0C83:  BCF    03.5
0C84:  CALL   2F9
0C85:  MOVF   2B,W
0C86:  BSF    03.5
0C87:  MOVWF  56
0C88:  MOVLW  1B
0C89:  MOVWF  57
0C8A:  BCF    03.5
0C8B:  CALL   377
....................    lcd_goto(1, 2);                     // Go to column 1 row 2
0C8C:  MOVLW  01
0C8D:  BSF    03.5
0C8E:  MOVWF  56
0C8F:  MOVLW  02
0C90:  MOVWF  57
0C91:  BCF    03.5
0C92:  CALL   248
....................    printf(lcd_out,"Humid = %u",h);           // Display message2
0C93:  MOVLW  E0
0C94:  BSF    03.6
0C95:  MOVWF  0D
0C96:  MOVLW  00
0C97:  MOVWF  0F
0C98:  BCF    03.0
0C99:  MOVLW  08
0C9A:  BSF    03.5
0C9B:  BCF    03.6
0C9C:  MOVWF  53
0C9D:  BCF    03.5
0C9E:  CALL   2F9
0C9F:  MOVF   2D,W
0CA0:  BSF    03.5
0CA1:  MOVWF  56
0CA2:  MOVLW  1B
0CA3:  MOVWF  57
0CA4:  BCF    03.5
0CA5:  CALL   377
....................    lcd_goto(12, 1);
0CA6:  MOVLW  0C
0CA7:  BSF    03.5
0CA8:  MOVWF  56
0CA9:  MOVLW  01
0CAA:  MOVWF  57
0CAB:  BCF    03.5
0CAC:  CALL   248
....................    printf(lcd_out,"W = %u", w);
0CAD:  MOVLW  E6
0CAE:  BSF    03.6
0CAF:  MOVWF  0D
0CB0:  MOVLW  00
0CB1:  MOVWF  0F
0CB2:  BCF    03.0
0CB3:  MOVLW  04
0CB4:  BSF    03.5
0CB5:  BCF    03.6
0CB6:  MOVWF  53
0CB7:  BCF    03.5
0CB8:  CALL   2F9
0CB9:  MOVF   32,W
0CBA:  BSF    03.5
0CBB:  MOVWF  56
0CBC:  MOVLW  1B
0CBD:  MOVWF  57
0CBE:  BCF    03.5
0CBF:  CALL   377
....................    lcd_goto(12, 2);  
0CC0:  MOVLW  0C
0CC1:  BSF    03.5
0CC2:  MOVWF  56
0CC3:  MOVLW  02
0CC4:  MOVWF  57
0CC5:  BCF    03.5
0CC6:  CALL   248
....................    printf(lcd_out,"L = %05lu", lux);
0CC7:  MOVLW  EA
0CC8:  BSF    03.6
0CC9:  MOVWF  0D
0CCA:  MOVLW  00
0CCB:  MOVWF  0F
0CCC:  BCF    03.0
0CCD:  MOVLW  04
0CCE:  BSF    03.5
0CCF:  BCF    03.6
0CD0:  MOVWF  53
0CD1:  BCF    03.5
0CD2:  CALL   2F9
0CD3:  MOVLW  08
0CD4:  MOVWF  04
0CD5:  MOVF   34,W
0CD6:  BSF    03.5
0CD7:  MOVWF  54
0CD8:  BCF    03.5
0CD9:  MOVF   33,W
0CDA:  BSF    03.5
0CDB:  MOVWF  53
....................    //%05lu
....................    lcd_goto(21,2);
*
0D42:  MOVLW  15
0D43:  MOVWF  56
0D44:  MOVLW  02
0D45:  MOVWF  57
0D46:  BCF    03.5
0D47:  CALL   248
....................    printf(lcd_out,"Q:%d D:%d B:%d P:%d", q,d,b,p);
0D48:  MOVLW  00
0D49:  BTFSC  21.2
0D4A:  MOVLW  01
0D4B:  BSF    03.5
0D4C:  MOVWF  53
0D4D:  MOVLW  00
0D4E:  BCF    03.5
0D4F:  BTFSC  21.3
0D50:  MOVLW  01
0D51:  BSF    03.5
0D52:  MOVWF  54
0D53:  MOVLW  00
0D54:  BCF    03.5
0D55:  BTFSC  21.4
0D56:  MOVLW  01
0D57:  BSF    03.5
0D58:  MOVWF  55
0D59:  MOVLW  00
0D5A:  BCF    03.5
0D5B:  BTFSC  21.5
0D5C:  MOVLW  01
0D5D:  BSF    03.5
0D5E:  MOVWF  56
0D5F:  MOVLW  51
0D60:  MOVWF  5D
0D61:  BCF    0A.3
0D62:  BCF    03.5
0D63:  CALL   7E6
0D64:  BSF    0A.3
0D65:  MOVLW  3A
0D66:  BSF    03.5
0D67:  MOVWF  5D
0D68:  BCF    0A.3
0D69:  BCF    03.5
0D6A:  CALL   7E6
0D6B:  BSF    0A.3
0D6C:  BSF    03.5
0D6D:  MOVF   53,W
0D6E:  MOVWF  57
0D6F:  MOVLW  18
0D70:  MOVWF  58
0D71:  BCF    03.5
0D72:  CALL   3C4
0D73:  MOVLW  20
0D74:  BSF    03.5
0D75:  MOVWF  5D
0D76:  BCF    0A.3
0D77:  BCF    03.5
0D78:  CALL   7E6
0D79:  BSF    0A.3
0D7A:  MOVLW  44
0D7B:  BSF    03.5
0D7C:  MOVWF  5D
0D7D:  BCF    0A.3
0D7E:  BCF    03.5
0D7F:  CALL   7E6
0D80:  BSF    0A.3
0D81:  MOVLW  3A
0D82:  BSF    03.5
0D83:  MOVWF  5D
0D84:  BCF    0A.3
0D85:  BCF    03.5
0D86:  CALL   7E6
0D87:  BSF    0A.3
0D88:  BSF    03.5
0D89:  MOVF   54,W
0D8A:  MOVWF  57
0D8B:  MOVLW  18
0D8C:  MOVWF  58
0D8D:  BCF    03.5
0D8E:  CALL   3C4
0D8F:  MOVLW  20
0D90:  BSF    03.5
0D91:  MOVWF  5D
0D92:  BCF    0A.3
0D93:  BCF    03.5
0D94:  CALL   7E6
0D95:  BSF    0A.3
0D96:  MOVLW  42
0D97:  BSF    03.5
0D98:  MOVWF  5D
0D99:  BCF    0A.3
0D9A:  BCF    03.5
0D9B:  CALL   7E6
0D9C:  BSF    0A.3
0D9D:  MOVLW  3A
0D9E:  BSF    03.5
0D9F:  MOVWF  5D
0DA0:  BCF    0A.3
0DA1:  BCF    03.5
0DA2:  CALL   7E6
0DA3:  BSF    0A.3
0DA4:  BSF    03.5
0DA5:  MOVF   55,W
0DA6:  MOVWF  57
0DA7:  MOVLW  18
0DA8:  MOVWF  58
0DA9:  BCF    03.5
0DAA:  CALL   3C4
0DAB:  MOVLW  20
0DAC:  BSF    03.5
0DAD:  MOVWF  5D
0DAE:  BCF    0A.3
0DAF:  BCF    03.5
0DB0:  CALL   7E6
0DB1:  BSF    0A.3
0DB2:  MOVLW  50
0DB3:  BSF    03.5
0DB4:  MOVWF  5D
0DB5:  BCF    0A.3
0DB6:  BCF    03.5
0DB7:  CALL   7E6
0DB8:  BSF    0A.3
0DB9:  MOVLW  3A
0DBA:  BSF    03.5
0DBB:  MOVWF  5D
0DBC:  BCF    0A.3
0DBD:  BCF    03.5
0DBE:  CALL   7E6
0DBF:  BSF    0A.3
0DC0:  BSF    03.5
0DC1:  MOVF   56,W
0DC2:  MOVWF  57
0DC3:  MOVLW  18
0DC4:  MOVWF  58
0DC5:  BCF    03.5
0DC6:  CALL   3C4
0DC7:  BSF    0A.3
0DC8:  BSF    0A.4
0DC9:  GOTO   1F7 (RETURN)
....................    
.................... 
.................... }
....................  
.................... void main() {
*
1800:  MOVF   03,W
1801:  ANDLW  1F
1802:  MOVWF  03
1803:  MOVLW  FF
1804:  MOVWF  20
1805:  BSF    20.3
1806:  MOVF   20,W
1807:  BSF    03.5
1808:  MOVWF  07
1809:  BCF    03.5
180A:  BSF    20.4
180B:  MOVF   20,W
180C:  BSF    03.5
180D:  MOVWF  07
180E:  MOVLW  31
180F:  MOVWF  13
1810:  MOVLW  28
1811:  BCF    03.5
1812:  MOVWF  14
1813:  BSF    03.5
1814:  BSF    14.7
1815:  BCF    14.6
1816:  MOVLW  08
1817:  BCF    03.5
1818:  MOVWF  23
1819:  CLRF   24
181A:  BSF    03.5
181B:  BSF    03.6
181C:  BSF    07.3
181D:  BCF    03.6
181E:  MOVWF  19
181F:  MOVLW  02
1820:  MOVWF  1A
1821:  MOVLW  A6
1822:  MOVWF  18
1823:  MOVLW  90
1824:  BCF    03.5
1825:  MOVWF  18
1826:  CLRF   34
1827:  CLRF   33
1828:  BCF    21.2
1829:  BCF    21.3
182A:  BCF    21.4
182B:  BCF    21.5
182C:  CLRF   58
182D:  CLRF   57
182E:  BSF    03.5
182F:  CLRF   49
1830:  CLRF   4A
1831:  CLRF   4B
1832:  CLRF   4C
1833:  MOVLW  01
1834:  MOVWF  4F
1835:  MOVWF  50
1836:  MOVWF  51
1837:  MOVWF  52
1838:  BCF    03.5
1839:  BCF    21.7
183A:  BSF    03.5
183B:  BSF    03.6
183C:  MOVF   09,W
183D:  ANDLW  C0
183E:  MOVWF  09
183F:  BCF    03.6
1840:  BCF    1F.4
1841:  BCF    1F.5
1842:  MOVLW  00
1843:  BSF    03.6
1844:  MOVWF  08
1845:  BCF    03.5
1846:  CLRF   07
1847:  CLRF   08
1848:  CLRF   09
1849:  BCF    03.7
.................... 
.................... 
....................    set_tris_B(0b00111111);
*
18F0:  MOVLW  3F
18F1:  MOVWF  06
....................    port_b_pullups(TRUE);                          // Enable PORTB internal pull-ups
18F2:  MOVLW  01
18F3:  MOVWF  15
18F4:  BCF    01.7
....................    
....................    setup_adc(ADC_CLOCK_DIV_32);      // Set ADC conversion time to 32Tosc
18F5:  BCF    03.5
18F6:  BCF    1F.6
18F7:  BSF    1F.7
18F8:  BSF    03.5
18F9:  BSF    1F.7
18FA:  BCF    03.5
18FB:  BSF    1F.0
....................    setup_adc_ports(SAN0);             // Configure AN0 as analog
18FC:  BSF    03.5
18FD:  BSF    03.6
18FE:  MOVF   09,W
18FF:  ANDLW  C0
1900:  MOVWF  09
1901:  BCF    03.6
1902:  BCF    1F.4
1903:  BCF    1F.5
1904:  MOVLW  01
1905:  BSF    03.6
1906:  MOVWF  08
....................    set_adc_channel(0);               // Select channel 0 input
1907:  MOVLW  00
1908:  MOVWF  78
1909:  BCF    03.5
190A:  BCF    03.6
190B:  MOVF   1F,W
190C:  ANDLW  C3
190D:  IORWF  78,W
190E:  MOVWF  1F
....................    delay_ms(50);                    // Wait 100ms
190F:  MOVLW  32
1910:  BSF    03.6
1911:  MOVWF  6A
1912:  BCF    0A.4
1913:  BCF    0A.3
1914:  BCF    03.6
1915:  CALL   10D
1916:  BSF    0A.4
1917:  BSF    0A.3
.................... 
....................    //enable_interrupts(INT_EXT_H2L);                // Enable external interrupt with edge from high to low 
....................    lcd_begin(0x4E);                 // Initialize LCD module with I2C address = 0x4E 
1918:  MOVLW  4E
1919:  BSF    03.5
191A:  MOVWF  53
191B:  BCF    0A.4
191C:  BCF    0A.3
191D:  BCF    03.5
191E:  GOTO   17F
191F:  BSF    0A.4
1920:  BSF    0A.3
....................    BH1750_init();
1921:  BCF    0A.4
1922:  BCF    0A.3
1923:  GOTO   204
1924:  BSF    0A.4
1925:  BSF    0A.3
....................    ENABLE_INTERRUPTS(INT_RDA); //cho phep ngat uart
1926:  BSF    03.5
1927:  BSF    0C.5
....................    ENABLE_INTERRUPTS(GLOBAL); //cho phep ngat toan cuc
1928:  MOVLW  C0
1929:  BCF    03.5
192A:  IORWF  0B,F
....................    ESP8266_init();
192B:  BCF    0A.4
192C:  BCF    0A.3
192D:  GOTO   2D6
192E:  BSF    0A.4
192F:  BSF    0A.3
....................  
....................  
....................   while(TRUE) {
....................         ConnectWithWebServer(); 
1930:  BCF    0A.4
1931:  BCF    0A.3
1932:  GOTO   455
1933:  BSF    0A.4
1934:  BSF    0A.3
....................         //web
....................             
....................         
....................         //web
....................         //readDHT();
....................         //dht test thu
....................              Time_out = 0;
1935:  BCF    21.1
....................              Start_signal();
1936:  BCF    0A.4
1937:  BCF    0A.3
1938:  GOTO   5FF
1939:  BSF    0A.4
193A:  BSF    0A.3
....................              if(check_response()){                     // If there is a response from sensor
193B:  BCF    0A.4
193C:  BCF    0A.3
193D:  GOTO   622
193E:  BSF    0A.4
193F:  BSF    0A.3
1940:  MOVF   78,F
1941:  BTFSC  03.2
1942:  GOTO   166
....................                h = Read_Data();                 // read RH byte1
1943:  BCF    0A.4
1944:  BCF    0A.3
1945:  CALL   642
1946:  BSF    0A.4
1947:  BSF    0A.3
1948:  MOVF   78,W
1949:  MOVWF  2D
....................                RH_byte2 = Read_Data();                 // read RH byte2
194A:  BCF    0A.4
194B:  BCF    0A.3
194C:  CALL   642
194D:  BSF    0A.4
194E:  BSF    0A.3
194F:  MOVF   78,W
1950:  MOVWF  2E
....................                t = Read_Data();                  // read T byte1
1951:  BCF    0A.4
1952:  BCF    0A.3
1953:  CALL   642
1954:  BSF    0A.4
1955:  BSF    0A.3
1956:  MOVF   78,W
1957:  MOVWF  2B
....................                T_byte2 = Read_Data();                  // read T byte2
1958:  BCF    0A.4
1959:  BCF    0A.3
195A:  CALL   642
195B:  BSF    0A.4
195C:  BSF    0A.3
195D:  MOVF   78,W
195E:  MOVWF  2C
....................                Checksum = Read_Data();                 // read checksum
195F:  BCF    0A.4
1960:  BCF    0A.3
1961:  CALL   642
1962:  BSF    0A.4
1963:  BSF    0A.3
1964:  MOVF   78,W
1965:  MOVWF  2F
....................              }
....................         //dht
....................         adc_value = read_adc();
1966:  BSF    1F.1
1967:  BTFSC  1F.1
1968:  GOTO   167
1969:  MOVF   1E,W
196A:  MOVWF  79
196B:  BSF    03.5
196C:  MOVF   1E,W
196D:  MOVWF  78
196E:  MOVF   79,W
196F:  BCF    03.5
1970:  MOVWF  31
1971:  MOVF   78,W
1972:  MOVWF  30
....................         w = 100-(adc_value*100.00)/1023.00;
1973:  MOVF   31,W
1974:  BSF    03.5
1975:  MOVWF  54
1976:  BCF    03.5
1977:  MOVF   30,W
1978:  BSF    03.5
1979:  MOVWF  53
197A:  BCF    0A.4
197B:  BCF    0A.3
197C:  BCF    03.5
197D:  GOTO   6B2
197E:  BSF    0A.4
197F:  BSF    0A.3
1980:  MOVF   7A,W
1981:  BSF    03.5
1982:  MOVWF  56
1983:  MOVF   79,W
1984:  MOVWF  55
1985:  MOVF   78,W
1986:  MOVWF  54
1987:  MOVF   77,W
1988:  MOVWF  53
1989:  CLRF   5A
198A:  CLRF   59
198B:  MOVLW  48
198C:  MOVWF  58
198D:  MOVLW  85
198E:  MOVWF  57
198F:  BCF    0A.4
1990:  BCF    0A.3
1991:  BCF    03.5
1992:  GOTO   6D3
1993:  BSF    0A.4
1994:  BSF    0A.3
1995:  MOVF   7A,W
1996:  BSF    03.5
1997:  MOVWF  56
1998:  MOVF   79,W
1999:  MOVWF  55
199A:  MOVF   78,W
199B:  MOVWF  54
199C:  MOVF   77,W
199D:  MOVWF  53
199E:  MOVF   56,W
199F:  MOVWF  5A
19A0:  MOVF   55,W
19A1:  MOVWF  59
19A2:  MOVF   54,W
19A3:  MOVWF  58
19A4:  MOVF   53,W
19A5:  MOVWF  57
19A6:  CLRF   5E
19A7:  MOVLW  C0
19A8:  MOVWF  5D
19A9:  MOVLW  7F
19AA:  MOVWF  5C
19AB:  MOVLW  88
19AC:  MOVWF  5B
19AD:  BCF    0A.4
19AE:  BCF    03.5
19AF:  GOTO   000
19B0:  BSF    0A.4
19B1:  BSF    03.1
19B2:  BSF    03.5
19B3:  CLRF   56
19B4:  CLRF   55
19B5:  MOVLW  48
19B6:  MOVWF  54
19B7:  MOVLW  85
19B8:  MOVWF  53
19B9:  MOVF   7A,W
19BA:  MOVWF  5A
19BB:  MOVF   79,W
19BC:  MOVWF  59
19BD:  MOVF   78,W
19BE:  MOVWF  58
19BF:  MOVF   77,W
19C0:  MOVWF  57
19C1:  BCF    0A.4
19C2:  BCF    03.5
19C3:  GOTO   0CF
19C4:  BSF    0A.4
19C5:  MOVF   7A,W
19C6:  BSF    03.5
19C7:  MOVWF  56
19C8:  MOVF   79,W
19C9:  MOVWF  55
19CA:  MOVF   78,W
19CB:  MOVWF  54
19CC:  MOVF   77,W
19CD:  MOVWF  53
19CE:  BCF    0A.4
19CF:  BCF    0A.3
19D0:  BCF    03.5
19D1:  GOTO   74C
19D2:  BSF    0A.4
19D3:  BSF    0A.3
19D4:  MOVF   78,W
19D5:  MOVWF  32
....................         lux = get_lux_value(cont_H_res_mode1, 180); 
19D6:  MOVLW  10
19D7:  BSF    03.5
19D8:  MOVWF  53
19D9:  CLRF   55
19DA:  MOVLW  B4
19DB:  MOVWF  54
19DC:  BCF    0A.4
19DD:  BCF    0A.3
19DE:  BCF    03.5
19DF:  GOTO   77F
19E0:  BSF    0A.4
19E1:  BSF    0A.3
19E2:  MOVF   79,W
19E3:  MOVWF  34
19E4:  MOVF   78,W
19E5:  MOVWF  33
....................         
....................    
....................       status = phim_ONOFF(status);
19E6:  MOVLW  00
19E7:  BTFSC  21.7
19E8:  MOVLW  01
19E9:  BSF    03.5
19EA:  MOVWF  53
19EB:  MOVWF  54
19EC:  BCF    0A.4
19ED:  BCF    03.5
19EE:  GOTO   217
19EF:  BSF    0A.4
19F0:  BCF    21.7
19F1:  BTFSC  78.0
19F2:  BSF    21.7
....................       
....................       if(status==0) {
19F3:  BTFSC  21.7
19F4:  GOTO   1F9
....................             mode_OFF();}
19F5:  BCF    0A.4
19F6:  GOTO   437
19F7:  BSF    0A.4
19F8:  GOTO   250
....................      
....................       else
....................       {
....................          pos_go = phim_GO(pos_go);
19F9:  BSF    03.5
19FA:  MOVF   51,W
19FB:  MOVWF  53
19FC:  BCF    0A.4
19FD:  BCF    03.5
19FE:  GOTO   5CA
19FF:  BSF    0A.4
1A00:  MOVF   78,W
1A01:  BSF    03.5
1A02:  MOVWF  51
....................          pos_go = phim_BACK(pos_go);
1A03:  MOVF   51,W
1A04:  MOVWF  53
1A05:  BCF    0A.4
1A06:  BCF    03.5
1A07:  GOTO   668
1A08:  BSF    0A.4
1A09:  MOVF   78,W
1A0A:  BSF    03.5
1A0B:  MOVWF  51
....................          pos_x = phim_LEFT(pos_x);
1A0C:  MOVF   4F,W
1A0D:  MOVWF  53
1A0E:  BCF    0A.4
1A0F:  BCF    03.5
1A10:  GOTO   77C
1A11:  BSF    0A.4
1A12:  MOVF   78,W
1A13:  BSF    03.5
1A14:  MOVWF  4F
....................          pos_x = phim_RIGHT(pos_x);
1A15:  MOVF   4F,W
1A16:  MOVWF  53
1A17:  BCF    0A.4
1A18:  BCF    03.5
1A19:  GOTO   7A2
1A1A:  BSF    0A.4
1A1B:  MOVF   78,W
1A1C:  BSF    03.5
1A1D:  MOVWF  4F
....................          pos_y = phim_UP(pos_y);
1A1E:  MOVF   50,W
1A1F:  MOVWF  53
1A20:  BCF    0A.4
1A21:  BCF    03.5
1A22:  GOTO   7CB
1A23:  BSF    0A.4
1A24:  MOVF   78,W
1A25:  BSF    03.5
1A26:  MOVWF  50
....................          pos_y = phim_DW(pos_y);
1A27:  MOVF   50,W
1A28:  MOVWF  53
1A29:  BCF    0A.3
1A2A:  BCF    03.5
1A2B:  GOTO   000
1A2C:  BSF    0A.3
1A2D:  MOVF   78,W
1A2E:  BSF    03.5
1A2F:  MOVWF  50
....................          pos = choice_mode(pos_go,pos_x,pos);
1A30:  MOVF   51,W
1A31:  MOVWF  53
1A32:  MOVF   4F,W
1A33:  MOVWF  54
1A34:  MOVF   52,W
1A35:  MOVWF  55
1A36:  BCF    0A.3
1A37:  BCF    03.5
1A38:  GOTO   035
1A39:  BSF    0A.3
1A3A:  MOVF   78,W
1A3B:  BSF    03.5
1A3C:  MOVWF  52
....................          pos_xy_current(pos_x,pos_y,pos);
1A3D:  MOVF   4F,W
1A3E:  MOVWF  53
1A3F:  MOVF   50,W
1A40:  MOVWF  54
1A41:  MOVF   52,W
1A42:  MOVWF  55
1A43:  BCF    0A.3
1A44:  BCF    03.5
1A45:  GOTO   05B
1A46:  BSF    0A.3
....................          pos_current(pos,pos_go); 
1A47:  BSF    03.5
1A48:  MOVF   52,W
1A49:  MOVWF  53
1A4A:  MOVF   51,W
1A4B:  MOVWF  54
1A4C:  BCF    0A.3
1A4D:  BCF    03.5
1A4E:  GOTO   38F
1A4F:  BSF    0A.3
....................       }
....................         if((pos_go == 2) && (pos == 2 )){
1A50:  BSF    03.5
1A51:  MOVF   51,W
1A52:  SUBLW  02
1A53:  BTFSS  03.2
1A54:  GOTO   295
1A55:  MOVF   52,W
1A56:  SUBLW  02
1A57:  BTFSS  03.2
1A58:  GOTO   295
....................               //Mode Auto
....................                    if( w < 55 ){
1A59:  BCF    03.5
1A5A:  MOVF   32,W
1A5B:  SUBLW  36
1A5C:  BTFSS  03.0
1A5D:  GOTO   264
....................                       output_high(BOMB); b=1;   
1A5E:  BSF    03.5
1A5F:  BCF    05.3
1A60:  BCF    03.5
1A61:  BSF    05.3
1A62:  BSF    21.4
....................                    }else {
1A63:  GOTO   269
....................                       output_low(BOMB); b=0;        
1A64:  BSF    03.5
1A65:  BCF    05.3
1A66:  BCF    03.5
1A67:  BCF    05.3
1A68:  BCF    21.4
....................                    }
....................           
....................                    if( t > 35){
1A69:  MOVF   2B,W
1A6A:  SUBLW  23
1A6B:  BTFSC  03.0
1A6C:  GOTO   278
....................                       {output_high(SPRAY); p=1;   
1A6D:  BSF    03.5
1A6E:  BCF    05.4
1A6F:  BCF    03.5
1A70:  BSF    05.4
1A71:  BSF    21.5
....................                        output_high(FAN);  q=1;}   
1A72:  BSF    03.5
1A73:  BCF    05.1
1A74:  BCF    03.5
1A75:  BSF    05.1
1A76:  BSF    21.2
....................                    }else {
1A77:  GOTO   282
....................                       {output_low(SPRAY); p=0;   
1A78:  BSF    03.5
1A79:  BCF    05.4
1A7A:  BCF    03.5
1A7B:  BCF    05.4
1A7C:  BCF    21.5
....................                       output_low(FAN);  q=0;}        
1A7D:  BSF    03.5
1A7E:  BCF    05.1
1A7F:  BCF    03.5
1A80:  BCF    05.1
1A81:  BCF    21.2
....................                    }
....................                    
....................                    if( lux < 30 ){
1A82:  MOVF   34,F
1A83:  BTFSS  03.2
1A84:  GOTO   28F
1A85:  MOVF   33,W
1A86:  SUBLW  1D
1A87:  BTFSS  03.0
1A88:  GOTO   28F
....................                       output_high(LED); d=1;   
1A89:  BSF    03.5
1A8A:  BCF    05.2
1A8B:  BCF    03.5
1A8C:  BSF    05.2
1A8D:  BSF    21.3
....................                    }else {
1A8E:  GOTO   294
....................                       output_low(LED); d=0;         
1A8F:  BSF    03.5
1A90:  BCF    05.2
1A91:  BCF    03.5
1A92:  BCF    05.2
1A93:  BCF    21.3
1A94:  BSF    03.5
....................                    }   
....................            
....................          }
....................         if((pos_go == 2) && (pos == 3 )){
1A95:  MOVF   51,W
1A96:  SUBLW  02
1A97:  BTFSS  03.2
1A98:  GOTO   5A4
1A99:  MOVF   52,W
1A9A:  SUBLW  03
1A9B:  BTFSS  03.2
1A9C:  GOTO   5A4
....................             //Mode Clock
....................               if(input(LEFT) && input(RIGHT)) button_state = 0;
1A9D:  BSF    06.1
1A9E:  BCF    03.5
1A9F:  BTFSS  06.1
1AA0:  GOTO   2A7
1AA1:  BSF    03.5
1AA2:  BSF    06.3
1AA3:  BCF    03.5
1AA4:  BTFSS  06.3
1AA5:  GOTO   2A7
1AA6:  BCF    21.6
....................               if(!input(LEFT) && (!button_state)){
1AA7:  BSF    03.5
1AA8:  BSF    06.1
1AA9:  BCF    03.5
1AAA:  BTFSC  06.1
1AAB:  GOTO   54F
1AAC:  BTFSC  21.6
1AAD:  GOTO   54F
....................                button_state = 1;
1AAE:  BSF    21.6
....................                // Convert BCD to decimal
....................                minute = minute + minute10 * 10;
1AAF:  MOVF   7C,W
1AB0:  BSF    03.5
1AB1:  MOVWF  58
1AB2:  MOVLW  0A
1AB3:  MOVWF  59
1AB4:  BCF    0A.3
1AB5:  BCF    03.5
1AB6:  CALL   253
1AB7:  BSF    0A.3
1AB8:  MOVF   78,W
1AB9:  ADDWF  7B,F
....................                hour = hour + hour10 * 10;
1ABA:  MOVF   7E,W
1ABB:  BSF    03.5
1ABC:  MOVWF  58
1ABD:  MOVLW  0A
1ABE:  MOVWF  59
1ABF:  BCF    0A.3
1AC0:  BCF    03.5
1AC1:  CALL   253
1AC2:  BSF    0A.3
1AC3:  MOVF   78,W
1AC4:  ADDWF  7D,F
....................                date = date + date10 * 10;
1AC5:  BSF    03.5
1AC6:  MOVF   43,W
1AC7:  MOVWF  58
1AC8:  MOVLW  0A
1AC9:  MOVWF  59
1ACA:  BCF    0A.3
1ACB:  BCF    03.5
1ACC:  CALL   253
1ACD:  BSF    0A.3
1ACE:  MOVF   78,W
1ACF:  BSF    03.5
1AD0:  ADDWF  42,F
....................                month = month + month10 * 10;
1AD1:  MOVF   45,W
1AD2:  MOVWF  58
1AD3:  MOVLW  0A
1AD4:  MOVWF  59
1AD5:  BCF    0A.3
1AD6:  BCF    03.5
1AD7:  CALL   253
1AD8:  BSF    0A.3
1AD9:  MOVF   78,W
1ADA:  BSF    03.5
1ADB:  ADDWF  44,F
....................                year = year + year10 * 10;
1ADC:  MOVF   47,W
1ADD:  MOVWF  58
1ADE:  MOVLW  0A
1ADF:  MOVWF  59
1AE0:  BCF    0A.3
1AE1:  BCF    03.5
1AE2:  CALL   253
1AE3:  BSF    0A.3
1AE4:  MOVF   78,W
1AE5:  BSF    03.5
1AE6:  ADDWF  46,F
....................                // End conversion
....................                i=1;
1AE7:  MOVLW  01
1AE8:  MOVWF  4D
....................                hour = edit(hour, 9, 1);
1AE9:  MOVF   7D,W
1AEA:  MOVWF  53
1AEB:  MOVLW  09
1AEC:  MOVWF  54
1AED:  MOVLW  01
1AEE:  MOVWF  55
1AEF:  BCF    0A.3
1AF0:  BCF    03.5
1AF1:  CALL   604
1AF2:  BSF    0A.3
1AF3:  MOVF   78,W
1AF4:  MOVWF  7D
....................                i=2;
1AF5:  MOVLW  02
1AF6:  BSF    03.5
1AF7:  MOVWF  4D
....................                minute = edit(minute, 12, 1);
1AF8:  MOVF   7B,W
1AF9:  MOVWF  53
1AFA:  MOVLW  0C
1AFB:  MOVWF  54
1AFC:  MOVLW  01
1AFD:  MOVWF  55
1AFE:  BCF    0A.3
1AFF:  BCF    03.5
1B00:  CALL   604
1B01:  BSF    0A.3
1B02:  MOVF   78,W
1B03:  MOVWF  7B
....................                while(TRUE){
....................                  if(input(LEFT)) 
1B04:  BSF    03.5
1B05:  BSF    06.1
1B06:  BCF    03.5
1B07:  BTFSS  06.1
1B08:  GOTO   30A
....................                    button_state = 0;
1B09:  BCF    21.6
....................                  while(!input(UP)){
1B0A:  BSF    03.5
1B0B:  BSF    06.0
1B0C:  BCF    03.5
1B0D:  BTFSC  06.0
1B0E:  GOTO   381
....................                    day++;
1B0F:  BSF    03.5
1B10:  INCF   48,F
....................                    if(day > 7)
1B11:  MOVF   48,W
1B12:  SUBLW  07
1B13:  BTFSC  03.0
1B14:  GOTO   317
....................                      day = 1;
1B15:  MOVLW  01
1B16:  MOVWF  48
....................                    lcd_goto(6, 2);                  // Go to column 6 row 2
1B17:  MOVLW  06
1B18:  MOVWF  56
1B19:  MOVLW  02
1B1A:  MOVWF  57
1B1B:  BCF    0A.4
1B1C:  BCF    03.5
1B1D:  CALL   248
1B1E:  BSF    0A.4
....................                    switch(day){
1B1F:  MOVLW  01
1B20:  BSF    03.5
1B21:  SUBWF  48,W
1B22:  ADDLW  F9
1B23:  BTFSC  03.0
1B24:  GOTO   376
1B25:  ADDLW  07
1B26:  BCF    03.5
1B27:  GOTO   5A7
....................                      case 1: lcd_out("Su"); break;
1B28:  MOVLW  EF
1B29:  BSF    03.6
1B2A:  MOVWF  0D
1B2B:  MOVLW  00
1B2C:  MOVWF  0F
1B2D:  BCF    0A.4
1B2E:  BCF    03.6
1B2F:  CALL   281
1B30:  BSF    0A.4
1B31:  BSF    03.5
1B32:  GOTO   376
....................                      case 2: lcd_out("Mo"); break;
1B33:  MOVLW  F1
1B34:  BSF    03.6
1B35:  MOVWF  0D
1B36:  MOVLW  00
1B37:  MOVWF  0F
1B38:  BCF    0A.4
1B39:  BCF    03.6
1B3A:  CALL   281
1B3B:  BSF    0A.4
1B3C:  BSF    03.5
1B3D:  GOTO   376
....................                      case 3: lcd_out("Tu"); break;
1B3E:  MOVLW  F3
1B3F:  BSF    03.6
1B40:  MOVWF  0D
1B41:  MOVLW  00
1B42:  MOVWF  0F
1B43:  BCF    0A.4
1B44:  BCF    03.6
1B45:  CALL   281
1B46:  BSF    0A.4
1B47:  BSF    03.5
1B48:  GOTO   376
....................                      case 4: lcd_out("We"); break;
1B49:  MOVLW  F5
1B4A:  BSF    03.6
1B4B:  MOVWF  0D
1B4C:  MOVLW  00
1B4D:  MOVWF  0F
1B4E:  BCF    0A.4
1B4F:  BCF    03.6
1B50:  CALL   281
1B51:  BSF    0A.4
1B52:  BSF    03.5
1B53:  GOTO   376
....................                      case 5: lcd_out("Th"); break;
1B54:  MOVLW  F7
1B55:  BSF    03.6
1B56:  MOVWF  0D
1B57:  MOVLW  00
1B58:  MOVWF  0F
1B59:  BCF    0A.4
1B5A:  BCF    03.6
1B5B:  CALL   281
1B5C:  BSF    0A.4
1B5D:  BSF    03.5
1B5E:  GOTO   376
....................                      case 6: lcd_out("Fr"); break;
1B5F:  MOVLW  F9
1B60:  BSF    03.6
1B61:  MOVWF  0D
1B62:  MOVLW  00
1B63:  MOVWF  0F
1B64:  BCF    0A.4
1B65:  BCF    03.6
1B66:  CALL   281
1B67:  BSF    0A.4
1B68:  BSF    03.5
1B69:  GOTO   376
....................                      case 7: lcd_out("Sa"); break;}
1B6A:  MOVLW  FB
1B6B:  BSF    03.6
1B6C:  MOVWF  0D
1B6D:  MOVLW  00
1B6E:  MOVWF  0F
1B6F:  BCF    0A.4
1B70:  BCF    03.6
1B71:  CALL   281
1B72:  BSF    0A.4
1B73:  BSF    03.5
1B74:  GOTO   376
1B75:  BSF    03.5
....................                    delay_ms(200);
1B76:  MOVLW  C8
1B77:  BCF    03.5
1B78:  BSF    03.6
1B79:  MOVWF  6A
1B7A:  BCF    0A.4
1B7B:  BCF    0A.3
1B7C:  BCF    03.6
1B7D:  CALL   10D
1B7E:  BSF    0A.4
1B7F:  BSF    0A.3
1B80:  GOTO   30A
....................                  }
....................                  lcd_goto(6, 2);
1B81:  MOVLW  06
1B82:  BSF    03.5
1B83:  MOVWF  56
1B84:  MOVLW  02
1B85:  MOVWF  57
1B86:  BCF    0A.4
1B87:  BCF    03.5
1B88:  CALL   248
1B89:  BSF    0A.4
....................                  lcd_out("   ");
1B8A:  MOVLW  FD
1B8B:  BSF    03.6
1B8C:  MOVWF  0D
1B8D:  MOVLW  00
1B8E:  MOVWF  0F
1B8F:  BCF    0A.4
1B90:  BCF    03.6
1B91:  CALL   281
1B92:  BSF    0A.4
....................                  j = 0;
1B93:  BSF    03.5
1B94:  CLRF   4E
....................                  while((input(LEFT)||button_state) && input(UP) && j < 5){
1B95:  BSF    06.1
1B96:  BCF    03.5
1B97:  BTFSC  06.1
1B98:  GOTO   39B
1B99:  BTFSS  21.6
1B9A:  GOTO   3B5
1B9B:  BSF    03.5
1B9C:  BSF    06.0
1B9D:  BCF    03.5
1B9E:  BTFSS  06.0
1B9F:  GOTO   3B5
1BA0:  BSF    03.5
1BA1:  MOVF   4E,W
1BA2:  SUBLW  04
1BA3:  BTFSC  03.0
1BA4:  GOTO   3A7
1BA5:  BCF    03.5
1BA6:  GOTO   3B5
....................                    j++;
1BA7:  INCF   4E,F
....................                    delay_ms(200);}
1BA8:  MOVLW  C8
1BA9:  BCF    03.5
1BAA:  BSF    03.6
1BAB:  MOVWF  6A
1BAC:  BCF    0A.4
1BAD:  BCF    0A.3
1BAE:  BCF    03.6
1BAF:  CALL   10D
1BB0:  BSF    0A.4
1BB1:  BSF    0A.3
1BB2:  BSF    03.5
1BB3:  GOTO   395
1BB4:  BCF    03.5
....................                  lcd_goto(6, 2);
1BB5:  MOVLW  06
1BB6:  BSF    03.5
1BB7:  MOVWF  56
1BB8:  MOVLW  02
1BB9:  MOVWF  57
1BBA:  BCF    0A.4
1BBB:  BCF    03.5
1BBC:  CALL   248
1BBD:  BSF    0A.4
....................                  switch(day){
1BBE:  MOVLW  01
1BBF:  BSF    03.5
1BC0:  SUBWF  48,W
1BC1:  ADDLW  F9
1BC2:  BTFSC  03.0
1BC3:  GOTO   415
1BC4:  ADDLW  07
1BC5:  BCF    03.5
1BC6:  GOTO   5B2
....................                    case 1: lcd_out("Su"); break;
1BC7:  MOVLW  FF
1BC8:  BSF    03.6
1BC9:  MOVWF  0D
1BCA:  MOVLW  00
1BCB:  MOVWF  0F
1BCC:  BCF    0A.4
1BCD:  BCF    03.6
1BCE:  CALL   281
1BCF:  BSF    0A.4
1BD0:  BSF    03.5
1BD1:  GOTO   415
....................                    case 2: lcd_out("Mo"); break;
1BD2:  MOVLW  01
1BD3:  BSF    03.6
1BD4:  MOVWF  0D
1BD5:  MOVLW  01
1BD6:  MOVWF  0F
1BD7:  BCF    0A.4
1BD8:  BCF    03.6
1BD9:  CALL   281
1BDA:  BSF    0A.4
1BDB:  BSF    03.5
1BDC:  GOTO   415
....................                    case 3: lcd_out("Tu"); break;
1BDD:  MOVLW  03
1BDE:  BSF    03.6
1BDF:  MOVWF  0D
1BE0:  MOVLW  01
1BE1:  MOVWF  0F
1BE2:  BCF    0A.4
1BE3:  BCF    03.6
1BE4:  CALL   281
1BE5:  BSF    0A.4
1BE6:  BSF    03.5
1BE7:  GOTO   415
....................                    case 4: lcd_out("We"); break;
1BE8:  MOVLW  05
1BE9:  BSF    03.6
1BEA:  MOVWF  0D
1BEB:  MOVLW  01
1BEC:  MOVWF  0F
1BED:  BCF    0A.4
1BEE:  BCF    03.6
1BEF:  CALL   281
1BF0:  BSF    0A.4
1BF1:  BSF    03.5
1BF2:  GOTO   415
....................                    case 5: lcd_out("Th"); break;
1BF3:  MOVLW  07
1BF4:  BSF    03.6
1BF5:  MOVWF  0D
1BF6:  MOVLW  01
1BF7:  MOVWF  0F
1BF8:  BCF    0A.4
1BF9:  BCF    03.6
1BFA:  CALL   281
1BFB:  BSF    0A.4
1BFC:  BSF    03.5
1BFD:  GOTO   415
....................                    case 6: lcd_out("Fr"); break;
1BFE:  MOVLW  09
1BFF:  BSF    03.6
1C00:  MOVWF  0D
1C01:  MOVLW  01
1C02:  MOVWF  0F
1C03:  BCF    0A.4
1C04:  BCF    03.6
1C05:  CALL   281
1C06:  BSF    0A.4
1C07:  BSF    03.5
1C08:  GOTO   415
....................                    case 7: lcd_out("Sa"); break;}
1C09:  MOVLW  0B
1C0A:  BSF    03.6
1C0B:  MOVWF  0D
1C0C:  MOVLW  01
1C0D:  MOVWF  0F
1C0E:  BCF    0A.4
1C0F:  BCF    03.6
1C10:  CALL   281
1C11:  BSF    0A.4
1C12:  BSF    03.5
1C13:  GOTO   415
1C14:  BSF    03.5
....................                  if(!input(LEFT) && (!button_state)){
1C15:  BSF    06.1
1C16:  BCF    03.5
1C17:  BTFSC  06.1
1C18:  GOTO   41D
1C19:  BTFSC  21.6
1C1A:  GOTO   41D
....................                    button_state = 1;
1C1B:  BSF    21.6
....................                    break;}
1C1C:  GOTO   440
....................                  j = 0;
1C1D:  BSF    03.5
1C1E:  CLRF   4E
....................                  while((input(PIN_B2)||button_state) && input(UP) && j < 5){
1C1F:  BSF    06.2
1C20:  BCF    03.5
1C21:  BTFSC  06.2
1C22:  GOTO   425
1C23:  BTFSS  21.6
1C24:  GOTO   43F
1C25:  BSF    03.5
1C26:  BSF    06.0
1C27:  BCF    03.5
1C28:  BTFSS  06.0
1C29:  GOTO   43F
1C2A:  BSF    03.5
1C2B:  MOVF   4E,W
1C2C:  SUBLW  04
1C2D:  BTFSC  03.0
1C2E:  GOTO   431
1C2F:  BCF    03.5
1C30:  GOTO   43F
....................                    j++;
1C31:  INCF   4E,F
....................                    delay_ms(200);}
1C32:  MOVLW  C8
1C33:  BCF    03.5
1C34:  BSF    03.6
1C35:  MOVWF  6A
1C36:  BCF    0A.4
1C37:  BCF    0A.3
1C38:  BCF    03.6
1C39:  CALL   10D
1C3A:  BSF    0A.4
1C3B:  BSF    0A.3
1C3C:  BSF    03.5
1C3D:  GOTO   41F
1C3E:  BCF    03.5
1C3F:  GOTO   304
....................                }
....................                i=3;
1C40:  MOVLW  03
1C41:  BSF    03.5
1C42:  MOVWF  4D
....................                date = edit(date, 9, 2); 
1C43:  MOVF   42,W
1C44:  MOVWF  53
1C45:  MOVLW  09
1C46:  MOVWF  54
1C47:  MOVLW  02
1C48:  MOVWF  55
1C49:  BCF    0A.3
1C4A:  BCF    03.5
1C4B:  CALL   604
1C4C:  BSF    0A.3
1C4D:  MOVF   78,W
1C4E:  BSF    03.5
1C4F:  MOVWF  42
....................                i=4;
1C50:  MOVLW  04
1C51:  MOVWF  4D
....................                month = edit(month, 12, 2);
1C52:  MOVF   44,W
1C53:  MOVWF  53
1C54:  MOVLW  0C
1C55:  MOVWF  54
1C56:  MOVLW  02
1C57:  MOVWF  55
1C58:  BCF    0A.3
1C59:  BCF    03.5
1C5A:  CALL   604
1C5B:  BSF    0A.3
1C5C:  MOVF   78,W
1C5D:  BSF    03.5
1C5E:  MOVWF  44
....................                i=5;
1C5F:  MOVLW  05
1C60:  MOVWF  4D
....................                year = edit(year, 17, 2);
1C61:  MOVF   46,W
1C62:  MOVWF  53
1C63:  MOVLW  11
1C64:  MOVWF  54
1C65:  MOVLW  02
1C66:  MOVWF  55
1C67:  BCF    0A.3
1C68:  BCF    03.5
1C69:  CALL   604
1C6A:  BSF    0A.3
1C6B:  MOVF   78,W
1C6C:  BSF    03.5
1C6D:  MOVWF  46
....................                // Convert decimal to BCD
....................                minute = ((minute/10) << 4) + (minute % 10);
1C6E:  MOVF   7B,W
1C6F:  BSF    03.6
1C70:  MOVWF  10
1C71:  MOVLW  0A
1C72:  MOVWF  11
1C73:  BCF    0A.4
1C74:  BCF    0A.3
1C75:  BCF    03.5
1C76:  BCF    03.6
1C77:  CALL   3CD
1C78:  BSF    0A.4
1C79:  BSF    0A.3
1C7A:  SWAPF  78,W
1C7B:  BSF    03.5
1C7C:  MOVWF  53
1C7D:  MOVLW  F0
1C7E:  ANDWF  53,F
1C7F:  MOVF   7B,W
1C80:  BSF    03.6
1C81:  MOVWF  10
1C82:  MOVLW  0A
1C83:  MOVWF  11
1C84:  BCF    0A.4
1C85:  BCF    0A.3
1C86:  BCF    03.5
1C87:  BCF    03.6
1C88:  CALL   3CD
1C89:  BSF    0A.4
1C8A:  BSF    0A.3
1C8B:  MOVF   77,W
1C8C:  BSF    03.5
1C8D:  ADDWF  53,W
1C8E:  MOVWF  7B
....................                hour = ((hour/10) << 4) + (hour % 10);
1C8F:  MOVF   7D,W
1C90:  BSF    03.6
1C91:  MOVWF  10
1C92:  MOVLW  0A
1C93:  MOVWF  11
1C94:  BCF    0A.4
1C95:  BCF    0A.3
1C96:  BCF    03.5
1C97:  BCF    03.6
1C98:  CALL   3CD
1C99:  BSF    0A.4
1C9A:  BSF    0A.3
1C9B:  SWAPF  78,W
1C9C:  BSF    03.5
1C9D:  MOVWF  53
1C9E:  MOVLW  F0
1C9F:  ANDWF  53,F
1CA0:  MOVF   7D,W
1CA1:  BSF    03.6
1CA2:  MOVWF  10
1CA3:  MOVLW  0A
1CA4:  MOVWF  11
1CA5:  BCF    0A.4
1CA6:  BCF    0A.3
1CA7:  BCF    03.5
1CA8:  BCF    03.6
1CA9:  CALL   3CD
1CAA:  BSF    0A.4
1CAB:  BSF    0A.3
1CAC:  MOVF   77,W
1CAD:  BSF    03.5
1CAE:  ADDWF  53,W
1CAF:  MOVWF  7D
....................                date = ((date/10) << 4) + (date % 10);
1CB0:  MOVF   42,W
1CB1:  BSF    03.6
1CB2:  MOVWF  10
1CB3:  MOVLW  0A
1CB4:  MOVWF  11
1CB5:  BCF    0A.4
1CB6:  BCF    0A.3
1CB7:  BCF    03.5
1CB8:  BCF    03.6
1CB9:  CALL   3CD
1CBA:  BSF    0A.4
1CBB:  BSF    0A.3
1CBC:  SWAPF  78,W
1CBD:  BSF    03.5
1CBE:  MOVWF  53
1CBF:  MOVLW  F0
1CC0:  ANDWF  53,F
1CC1:  MOVF   42,W
1CC2:  BSF    03.6
1CC3:  MOVWF  10
1CC4:  MOVLW  0A
1CC5:  MOVWF  11
1CC6:  BCF    0A.4
1CC7:  BCF    0A.3
1CC8:  BCF    03.5
1CC9:  BCF    03.6
1CCA:  CALL   3CD
1CCB:  BSF    0A.4
1CCC:  BSF    0A.3
1CCD:  MOVF   77,W
1CCE:  BSF    03.5
1CCF:  ADDWF  53,W
1CD0:  MOVWF  42
....................                month = ((month/10) << 4) + (month % 10);
1CD1:  MOVF   44,W
1CD2:  BSF    03.6
1CD3:  MOVWF  10
1CD4:  MOVLW  0A
1CD5:  MOVWF  11
1CD6:  BCF    0A.4
1CD7:  BCF    0A.3
1CD8:  BCF    03.5
1CD9:  BCF    03.6
1CDA:  CALL   3CD
1CDB:  BSF    0A.4
1CDC:  BSF    0A.3
1CDD:  SWAPF  78,W
1CDE:  BSF    03.5
1CDF:  MOVWF  53
1CE0:  MOVLW  F0
1CE1:  ANDWF  53,F
1CE2:  MOVF   44,W
1CE3:  BSF    03.6
1CE4:  MOVWF  10
1CE5:  MOVLW  0A
1CE6:  MOVWF  11
1CE7:  BCF    0A.4
1CE8:  BCF    0A.3
1CE9:  BCF    03.5
1CEA:  BCF    03.6
1CEB:  CALL   3CD
1CEC:  BSF    0A.4
1CED:  BSF    0A.3
1CEE:  MOVF   77,W
1CEF:  BSF    03.5
1CF0:  ADDWF  53,W
1CF1:  MOVWF  44
....................                year = ((year/10) << 4) + (year % 10);
1CF2:  MOVF   46,W
1CF3:  BSF    03.6
1CF4:  MOVWF  10
1CF5:  MOVLW  0A
1CF6:  MOVWF  11
1CF7:  BCF    0A.4
1CF8:  BCF    0A.3
1CF9:  BCF    03.5
1CFA:  BCF    03.6
1CFB:  CALL   3CD
1CFC:  BSF    0A.4
1CFD:  BSF    0A.3
1CFE:  SWAPF  78,W
1CFF:  BSF    03.5
1D00:  MOVWF  53
1D01:  MOVLW  F0
1D02:  ANDWF  53,F
1D03:  MOVF   46,W
1D04:  BSF    03.6
1D05:  MOVWF  10
1D06:  MOVLW  0A
1D07:  MOVWF  11
1D08:  BCF    0A.4
1D09:  BCF    0A.3
1D0A:  BCF    03.5
1D0B:  BCF    03.6
1D0C:  CALL   3CD
1D0D:  BSF    0A.4
1D0E:  BSF    0A.3
1D0F:  MOVF   77,W
1D10:  BSF    03.5
1D11:  ADDWF  53,W
1D12:  MOVWF  46
....................                // End conversion
....................                ds1307_write(1, minute);
1D13:  MOVLW  01
1D14:  MOVWF  53
1D15:  MOVF   7B,W
1D16:  MOVWF  54
1D17:  BCF    0A.3
1D18:  BCF    03.5
1D19:  CALL   747
1D1A:  BSF    0A.3
....................                ds1307_write(2, hour);
1D1B:  MOVLW  02
1D1C:  BSF    03.5
1D1D:  MOVWF  53
1D1E:  MOVF   7D,W
1D1F:  MOVWF  54
1D20:  BCF    0A.3
1D21:  BCF    03.5
1D22:  CALL   747
1D23:  BSF    0A.3
....................                ds1307_write(3, day);
1D24:  MOVLW  03
1D25:  BSF    03.5
1D26:  MOVWF  53
1D27:  MOVF   48,W
1D28:  MOVWF  54
1D29:  BCF    0A.3
1D2A:  BCF    03.5
1D2B:  CALL   747
1D2C:  BSF    0A.3
....................                ds1307_write(4, date);
1D2D:  MOVLW  04
1D2E:  BSF    03.5
1D2F:  MOVWF  53
1D30:  MOVF   42,W
1D31:  MOVWF  54
1D32:  BCF    0A.3
1D33:  BCF    03.5
1D34:  CALL   747
1D35:  BSF    0A.3
....................                ds1307_write(5, month);
1D36:  MOVLW  05
1D37:  BSF    03.5
1D38:  MOVWF  53
1D39:  MOVF   44,W
1D3A:  MOVWF  54
1D3B:  BCF    0A.3
1D3C:  BCF    03.5
1D3D:  CALL   747
1D3E:  BSF    0A.3
....................                ds1307_write(6, year);
1D3F:  MOVLW  06
1D40:  BSF    03.5
1D41:  MOVWF  53
1D42:  MOVF   46,W
1D43:  MOVWF  54
1D44:  BCF    0A.3
1D45:  BCF    03.5
1D46:  CALL   747
1D47:  BSF    0A.3
....................                ds1307_write(0, 0);
1D48:  BSF    03.5
1D49:  CLRF   53
1D4A:  CLRF   54
1D4B:  BCF    0A.3
1D4C:  BCF    03.5
1D4D:  CALL   747
1D4E:  BSF    0A.3
....................              }
....................              if(!input(RIGHT) && (!button_state)){
1D4F:  BSF    03.5
1D50:  BSF    06.3
1D51:  BCF    03.5
1D52:  BTFSC  06.3
1D53:  GOTO   59E
1D54:  BTFSC  21.6
1D55:  GOTO   59E
....................                button_state = 1;
1D56:  BSF    21.6
....................                i=6;
1D57:  MOVLW  06
1D58:  BSF    03.5
1D59:  MOVWF  4D
....................                alarm1_hour = edit(alarm1_hour, 29, 1);
1D5A:  MOVF   4A,W
1D5B:  MOVWF  53
1D5C:  MOVLW  1D
1D5D:  MOVWF  54
1D5E:  MOVLW  01
1D5F:  MOVWF  55
1D60:  BCF    0A.3
1D61:  BCF    03.5
1D62:  CALL   604
1D63:  BSF    0A.3
1D64:  MOVF   78,W
1D65:  BSF    03.5
1D66:  MOVWF  4A
....................                i=7;
1D67:  MOVLW  07
1D68:  MOVWF  4D
....................                alarm1_minute = edit(alarm1_minute, 32, 1);
1D69:  MOVF   49,W
1D6A:  MOVWF  53
1D6B:  MOVLW  20
1D6C:  MOVWF  54
1D6D:  MOVLW  01
1D6E:  MOVWF  55
1D6F:  BCF    0A.3
1D70:  BCF    03.5
1D71:  CALL   604
1D72:  BSF    0A.3
1D73:  MOVF   78,W
1D74:  BSF    03.5
1D75:  MOVWF  49
....................                i=6;
1D76:  MOVLW  06
1D77:  MOVWF  4D
....................                alarm2_hour = edit(alarm2_hour, 29, 2);
1D78:  MOVF   4C,W
1D79:  MOVWF  53
1D7A:  MOVLW  1D
1D7B:  MOVWF  54
1D7C:  MOVLW  02
1D7D:  MOVWF  55
1D7E:  BCF    0A.3
1D7F:  BCF    03.5
1D80:  CALL   604
1D81:  BSF    0A.3
1D82:  MOVF   78,W
1D83:  BSF    03.5
1D84:  MOVWF  4C
....................                i=7;
1D85:  MOVLW  07
1D86:  MOVWF  4D
....................                alarm2_minute = edit(alarm2_minute, 32, 2);
1D87:  MOVF   4B,W
1D88:  MOVWF  53
1D89:  MOVLW  20
1D8A:  MOVWF  54
1D8B:  MOVLW  02
1D8C:  MOVWF  55
1D8D:  BCF    0A.3
1D8E:  BCF    03.5
1D8F:  CALL   604
1D90:  BSF    0A.3
1D91:  MOVF   78,W
1D92:  BSF    03.5
1D93:  MOVWF  4B
....................                delay_ms(200); 
1D94:  MOVLW  C8
1D95:  BCF    03.5
1D96:  BSF    03.6
1D97:  MOVWF  6A
1D98:  BCF    0A.4
1D99:  BCF    0A.3
1D9A:  BCF    03.6
1D9B:  CALL   10D
1D9C:  BSF    0A.4
1D9D:  BSF    0A.3
....................              }
....................              if(input(UP) == 0){
1D9E:  BSF    03.5
1D9F:  BSF    06.0
1DA0:  BCF    03.5
1DA1:  BTFSC  06.0
1DA2:  GOTO   5A3
1DA3:  BSF    03.5
....................                //output_low(PIN_B5);
....................              }
....................         }
1DA4:  BCF    03.5
1DA5:  GOTO   130
....................    }
.................... }
....................  
1DA6:  SLEEP
.................... 

Configuration Fuses:
   Word  1: 2CE2   HS NOWDT PUT MCLR NOPROTECT NOCPD NOBROWNOUT IESO FCMEN NOLVP NODEBUG
   Word  2: 3FFF   BORV40 NOWRT
